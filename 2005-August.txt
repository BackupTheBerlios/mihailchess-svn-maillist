From gauleng at berlios.de  Wed Aug 10 02:30:19 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Wed, 10 Aug 2005 02:30:19 +0200
Subject: [Mihailchess-svn] r28 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508100030.j7A0UJiM014506@sheep.berlios.de>

Author: gauleng
Date: 2005-08-10 02:30:19 +0200 (Wed, 10 Aug 2005)
New Revision: 28

Modified:
   trunk/MihailChessLib/com/mihail/chess/Logica.java
   trunk/MihailChessLib/com/mihail/chess/Pieza.java
   trunk/MihailChessLib/com/mihail/chess/Posicion.java
Log:
Pasados los ultimos dos metodos de la logica antigua a la nueva: generarNotacionALG y moverALG

Modified: trunk/MihailChessLib/com/mihail/chess/Logica.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-10 00:30:19 UTC (rev 28)
@@ -866,8 +866,168 @@
 		}
 		return devolver;
 	}
-	
+
 	/**
-	 * TODO moverALG y getFEN ?
+	 * Interpreta un movimiento en notacion algebraica y lo realiza en la
+	 * Logica. NOTA: Partimos de la base de que el turno corresponde con el
+	 * movimiento que se recibe: no se puede dar el caso de que se reciba un
+	 * movimiento de negras y que el turno pertenezca a blancas o viceversa.
+	 * 
+	 * @param mov
+	 *            String que contiene el movimiento en notacion algebraica.
+	 * @todo Poner las ambig?edades de la dama
+	 * @todo Puede ser que tengamos un problema: cuando una pieza esta clavada
+	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
+	 *       tenerlo en cuenta.
 	 */
+	public Movimiento moverALG(String mov) {
+		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
+		char tipoPieza = 'P';
+		Tipo piezaCoronacion = null;
+		int contadorOesEnroque = 0, i;
+		boolean finDestino = false;
+
+		for (i = mov.length() - 1; i >= 0; i--) {
+			switch (mov.charAt(i)) {
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+				if (!finDestino) {
+					destinoNum = mov.charAt(i);
+				} else {
+					origenNum = mov.charAt(i);
+				}
+				break;
+			case 'a':
+			case 'b':
+			case 'c':
+			case 'd':
+			case 'e':
+			case 'f':
+			case 'g':
+			case 'h':
+				if (!finDestino) {
+					destinoLetra = mov.charAt(i);
+				} else {
+					origenLetra = mov.charAt(i);
+				}
+				finDestino = true;
+				break;
+			case 'B':
+				if (i != 0) {
+					piezaCoronacion = Tipo.ALFIL;
+				} else {
+					tipoPieza = 'A';
+				}
+				break;
+			case 'K':
+				tipoPieza = 'R';
+				break;
+			case 'N':
+				if (i != 0) {
+					piezaCoronacion = Tipo.CABALLO;
+				} else {
+					tipoPieza = 'C';
+				}
+				break;
+			case 'Q':
+				if (i != 0) {
+					piezaCoronacion = Tipo.DAMA;
+				} else {
+					tipoPieza = 'D';
+				}
+				break;
+			case 'R':
+				if (i != 0) {
+					piezaCoronacion = Tipo.TORRE;
+				} else {
+					tipoPieza = 'T';
+				}
+				break;
+			case '0':
+			case 'o':
+			case 'O':
+				contadorOesEnroque++;
+				break;
+			case 'x':
+			case '+':
+			case '!':
+			case '?':
+			case '-':
+			case '=':
+				break;
+			default:
+				System.out.print("Caracter desconocido: " + mov.charAt(i));
+				break;
+			}
+		}
+		if(piezaCoronacion!=null) {
+			// TODO hacer el mostrarDialogoCoronacion;
+			coronar = piezaCoronacion;
+		}
+		// Enroque Corto
+		if (contadorOesEnroque == 2) {
+			origenLetra = 'e';
+			destinoLetra = 'g';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else if (contadorOesEnroque == 3) {
+			origenLetra = 'e';
+			destinoLetra = 'c';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else {
+			Casilla c = new Casilla(destinoLetra, destinoNum);
+			if (origenLetra == '\0' && origenNum != '\0') {
+				for (char ii = 'a'; ii <= 'h'; ii++) {
+					Pieza p = posicion.getPieza(ii, origenNum);
+					if (p.canMove(c)) {
+						origenLetra = ii;
+						break;
+					}
+				}
+			} else if (origenLetra != '\0' && origenNum == '\0') {
+				for (char ii = '1'; ii <= '8'; ii++) {
+					Pieza p = posicion.getPieza(origenLetra, ii);
+					if (p.canMove(c)) {
+						origenNum = ii;
+						break;
+					}
+				}
+			} else {
+				for (char ii = '1'; ii <= '8'; ii++) {
+					for (char jj = 'a'; jj <= 'h'; jj++) {
+						Pieza p = posicion.getPieza(jj, ii);
+						if (p.canMove(c)) {
+							origenNum = ii;
+							break;
+						}
+					}
+				}
+			}
+		}
+		if (origenLetra == '\0' || origenNum == '\0' || destinoLetra == '\0'
+				|| destinoNum == '\0') {
+			System.out.println(tipoPieza + " " + origenLetra + " " + origenNum
+					+ " " + destinoLetra + " " + destinoNum);
+			return null;
+		} else {
+			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
+		}
+	}
 }

Modified: trunk/MihailChessLib/com/mihail/chess/Pieza.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-10 00:30:19 UTC (rev 28)
@@ -216,4 +216,8 @@
 	public void setCasilla(Casilla casilla) {
 		this.casilla = casilla;
 	}
+	
+	public boolean canMove(Casilla casilla) {
+		return casillasValidas.contains(casilla);
+	}
 }
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/Posicion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-10 00:30:19 UTC (rev 28)
@@ -3,6 +3,9 @@
 import static com.mihail.chess.Logica.Bando;
 import static com.mihail.chess.Pieza.Tipo;
 
+import com.mihail.chess.Logica.Resultado;
+import com.mihail.chess.Pieza.Tipo;
+
 public class Posicion {
 
 	/**
@@ -758,7 +761,98 @@
 	public Casilla getKingPosition(Bando color) {
 		return kingPosition[bandoToInt(color)];
 	}
+	
+	/**
+	 * Genera la notaci?n algebraica de un movimiento.
+	 * 
+	 * @param mov
+	 *            Objeto movimiento del que se generara la notacion algebraica.
+	 * @return Una cadena con el movimiento expresado en notacion algebraica,
+	 *         (por ejemplo: Nf3, e6, Bd5...)
+	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
+	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
+	 */
+	private String generarNotacionALG (Movimiento mov) {
+		StringBuffer temp = new StringBuffer ();
 
+		if (mov.getTipoPieza() == Tipo.REY) {
+			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
+				if (mov.getCasillaDestino().getLetra() == 'g') {
+					temp.append ("O-O");
+				}
+				else { // mov.destinoLetra == 'c'
+					temp.append ("O-O-O");
+				}
+				return temp.toString ();
+			}
+		}
+		if (mov.getTipoPieza() != Tipo.PEON) {
+			temp.append (tipoToEnglish (mov.getTipoPieza()));
+		}
+		Pieza pieza = getPieza (mov.getCasillaDestino());
+		switch (mov.getTipoPieza()) {
+			case PEON:
+				if (mov.getCasillaComer() != null)
+					temp.append (mov.getCasillaOrigen().getLetra());
+				break;
+			case CABALLO:
+				for(VectorDireccion v: pieza.getDirecciones()) {
+					try {
+						Pieza p = getPieza(mov.getCasillaDestino().add(v));
+						if(p!=null && p.getTipo() == Tipo.CABALLO && p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+
+			case ALFIL:
+			case TORRE:
+			case DAMA:
+				for(VectorDireccion v: pieza.getDirecciones()) {
+					try {
+						Casilla destino = mov.getCasillaDestino().add(v);
+						Pieza p;
+						while((p=getPieza(destino))==null) {
+							destino.add(v);
+						}
+						if(p!=null && p.getTipo() == pieza.getTipo() && p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+		}
+
+		if (mov.getCasillaComer() != null)
+			temp.append ("x");
+
+		temp.append (mov.getCasillaDestino().toString());
+
+		if (mov.getCoronacion() != null)
+			temp.append ("=" + tipoToEnglish (mov.getCoronacion()));
+
+		if (mov.isJaque())
+			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
+					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
+				temp.append ("#");
+			else
+				temp.append ("+");
+		return temp.toString ();
+	}
+
 	/**
 	 * Funciones de uso interno. No usar directamente
 	 * 



From gauleng at berlios.de  Wed Aug 10 02:38:00 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Wed, 10 Aug 2005 02:38:00 +0200
Subject: [Mihailchess-svn] r29 - trunk/MihailChessLib
Message-ID: <200508100038.j7A0c0En018207@sheep.berlios.de>

Author: gauleng
Date: 2005-08-10 02:37:52 +0200 (Wed, 10 Aug 2005)
New Revision: 29

Added:
   trunk/MihailChessLib/estructura.txt
Modified:
   trunk/MihailChessLib/TODO
Log:
Anadido esto para mas info (Se ruega leer xD)

Modified: trunk/MihailChessLib/TODO
===================================================================
--- trunk/MihailChessLib/TODO	2005-08-10 00:30:19 UTC (rev 28)
+++ trunk/MihailChessLib/TODO	2005-08-10 00:37:52 UTC (rev 29)
@@ -1,4 +1,4 @@
 - Cambiar nombre metodo Casilla.add
 - Cambiar nombre clase TablaHash
 - En vez de usar int clave en los Diccionarios, usar Posicion posicion.
-- Tratar de usar la clase Casilla lo maximo posible, en vez de dos chars.
\ No newline at end of file
+- Tratar de usar la clase Casilla lo maximo posible, en vez de dos chars.

Added: trunk/MihailChessLib/estructura.txt
===================================================================
--- trunk/MihailChessLib/estructura.txt	2005-08-10 00:30:19 UTC (rev 28)
+++ trunk/MihailChessLib/estructura.txt	2005-08-10 00:37:52 UTC (rev 29)
@@ -0,0 +1,45 @@
+com.mihail.chess:
+
+ArbolVariantes
+Casilla
+DiccionarioPosiciones
+Logica
+Movimiento
+Pieza
+Posicion
+VectorDireccion
+
+Reloj
+RelojException
+
+Partida
+
+com.mihail.util:
+TablaMovimientosModel
+FiltroArchivos
+IPTextField
+Renderers ??
+
+com.mihail.ui:
+Tablero2D
+TableroGrafico
+RelojDigital
+PanelMovimientos
+
+=================================
+Posible solucion a las coronaciones y otros problemas de la logica:
+
+A?adir una nueva clase tipo BoardListener, que se encarga de gestionar las
+acciones que dependen de la interfaz.
+
+Los metodos que tendria esta nueva clase:
+
+promotionEvent: Se llamaria cuando hay coronacion. El escuchador
+cambiaria los valores adecuados de la logica para coronar a lo deseado.
+
+avanzarEvent retrocederEvent (y en spanglish por supuesto): Se ejecutaria
+en los casos que se ordena a la logica avanzar y retroceder en la partida,
+y existen variantes alternativas a la principal. La mision del escuchador
+seria determinar que variante se elige.
+
+Podrian existir mas situaciones que dependen del uso de la logica?
\ No newline at end of file



From gauleng at berlios.de  Sat Aug 13 01:35:52 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sat, 13 Aug 2005 01:35:52 +0200
Subject: [Mihailchess-svn] r30 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508122335.j7CNZqd7021015@sheep.berlios.de>

Author: gauleng
Date: 2005-08-13 01:35:50 +0200 (Sat, 13 Aug 2005)
New Revision: 30

Added:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
Log:
Clase para gestionar los temas para usar en tableros graficos

Added: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-10 00:37:52 UTC (rev 29)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-12 23:35:50 UTC (rev 30)
@@ -0,0 +1,154 @@
+package com.mihail.chess;
+
+import java.awt.Image;
+import java.io.File;
+import java.io.IOException;
+import java.io.InputStream;
+import java.net.URISyntaxException;
+import java.net.URL;
+import java.util.Enumeration;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipException;
+import java.util.zip.ZipFile;
+
+import javax.swing.ImageIcon;
+
+import com.mihail.chess.Logica.Bando;
+import com.mihail.chess.Pieza.Tipo;
+
+/**
+ * Representa el tema de imagenes de piezas, texturas de las casillas, textura
+ * del borde del tablero y textura de fondo del tablero. Para crear un tema
+ * basta pasarle la ruta a un archivo .mcz cuyos contenidos estan especificados
+ * de la siguiente manera:
+ * 
+ * Todas las imagenes podran estar en formatos que soporte Java por defecto. En la 
+ * version actual valen: png, jpeg y gif
+ * 
+ * Las imagenes de las piezas deberan estar formadas por el nombre de la pieza
+ * mas la inicial del bando al que pertenecen. Por ejemplo, el peon negro seria
+ * 'peonN.png', y el rey blanco 'reyB.png'.
+ * 
+ * Las casillas seran 'casillaB.png' y 'casillaN.png'.
+ * 
+ * El borde del tablero 'marco.png'.
+ * 
+ * El fondo del tablero 'fondo.png'.
+ * 
+ * Ademas se debera a?adir un archivo de texto, de nomre Metadata, en el
+ * que se podra indicar cierta informacion como el autor, la fecha de creacion y el
+ * nombre del tema.
+ * 
+ * @author wotan
+ *
+ */
+
+public class BoardTheme {
+	/*
+	 * Imagenes del tema
+	 */
+	private Image[] pieceImages = new Image[12];
+	private Image[] casillasImages = new Image[2];
+	private Image marco;
+	private Image background;
+	
+	/*
+	 * Informacion del tema
+	 */
+	private String autor;
+	private String nombre;
+	
+	/**
+	 * Crea un nuevo tema a partir de una ruta a el archivo ,mcz
+	 * 
+	 * @param path Ruta al archivo.
+	 */
+	
+	public BoardTheme(String path) {
+		File file = new File(path);
+		loadZip(file);
+	}
+	
+	/**
+	 * Crea un tema a partir de una URL donde se encuentra el archivo .mcz
+	 * Es util usar este metodo en caso de que el tema se encuentre dentro
+	 * de un archivo jar. Para cargarlo cuando se da esta situacion, no habria
+	 * que hacer mas que esta llamada:
+	 * 
+	 * new BoardTheme(getClass().getResource("/ruta/dentro/del/jar"))
+	 * 
+	 * @param path
+	 */
+	
+	public BoardTheme(URL path) {
+		try {
+			File file = new File(path.toURI());
+			loadZip(file);
+		} catch (URISyntaxException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+	
+	public Image getImagePiece(Bando bando, Tipo tipo) {
+		return pieceImages[bandoToInt(bando) * tipoToInt(tipo)];
+	}
+	
+	public Image getImageCasilla(Bando bando) {
+		return casillasImages[bandoToInt(bando)-1];
+	}
+	
+	public Image getMarco() {
+		return marco;
+	}
+	
+	public Image getBackground() {
+		return background;
+	}
+	
+	private int bandoToInt(Bando bando) {
+		return bando == Bando.BLANCO? 1:2;
+	}
+	
+	private int tipoToInt(Tipo tipo) {
+		switch(tipo) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		}
+		return -1;
+	}
+	
+	private void loadZip(File file) {
+		try {
+			ZipFile zipFile = new ZipFile(file);
+			for(Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
+				ZipEntry entry = e.nextElement();
+				
+				InputStream is = zipFile.getInputStream(entry);
+				String entryName = entry.getName();
+				System.out.println(entryName);
+				if(entryName.equals("reyB.png")) { // Cargar todas las imagenes en funcion de los nombres
+					byte [] data = new byte[is.available()];
+					is.read(data);
+					pieceImages[5] = new ImageIcon(data).getImage();
+				} /* ... TODO ... */
+			}
+		} catch (ZipException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		} catch (IOException e) {
+			// TODO Auto-generated catch block
+			e.printStackTrace();
+		}
+	}
+}



From gauleng at berlios.de  Sat Aug 13 02:42:25 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sat, 13 Aug 2005 02:42:25 +0200
Subject: [Mihailchess-svn] r31 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508130042.j7D0gPeZ011768@sheep.berlios.de>

Author: gauleng
Date: 2005-08-13 02:42:21 +0200 (Sat, 13 Aug 2005)
New Revision: 31

Modified:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
Log:
Adaptado Tablero2D para usar el BoardTheme

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-13 00:42:21 UTC (rev 31)
@@ -19,7 +19,8 @@
 /**
  * Representa el tema de imagenes de piezas, texturas de las casillas, textura
  * del borde del tablero y textura de fondo del tablero. Para crear un tema
- * basta pasarle la ruta a un archivo .mcz cuyos contenidos estan especificados
+ * basta pasarle la ruta a un archivo .mcz. Un archivo en este
+ * formato es un archivo comprimido Zip cuyos contenidos estan especificados
  * de la siguiente manera:
  * 
  * Todas las imagenes podran estar en formatos que soporte Java por defecto. En la 
@@ -27,15 +28,18 @@
  * 
  * Las imagenes de las piezas deberan estar formadas por el nombre de la pieza
  * mas la inicial del bando al que pertenecen. Por ejemplo, el peon negro seria
- * 'peonN.png', y el rey blanco 'reyB.png'.
+ * 'peonN.png', y el rey blanco 'reyB.png'. Son imagenes obligatorias.
  * 
- * Las casillas seran 'casillaB.png' y 'casillaN.png'.
+ * Las casillas seran 'casillaB.png' y 'casillaN.png'. Estas imagenes son optativas,
+ * y el tablero puede dibujarse sin ellas con colores lisos.
  * 
- * El borde del tablero 'marco.png'.
+ * El borde del tablero 'marco.png'. Esta imagen es optativa, del mismo modo que la 
+ * anterior.
  * 
- * El fondo del tablero 'fondo.png'.
+ * El fondo del tablero 'fondo.png'. Esta imagen es optativa, del mismo moo que la 
+ * anterior.
  * 
- * Ademas se debera a?adir un archivo de texto, de nomre Metadata, en el
+ * Ademas se debera a?adir un archivo de texto, de nombre Metadata, en el
  * que se podra indicar cierta informacion como el autor, la fecha de creacion y el
  * nombre del tema.
  * 
@@ -137,11 +141,41 @@
 				InputStream is = zipFile.getInputStream(entry);
 				String entryName = entry.getName();
 				System.out.println(entryName);
+				byte [] data = new byte[is.available()];
+				is.read(data);
 				if(entryName.equals("reyB.png")) { // Cargar todas las imagenes en funcion de los nombres
-					byte [] data = new byte[is.available()];
-					is.read(data);
 					pieceImages[5] = new ImageIcon(data).getImage();
-				} /* ... TODO ... */
+				} else if (entryName.equals("reyN.png")) {
+					pieceImages[11] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("damaB.png")) {
+					pieceImages[4] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("damaN.png")) {
+					pieceImages[10] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("torreB.png")) {
+					pieceImages[3] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("torreN.png")) {
+					pieceImages[9] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("caballoB.png")) {
+					pieceImages[1] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("caballoN.png")) {
+					pieceImages[7] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("alfilB.png")) {
+					pieceImages[2] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("alfilN.png")) {
+					pieceImages[8] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("peonB.png")) {
+					pieceImages[0] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("peonN.png")) {
+					pieceImages[6] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("casillaB.png")) {
+					casillasImages[0] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("casillaN.png")) {
+					casillasImages[1] = new ImageIcon(data).getImage();
+				} else if (entryName.equals("marco.png")) {
+					marco = new ImageIcon(data).getImage();
+				} else if (entryName.equals("fondo.png")) {
+					background = new ImageIcon(data).getImage();
+				}
 			}
 		} catch (ZipException e) {
 			// TODO Auto-generated catch block

Modified: trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 00:42:21 UTC (rev 31)
@@ -28,45 +28,34 @@
  * @author Iago Porto D?az
  */
 public class Tablero2D extends JPanel {
-	/**
-	 * Indica los diferentes tipos de casillas que el tablero puede dibujar.<br>
-	 * CASILLA_LISO indica una textura formada por un unico color.<br>
-	 * CASILLA_GRADIENTE indica una textura formada por dos colores que hacen un
-	 * gradiente.<br>
-	 * CASILLA_TEXTURA indica una textura que es una imagen.<br>
-	 * 
-	 */
-	public static enum Textura {
-		CASILLA_LISO, CASILLA_GRADIENTE, CASILLA_TEXTURA
-	}
 
 	private static final long serialVersionUID = 1L;
 
-	/**
+	/*
 	 * Tama?o del borde del tablero.
 	 */
 	private int BORDE = 30;
 
-	/**
+	/*
 	 * Tama?o de la casilla.
 	 */
 	private int TAM;
 
-	/**
+	/*
 	 * Tama?o anterior, para comparar si es necesario redimensionar.
 	 * 
 	 * @TODO ?Es necesario este atributo? Queda chapucero.
 	 */
 	private int TAMant;
 
-	/**
+	/*
 	 * Coordenada 'x' de la casilla pulsada por ultima vez [0, 8]. Sirve para
 	 * indicar al metodo de dibujo que la casilla indicada no se debe dibujar si
 	 * se esta arrastrando la pieza.
 	 */
 	protected int posX;
 
-	/**
+	/*
 	 * Coordenada 'y' de la casilla pulsada por ultima vez [0, 8].
 	 */
 	protected int posY;
@@ -83,9 +72,6 @@
 	// Versiones ajustadas al tama?o correcto de las imagenes
 	private Image[][] piezas = new Image[2][6];
 
-	// Imagenes de las piezas tal y como aparecen en el archivo
-	private Image[][] imagenes = new Image[2][6];
-
 	// Indica el sentido en el que se esta dibujando el tablero
 	private boolean sentido = true;
 
@@ -97,7 +83,7 @@
 	// Indica si se esta arrastrando una pieza
 	private boolean arrastrando = false;
 
-	/**
+	/*
 	 * Posicion de la pieza que se esta arrastrando. Se usa en el metodo de
 	 * dibujo para dibujar la pieza piezaArrastrada en el lugar correcto. TODO
 	 * Remodelar para a?adir objetos arbitrarios al tablero, entre ellos piezas
@@ -105,57 +91,35 @@
 	 */
 	private int posPiezaX, posPiezaY;
 
-	/**
+	/*
 	 * Imagen de la pieza qu esta siendo arrastrada.
 	 */
 	private Image piezaArrastrada;
 
-	/**
-	 * Opciones configurables de color del tablero:
+	/*
+	 * Colores que se dibujan las casillas en caso de que el tema no lo
+	 * establezca.
 	 */
-	private Textura textura = Textura.CASILLA_LISO;
-
 	private Color[] colorLiso = new Color[2];
 
-	private Color[] colorGradiente = new Color[2];
+	/*
+	 * Tema que esta usando el tablero para dibujarse.
+	 */
 
-	private Image[] colorTextura = new Image[2];
+	private BoardTheme theme;
 
-	public Tablero2D() {
-		this(60);
+	public Tablero2D(BoardTheme theme) {
+		this(theme, 60);
 	}
 
-	public Tablero2D(int tam) {
+	public Tablero2D(BoardTheme theme, int tam) {
 		super();
 		tablero = new Posicion();
 
 		TAM = tam;
-		imagenes[0][0] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/peonB.png"))).getImage();
-		imagenes[0][1] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/caballoB.png"))).getImage();
-		imagenes[0][2] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/alfilB.png"))).getImage();
-		imagenes[0][3] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/torreB.png"))).getImage();
-		imagenes[0][4] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/damaB.png"))).getImage();
-		imagenes[0][5] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/reyB.png"))).getImage();
-		imagenes[1][0] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/peonN.png"))).getImage();
-		imagenes[1][1] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/caballoN.png"))).getImage();
-		imagenes[1][2] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/alfilN.png"))).getImage();
-		imagenes[1][3] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/torreN.png"))).getImage();
-		imagenes[1][4] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/damaN.png"))).getImage();
-		imagenes[1][5] = (new ImageIcon(getClass().getResource(
-				"/piezas/modernas/reyN.png"))).getImage();
 
 		// this.setAutoscrolls(true);
+		this.theme = theme;
 
 		redimensionar();
 	}
@@ -189,8 +153,12 @@
 		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
 		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
 
-		g.setColor(Color.LIGHT_GRAY);
-		g.fillRect(0, 0, getWidth(), getHeight());
+		if(theme.getBackground()==null) {
+			g.setColor(Color.LIGHT_GRAY);
+			g.fillRect(0, 0, getWidth(), getHeight());
+		} else {
+			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
+		}
 
 		if (getWidth() < getHeight()) {
 			bordeSUP = (getHeight() - getWidth()) / 2;
@@ -214,21 +182,15 @@
 				// casillas blancas o negras
 				// if (activado) {
 				int v = (i + j) % 2;
+				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
+						: Bando.NEGRO);
+				if (textura != null)
 
-				if (textura == Textura.CASILLA_TEXTURA)
+					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
 
-					g.drawImage(colorTextura[v], i * TAM, j * TAM, TAM, TAM,
-							null);
-
-				else if (textura == Textura.CASILLA_LISO) {
+				else {
 					g.setColor(colorLiso[v]);
 					g.fillRect(i * TAM, j * TAM, TAM, TAM);
-				} else if (textura == Textura.CASILLA_GRADIENTE) {
-
-					g2d.setPaint(new GradientPaint(new Point(i * TAM, j * TAM),
-							colorLiso[v], new Point(i * TAM + TAM, j * TAM
-									+ TAM), colorGradiente[v]));
-					g.fillRect(i * TAM, j * TAM, TAM, TAM);
 				}
 
 				// Dibujamos la casilla
@@ -279,8 +241,8 @@
 						continue;
 					}
 
-					g.drawImage(getImage(temp.getBando(), temp.getTipo()), i
-							* TAM, j * TAM, null);
+					g.drawImage(theme.getImagePiece(temp.getBando(), temp
+							.getTipo()), i * TAM, j * TAM, null);
 
 				}
 			}
@@ -310,15 +272,6 @@
 	}
 
 	/**
-	 * @param borde
-	 *            Establece el tama?o del borde.
-	 */
-
-	public void setBorde(int borde) {
-		BORDE = borde;
-	}
-
-	/**
 	 * @return Devuelve el tama?o de las casilla.
 	 */
 
@@ -425,96 +378,42 @@
 	}
 
 	/**
-	 * Obtiene el modo de textura que se esta utilizando actualmente.
-	 * 
-	 * @return El modo de textura.
-	 */
-
-	public Textura getTextura() {
-		return textura;
-	}
-	
-	/**
-	 * Establece el modo de textura.
-	 * 
-	 * @param textura El modo de textura.
-	 */
-
-	public void setTextura(Textura textura) {
-		this.textura = textura;
-	}
-	
-	/**
-	 * Obtiene el color de degradado de las casillas de un color.
-	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
-	 * @return El color de degradado.
-	 */
-
-	public Color getColorGradiente(Bando b) {
-		return colorGradiente[bandoToInt(b)];
-	}
-	
-	/**
-	 * Establece el color de degradado de las casillas de un color. Este
-	 * color solo se mostrara si la opcion textura esta establecida a CASILLA_GRADIENTE.
-	 * El degradado se hara con el color establecido como liso.
-	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
-	 * @param colorGradiente El color de degradado.
-	 */
-
-	public void setColorGradiente(Bando b, Color colorGradiente) {
-		this.colorGradiente[bandoToInt(b)] = colorGradiente;
-	}
-
-	/**
 	 * Obtiene el color liso de las casillas de un color.
 	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
 	 * @return El color liso.
 	 */
 	public Color getColorLiso(Bando b) {
 		return colorLiso[bandoToInt(b)];
 	}
-	
+
 	/**
-	 * Establece el color liso de las casillas de un color. Este color
-	 * solo se mostrara si la opcion textura esta establecida a 
-	 * CASILLA_LISO.
+	 * Establece el color liso de las casillas de un color. Este color solo se
+	 * mostrara en caso de que el tema no establezca una textura para las
+	 * casillas.
 	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
-	 * @param colorLiso El color liso.
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
+	 * @param colorLiso
+	 *            El color liso.
 	 */
 
 	public void setColorLiso(Bando b, Color colorLiso) {
 		this.colorLiso[bandoToInt(b)] = colorLiso;
 	}
-	
-	/**
-	 * Obtiene la textura de las casillas de un color.
-	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
-	 * @return La textura del bando indicado.
-	 */
 
-	public Image getColorTextura(Bando b) {
-		return colorTextura[bandoToInt(b)];
-	}
-	
 	/**
-	 * Establece la textura de las casillas de un color. Esta textura solo
-	 * se mostrara si la opcion textura esta establecida a 
-	 * CASILLA_TEXTURA.
+	 * Establece el tema que usa el tablero para dibujarse.
 	 * 
-	 * @param b El tipo de las casillas, blancas o negras.
-	 * @param colorTextura La imagen que queremos establecer como textura.
+	 * @param theme
+	 *            Tema a establecer.
 	 */
 
-	public void setColorTextura(Bando b, Image colorTextura) {
-		this.colorTextura[bandoToInt(b)] = colorTextura;
+	public void setTema(BoardTheme theme) {
+		this.theme = theme;
 	}
-	
+
 	/*
 	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
 	 * el centro de la casilla. TODO Modificar para que funcione con la esquina
@@ -524,7 +423,7 @@
 	protected void repintarCasilla(int x, int y) {
 		repaint(x - TAM / 2, y - TAM / 2, TAM, TAM);
 	}
-	
+
 	/**
 	 * Metodo de utilidad para obtener de forma sencilla la casilla
 	 * correspondiente a la que pertenece un pixel en la posicion (x, y).
@@ -546,77 +445,55 @@
 		}
 		return new Point(posX, posY);
 	}
-	
-	protected Image getImage(Bando color, Tipo pieza) {
-		// if (p != null) {
-		switch (pieza) {
-		case PEON:
-			return piezas[bandoToInt(color)][0];
 
-		case CABALLO:
-			return piezas[bandoToInt(color)][1];
-
-		case ALFIL:
-			return piezas[bandoToInt(color)][2];
-
-		case TORRE:
-			return piezas[bandoToInt(color)][3];
-
-		case DAMA:
-			return piezas[bandoToInt(color)][4];
-
-		case REY:
-			return piezas[bandoToInt(color)][5];
-
-		default:
-			return null;
-		}
-
-	}
-	
 	private void dibujarBorde(Graphics g) {
-		g.setColor(Color.BLACK);
+		Image borde = theme.getMarco();
+		if (borde != null) {
+			g.drawImage(borde, 0, 0, null);
+		} else { // Dibujamos a mano
+			g.setColor(Color.BLACK);
 
-		g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
-				getWidth(), getHeight()));
-		// char num = '8';
-		// char let = 'a';
+			g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
+					getWidth(), getHeight()));
+			// char num = '8';
+			// char let = 'a';
 
-		g.setColor(new Color(209, 193, 134));
-		g.setFont(new Font("Arial", Font.BOLD, 12));
+			g.setColor(new Color(209, 193, 134));
+			g.setFont(new Font("Arial", Font.BOLD, 12));
 
-		int yF = 8 * TAM + BORDE * 3 / 2 + 6;
-		for (int i = 0; i < 8; i++) {
-			int xF = i * TAM + BORDE + TAM / 2;
-			if (sentido) {
-				g
-						.drawString(new Character((char) (i + 'A')).toString(),
-								xF, yF);
-			} else {
-				g.drawString(new Character((char) (7 - i + 'A')).toString(),
-						xF, yF);
+			int yF = 8 * TAM + BORDE * 3 / 2 + 6;
+			for (int i = 0; i < 8; i++) {
+				int xF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
+					g.drawString(new Character((char) (i + 'A')).toString(),
+							xF, yF);
+				} else {
+					g.drawString(
+							new Character((char) (7 - i + 'A')).toString(), xF,
+							yF);
+				}
 			}
-		}
-		int xF = BORDE / 2 - 3;
-		for (int i = 0; i < 8; i++) {
-			yF = i * TAM + BORDE + TAM / 2;
-			if (sentido) {
+			int xF = BORDE / 2 - 3;
+			for (int i = 0; i < 8; i++) {
+				yF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
 
-				g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
+					g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
 
-			} else {
-				g.drawString(new Integer(i + 1).toString(), xF, yF);
+				} else {
+					g.drawString(new Integer(i + 1).toString(), xF, yF);
+				}
 			}
 		}
 	}
-	
+
 	private int bandoToInt(Bando b) {
 		if (b == Bando.BLANCO) {
 			return 0;
 		}
 		return 1;
 	}
-	
+
 	/*
 	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
 	 * tama?o adecuado del tablero
@@ -626,8 +503,8 @@
 		MediaTracker media = new MediaTracker(this);
 		for (int i = 0; i < 2; i++) {
 			for (int j = 0; j < 6; j++) {
-				piezas[i][j] = imagenes[i][j].getScaledInstance(TAM, TAM,
-						Image.SCALE_SMOOTH);
+				piezas[i][j] = theme.getImagePiece(Bando.BLANCO, Tipo.ALFIL)
+						.getScaledInstance(TAM, TAM, Image.SCALE_SMOOTH);
 				media.addImage(piezas[i][j], 1);
 			}
 		}



From gauleng at berlios.de  Sat Aug 13 17:54:53 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sat, 13 Aug 2005 17:54:53 +0200
Subject: [Mihailchess-svn] r32 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508131554.j7DFsrrk031240@sheep.berlios.de>

Author: gauleng
Date: 2005-08-13 17:54:52 +0200 (Sat, 13 Aug 2005)
New Revision: 32

Modified:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/chess/Posicion.java
   trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
Log:
Probados ligeramente los temas, y corregidos ciertos errores. Anadido el test para el Tablero2D para que se pueda ver algo bonito ya ;)

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-13 00:42:21 UTC (rev 31)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-13 15:54:52 UTC (rev 32)
@@ -1,9 +1,9 @@
 package com.mihail.chess;
 
 import java.awt.Image;
+import java.io.BufferedInputStream;
 import java.io.File;
 import java.io.IOException;
-import java.io.InputStream;
 import java.net.URISyntaxException;
 import java.net.URL;
 import java.util.Enumeration;
@@ -51,7 +51,7 @@
 	/*
 	 * Imagenes del tema
 	 */
-	private Image[] pieceImages = new Image[12];
+	private Image[][] pieceImages = new Image[2][6];
 	private Image[] casillasImages = new Image[2];
 	private Image marco;
 	private Image background;
@@ -95,11 +95,11 @@
 	}
 	
 	public Image getImagePiece(Bando bando, Tipo tipo) {
-		return pieceImages[bandoToInt(bando) * tipoToInt(tipo)];
+		return pieceImages[bandoToInt(bando)][tipoToInt(tipo)];
 	}
 	
 	public Image getImageCasilla(Bando bando) {
-		return casillasImages[bandoToInt(bando)-1];
+		return casillasImages[bandoToInt(bando)];
 	}
 	
 	public Image getMarco() {
@@ -111,7 +111,7 @@
 	}
 	
 	private int bandoToInt(Bando bando) {
-		return bando == Bando.BLANCO? 1:2;
+		return bando == Bando.BLANCO? 0:1;
 	}
 	
 	private int tipoToInt(Tipo tipo) {
@@ -138,35 +138,36 @@
 			for(Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
 				ZipEntry entry = e.nextElement();
 				
-				InputStream is = zipFile.getInputStream(entry);
+				BufferedInputStream is = new BufferedInputStream(zipFile.getInputStream(entry));
 				String entryName = entry.getName();
-				System.out.println(entryName);
-				byte [] data = new byte[is.available()];
-				is.read(data);
+				int size = new Long(entry.getSize()).intValue();
+				byte [] data = new byte[size];
+				System.out.println(entryName + " Size: " + size);
+				System.out.println("Readed data: " + is.read(data, 0, size));
 				if(entryName.equals("reyB.png")) { // Cargar todas las imagenes en funcion de los nombres
-					pieceImages[5] = new ImageIcon(data).getImage();
+					pieceImages[0][5] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("reyN.png")) {
-					pieceImages[11] = new ImageIcon(data).getImage();
+					pieceImages[1][5] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("damaB.png")) {
-					pieceImages[4] = new ImageIcon(data).getImage();
+					pieceImages[0][4] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("damaN.png")) {
-					pieceImages[10] = new ImageIcon(data).getImage();
+					pieceImages[1][4] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("torreB.png")) {
-					pieceImages[3] = new ImageIcon(data).getImage();
+					pieceImages[0][3] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("torreN.png")) {
-					pieceImages[9] = new ImageIcon(data).getImage();
+					pieceImages[1][3]= new ImageIcon(data).getImage();
 				} else if (entryName.equals("caballoB.png")) {
-					pieceImages[1] = new ImageIcon(data).getImage();
+					pieceImages[0][1] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("caballoN.png")) {
-					pieceImages[7] = new ImageIcon(data).getImage();
+					pieceImages[1][1] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("alfilB.png")) {
-					pieceImages[2] = new ImageIcon(data).getImage();
+					pieceImages[0][2] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("alfilN.png")) {
-					pieceImages[8] = new ImageIcon(data).getImage();
+					pieceImages[1][2] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("peonB.png")) {
-					pieceImages[0] = new ImageIcon(data).getImage();
+					pieceImages[0][0] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("peonN.png")) {
-					pieceImages[6] = new ImageIcon(data).getImage();
+					pieceImages[1][0] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("casillaB.png")) {
 					casillasImages[0] = new ImageIcon(data).getImage();
 				} else if (entryName.equals("casillaN.png")) {

Modified: trunk/MihailChessLib/com/mihail/chess/Posicion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 00:42:21 UTC (rev 31)
+++ trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 15:54:52 UTC (rev 32)
@@ -269,6 +269,7 @@
 	 * @param pos
 	 *            Es un String que indica una posicion de juego, siguiendo el
 	 *            estandar FEN.
+	 * @see getFEN()
 	 */
 	public void setPosicion(String pos) {
 		char let = 'a';

Modified: trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 00:42:21 UTC (rev 31)
+++ trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 15:54:52 UTC (rev 32)
@@ -241,9 +241,8 @@
 						continue;
 					}
 
-					g.drawImage(theme.getImagePiece(temp.getBando(), temp
-							.getTipo()), i * TAM, j * TAM, null);
-
+					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
+					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
 				}
 			}
 
@@ -413,6 +412,21 @@
 	public void setTema(BoardTheme theme) {
 		this.theme = theme;
 	}
+	
+	public void setPieza(Pieza pieza, Casilla casilla) {
+		tablero.setPieza(pieza, casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void borrarPieza(Casilla casilla) {
+		tablero.borrarPieza(casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void setFEN(String pos) {
+		tablero.setPosicion(pos);
+		repaint();
+	}
 
 	/*
 	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
@@ -493,6 +507,42 @@
 		}
 		return 1;
 	}
+	
+	private int tipoToInt(Tipo tipo) {
+		switch(tipo) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		}
+		return -1;
+	}
+	
+	private Tipo intToTipo(int i) {
+		switch(i) {
+		case 0:
+			return Tipo.PEON;
+		case 1:
+			return Tipo.CABALLO;
+		case 2:
+			return Tipo.ALFIL;
+		case 3:
+			return Tipo.TORRE;
+		case 4:
+			return Tipo.DAMA;
+		case 5:
+			return Tipo.REY;
+		}
+		return null;
+	}
 
 	/*
 	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
@@ -503,8 +553,8 @@
 		MediaTracker media = new MediaTracker(this);
 		for (int i = 0; i < 2; i++) {
 			for (int j = 0; j < 6; j++) {
-				piezas[i][j] = theme.getImagePiece(Bando.BLANCO, Tipo.ALFIL)
-						.getScaledInstance(TAM, TAM, Image.SCALE_SMOOTH);
+				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
+						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
 				media.addImage(piezas[i][j], 1);
 			}
 		}



From gauleng at berlios.de  Sun Aug 14 14:37:19 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 14:37:19 +0200
Subject: [Mihailchess-svn] r34 - trunk/MihailChessLib/com/mihail/pgn
Message-ID: <200508141237.j7ECbJWY001663@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 14:37:18 +0200 (Sun, 14 Aug 2005)
New Revision: 34

Added:
   trunk/MihailChessLib/com/mihail/pgn/Game.java
   trunk/MihailChessLib/com/mihail/pgn/Parser.java
Removed:
   trunk/MihailChessLib/com/mihail/pgn/Analizador.java
   trunk/MihailChessLib/com/mihail/pgn/Partida.java
Log:
Un olvido de la primer

Deleted: trunk/MihailChessLib/com/mihail/pgn/Analizador.java
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/Analizador.java	2005-08-14 12:21:56 UTC (rev 33)
+++ trunk/MihailChessLib/com/mihail/pgn/Analizador.java	2005-08-14 12:37:18 UTC (rev 34)
@@ -1,64 +0,0 @@
-package com.mihail.pgn;
-
-import java.io.IOException;
-import java.util.ArrayList;
-
-/**
- * Clase que se encarga de cargar y guardar partidas en diferentes formatos. Por
- * ahora soportamos formato PGN, pero en un futuro se soportara formato MCN
- * (Markup Chess Notation) basado en XML, y quien sabe si alguno mas.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-public abstract class Analizador {
-
-	/**
-	 * Sirve para almacenar las partidas que se cargar?n.
-	 */
-	protected ArrayList<Partida> listaPartidas = new ArrayList<Partida>();
-
-	/**
-	 * Sirve para obtener el numero de partidas que tenemos.
-	 * 
-	 * @return El tama?o de la lista de partidas.
-	 */
-	public int getTamLista() {
-		return listaPartidas.size();
-	}
-
-	/**
-	 * Sirve para obtener una partida en particular.
-	 * 
-	 * @param pos
-	 *            La posicion dentro de la lista de partidas.
-	 * @return La partida en cuestion.
-	 */
-	public Partida getPartida(int pos) {
-		return listaPartidas.get(pos);
-	}
-
-	/**
-	 * Sirve para insertar una partida en la lista de partidas.
-	 * 
-	 * @param p
-	 *            La partida en cuestion.
-	 */
-	public void insertarPartida(Partida p) {
-		listaPartidas.add(p);
-	}
-
-	/**
-	 * Guarda a un archivo las partidas que tengamos en listaPartidas.
-	 * 
-	 * @param archivo
-	 *            El string que representa al archivo donde vamos a guardarlas.
-	 */
-	public abstract void guardarArchivo(String archivo) throws IOException;
-
-	/**
-	 * Analiza e interpreta un fichero con partidas con el objetivo de cargarlas
-	 * a memoria.
-	 */
-	public abstract void analizar() throws ParseException;
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/pgn/Game.java (from rev 27, trunk/MihailChessLib/com/mihail/pgn/Partida.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/Partida.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/pgn/Game.java	2005-08-14 12:37:18 UTC (rev 34)
@@ -0,0 +1,68 @@
+package com.mihail.pgn;
+
+import java.util.ArrayList;
+
+import com.mihail.chess.Movement;
+
+/**
+ * Esta clase define un objeto partida y sus caracteristicas: evento, sitio,
+ * fecha, jugadores, elo, lista de movimientos y lista de piezas comidas.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Game {
+	public String evento;
+
+	public String sitio;
+
+	public String fecha;
+
+	public String ronda;
+
+	public String jugadorB;
+
+	public String jugadorN;
+
+	public String resultado;
+
+	public int[] elos;
+
+	public String[] titulos;
+
+	public String[] emails;
+
+	public String[] tipos; // Humano o COM
+
+	public String apertura;
+
+	public String variacion;
+
+	public String subVariacion;
+
+	public String ECO;
+
+	public String controlDeTiempo;
+
+	public StringBuffer listaMovimientos = new StringBuffer();
+
+	public ArrayList listaPiezasComidas;
+
+	public String FEN;
+
+	/**
+	 * Este metodo devuelve la lista de movimientos de la partida.
+	 * 
+	 * @return La lista de movimientos de la partida
+	 */
+	public Movement[] getListaMovimientos() {
+		return null;
+	}
+
+	/**
+	 * 
+	 */
+	public void setListaMovimientos(Movement[] listaMovs) {
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/pgn/Parser.java (from rev 27, trunk/MihailChessLib/com/mihail/pgn/Analizador.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/Analizador.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/pgn/Parser.java	2005-08-14 12:37:18 UTC (rev 34)
@@ -0,0 +1,64 @@
+package com.mihail.pgn;
+
+import java.io.IOException;
+import java.util.ArrayList;
+
+/**
+ * Clase que se encarga de cargar y guardar partidas en diferentes formatos. Por
+ * ahora soportamos formato PGN, pero en un futuro se soportara formato MCN
+ * (Markup Chess Notation) basado en XML, y quien sabe si alguno mas.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+public abstract class Parser {
+
+	/**
+	 * Sirve para almacenar las partidas que se cargar?n.
+	 */
+	protected ArrayList<Game> listaPartidas = new ArrayList<Game>();
+
+	/**
+	 * Sirve para obtener el numero de partidas que tenemos.
+	 * 
+	 * @return El tama?o de la lista de partidas.
+	 */
+	public int getTamLista() {
+		return listaPartidas.size();
+	}
+
+	/**
+	 * Sirve para obtener una partida en particular.
+	 * 
+	 * @param pos
+	 *            La posicion dentro de la lista de partidas.
+	 * @return La partida en cuestion.
+	 */
+	public Game getPartida(int pos) {
+		return listaPartidas.get(pos);
+	}
+
+	/**
+	 * Sirve para insertar una partida en la lista de partidas.
+	 * 
+	 * @param p
+	 *            La partida en cuestion.
+	 */
+	public void insertarPartida(Game p) {
+		listaPartidas.add(p);
+	}
+
+	/**
+	 * Guarda a un archivo las partidas que tengamos en listaPartidas.
+	 * 
+	 * @param archivo
+	 *            El string que representa al archivo donde vamos a guardarlas.
+	 */
+	public abstract void guardarArchivo(String archivo) throws IOException;
+
+	/**
+	 * Analiza e interpreta un fichero con partidas con el objetivo de cargarlas
+	 * a memoria.
+	 */
+	public abstract void analizar() throws ParseException;
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/pgn/Partida.java
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/Partida.java	2005-08-14 12:21:56 UTC (rev 33)
+++ trunk/MihailChessLib/com/mihail/pgn/Partida.java	2005-08-14 12:37:18 UTC (rev 34)
@@ -1,68 +0,0 @@
-package com.mihail.pgn;
-
-import java.util.ArrayList;
-
-import com.mihail.chess.Movimiento;
-
-/**
- * Esta clase define un objeto partida y sus caracteristicas: evento, sitio,
- * fecha, jugadores, elo, lista de movimientos y lista de piezas comidas.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Partida {
-	public String evento;
-
-	public String sitio;
-
-	public String fecha;
-
-	public String ronda;
-
-	public String jugadorB;
-
-	public String jugadorN;
-
-	public String resultado;
-
-	public int[] elos;
-
-	public String[] titulos;
-
-	public String[] emails;
-
-	public String[] tipos; // Humano o COM
-
-	public String apertura;
-
-	public String variacion;
-
-	public String subVariacion;
-
-	public String ECO;
-
-	public String controlDeTiempo;
-
-	public StringBuffer listaMovimientos = new StringBuffer();
-
-	public ArrayList listaPiezasComidas;
-
-	public String FEN;
-
-	/**
-	 * Este metodo devuelve la lista de movimientos de la partida.
-	 * 
-	 * @return La lista de movimientos de la partida
-	 */
-	public Movimiento[] getListaMovimientos() {
-		return null;
-	}
-
-	/**
-	 * 
-	 */
-	public void setListaMovimientos(Movimiento[] listaMovs) {
-	}
-}



From gauleng at berlios.de  Sun Aug 14 15:38:53 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 15:38:53 +0200
Subject: [Mihailchess-svn] r37 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508141338.j7EDcrA3003839@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 15:38:53 +0200 (Sun, 14 Aug 2005)
New Revision: 37

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Board2D.java
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java
Log:
More translations

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:30:00 UTC (rev 36)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:38:53 UTC (rev 37)
@@ -63,7 +63,7 @@
 	public Board(Position posInicial) {
 		movimientos = new VariationsTree();
 		posicion = posInicial;
-		hash.insertar(posicion.getPositionKey());
+		hash.insert(posicion.getPositionKey());
 	}
 
 	/**
@@ -561,7 +561,7 @@
 					// Si se come ponemos el contador a 0
 					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
 						posicion.setHalfmoveClock(0);
-						hash.borrarTabla();
+						hash.clearDictionary();
 						mov.setCasillaComer(new Square(destinoLetra,
 								destinoNum));
 						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
@@ -599,7 +599,7 @@
 							mov.setCoronacion(coronar);
 						}
 						posicion.setHalfmoveClock(0);
-						hash.borrarTabla();
+						hash.clearDictionary();
 					}
 					// Se hacen los calculos especiales si se trata de un rey
 					if (piezaQueMueve.getType() == Type.KING) {
@@ -641,7 +641,7 @@
 					}
 					mov.setFinPartida(esFinPartida());
 
-					hash.insertar(posicion.getPositionKey());
+					hash.insert(posicion.getPositionKey());
 					movimientos.appendMovimiento(mov);
 					indice++;
 					return mov;
@@ -788,7 +788,7 @@
 			devolver = Result.FIFTY_MOV_DRAW;
 		}
 		// Tablas por repeticion de posiciones
-		if (hash.getRepeticiones(posicion.getPositionKey()) == 3) {
+		if (hash.getRepetitions(posicion.getPositionKey()) == 3) {
 			fin = true;
 			devolver = Result.REPETITION_DRAW;
 		}

Modified: trunk/MihailChessLib/com/mihail/chess/Board2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 13:30:00 UTC (rev 36)
+++ trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 13:38:53 UTC (rev 37)
@@ -153,11 +153,11 @@
 		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
 		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
 
-		if(theme.getBackground()==null) {
+		if(theme.getBackgroundImage()==null) {
 			g.setColor(Color.LIGHT_GRAY);
 			g.fillRect(0, 0, getWidth(), getHeight());
 		} else {
-			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
+			g.drawImage(theme.getBackgroundImage(), 0, 0, this.getWidth(), this.getHeight(), null);
 		}
 
 		if (getWidth() < getHeight()) {
@@ -182,7 +182,7 @@
 				// casillas blancas o negras
 				// if (activado) {
 				int v = (i + j) % 2;
-				Image textura = theme.getImageCasilla(v == 0 ? Side.WHITE
+				Image textura = theme.getSquareImage(v == 0 ? Side.WHITE
 						: Side.BLACK);
 				if (textura != null)
 
@@ -461,7 +461,7 @@
 	}
 
 	private void dibujarBorde(Graphics g) {
-		Image borde = theme.getMarco();
+		Image borde = theme.getBorderImage();
 		if (borde != null) {
 			g.drawImage(borde, 0, 0, null);
 		} else { // Dibujamos a mano
@@ -553,7 +553,7 @@
 		MediaTracker media = new MediaTracker(this);
 		for (int i = 0; i < 2; i++) {
 			for (int j = 0; j < 6; j++) {
-				piezas[i][j] = theme.getImagePiece(i==0?Side.WHITE:Side.BLACK, intToTipo(j))
+				piezas[i][j] = theme.getPieceImage(i==0?Side.WHITE:Side.BLACK, intToTipo(j))
 						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
 				media.addImage(piezas[i][j], 1);
 			}

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 13:30:00 UTC (rev 36)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 13:38:53 UTC (rev 37)
@@ -94,19 +94,19 @@
 		}
 	}
 	
-	public Image getImagePiece(Side bando, Type tipo) {
+	public Image getPieceImage(Side bando, Type tipo) {
 		return pieceImages[bandoToInt(bando)][tipoToInt(tipo)];
 	}
 	
-	public Image getImageCasilla(Side bando) {
+	public Image getSquareImage(Side bando) {
 		return casillasImages[bandoToInt(bando)];
 	}
 	
-	public Image getMarco() {
+	public Image getBorderImage() {
 		return marco;
 	}
 	
-	public Image getBackground() {
+	public Image getBackgroundImage() {
 		return background;
 	}
 	

Modified: trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java	2005-08-14 13:30:00 UTC (rev 36)
+++ trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java	2005-08-14 13:38:53 UTC (rev 37)
@@ -37,7 +37,7 @@
 	 * @param clave
 	 *            Clave que queremos insertar dentro de la tabla
 	 */
-	public void insertar(int clave) {
+	public void insert(int clave) {
 		int pos = clave % tam;
 		int i = 0;
 
@@ -55,7 +55,7 @@
 	/**
 	 * Borra todos los elementos de la tabla.
 	 */
-	public void borrarTabla() {
+	public void clearDictionary() {
 		for (int i = 0; i < tabla.length; i++)
 			tabla[i].clear();
 	}
@@ -67,7 +67,7 @@
 	 *            La clave asociada con una posicion.
 	 * @return El numero de repeticiones de la clave recibida.
 	 */
-	public int getRepeticiones(int clave) {
+	public int getRepetitions(int clave) {
 		int pos = clave % tam;
 		int i = 0;
 



From gauleng at berlios.de  Sun Aug 14 15:42:39 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 15:42:39 +0200
Subject: [Mihailchess-svn] r38 - in trunk/MihailChessLib/com/mihail: clock openings test
Message-ID: <200508141342.j7EDgdZu004077@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 15:42:39 +0200 (Sun, 14 Aug 2005)
New Revision: 38

Modified:
   trunk/MihailChessLib/com/mihail/clock/Clock.java
   trunk/MihailChessLib/com/mihail/openings/Openings.java
   trunk/MihailChessLib/com/mihail/test/PositionTest.java
   trunk/MihailChessLib/com/mihail/test/RelojTest.java
Log:
More translations

Modified: trunk/MihailChessLib/com/mihail/clock/Clock.java
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/Clock.java	2005-08-14 13:38:53 UTC (rev 37)
+++ trunk/MihailChessLib/com/mihail/clock/Clock.java	2005-08-14 13:42:39 UTC (rev 38)
@@ -74,7 +74,7 @@
 			throw new ClockException("Recarga fuera de rango");
 	}
 
-	public void comenzar() {
+	public void start() {
 		if (tiempo == null) {
 			tiempo = new Timer();
 		}
@@ -120,11 +120,11 @@
 		}
 	}
 
-	public void setParado(boolean b) {
+	public void setStopped(boolean b) {
 		parado = b;
 	}
 
-	public void setTiempo(int h, int m, int s, int d) throws ClockException {
+	public void setTime(int h, int m, int s, int d) throws ClockException {
 		horas = h;
 		if (h < 0)
 			throw new ClockException("Horas fuera de rango");
@@ -139,7 +139,7 @@
 		decimas = d;
 	}
 
-	public void recargar() {
+	public void recharge() {
 		int simul, resto;
 		simul = segundos + recarga;
 		horas += simul / 3600;
@@ -148,27 +148,27 @@
 		segundos = resto % 60;
 	}
 
-	public boolean isFinTiempo() {
+	public boolean isTimeFinished() {
 		return horas < 0;
 	}
 
-	public void setRecarga(int segs) {
+	public void setRecharge(int segs) {
 		recarga = segs;
 	}
 
-	public int getHoras() {
+	public int getHours() {
 		return horas;
 	}
 
-	public int getMinutos() {
+	public int getMinutes() {
 		return minutos;
 	}
 
-	public int getSegundos() {
+	public int getSeconds() {
 		return segundos;
 	}
 
-	public int getDecimas() {
+	public int getTenths() {
 		return decimas;
 	}
 }

Modified: trunk/MihailChessLib/com/mihail/openings/Openings.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 13:38:53 UTC (rev 37)
+++ trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 13:42:39 UTC (rev 38)
@@ -32,7 +32,7 @@
 	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
 	 */
 	public String getApertura(Position pos) {
-		int clave = pos.getClavePosicion();
+		int clave = pos.getPositionKey();
 		if (aperturas.containsKey(clave))
 			return aperturas.get(clave);
 		else

Modified: trunk/MihailChessLib/com/mihail/test/PositionTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-14 13:38:53 UTC (rev 37)
+++ trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-14 13:42:39 UTC (rev 38)
@@ -13,8 +13,8 @@
 import com.mihail.chess.Position;
 import junit.framework.TestCase;
 
-import static com.mihail.chess.Board.Bando;
-import static com.mihail.chess.Piece.Tipo;
+import static com.mihail.chess.Board.Side;
+import static com.mihail.chess.Piece.Type;
 
 public class PositionTest extends TestCase {
 
@@ -31,7 +31,7 @@
 	 */
 	public void testGetFEN() {
 		Position p = new Position();
-		p.setPosicion(Position.CAD_INICIAL);
+		p.setFEN(Position.INITIAL_POSITION_FEN);
 		assertEquals(
 				"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", p
 						.getFEN());
@@ -46,10 +46,10 @@
 	 */
 	public void testSetTurno() {
 		Position p = new Position();
-		Bando turno = p.getTurno();
-		p.setTurno();
-		p.setTurno();
-		assertEquals(turno, p.getTurno());
+		Side turno = p.getTurn();
+		p.setTurn();
+		p.setTurn();
+		assertEquals(turno, p.getTurn());
 	}
 
 	/*
@@ -57,10 +57,10 @@
 	 */
 	public void testSetTurnoInt() {
 		Position p = new Position();
-		p.setTurno(Bando.BLANCO);
-		assertEquals(Bando.BLANCO, p.getTurno());
-		p.setTurno(Bando.NEGRO);
-		assertEquals(Bando.NEGRO, p.getTurno());
+		p.setTurn(Side.WHITE);
+		assertEquals(Side.WHITE, p.getTurn());
+		p.setTurn(Side.BLACK);
+		assertEquals(Side.BLACK, p.getTurn());
 	}
 
 	/*
@@ -68,19 +68,19 @@
 	 */
 	public void testSetEnroqueCorto() {
 		Position p = new Position();
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
-		p.setEnroqueCorto(Bando.BLANCO, true);
-		assertFalse(p.getEnroqueCorto(Bando.BLANCO));
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'h', '1');
-		p.setEnroqueCorto(Bando.BLANCO, true);
-		assertTrue(p.getEnroqueCorto(Bando.BLANCO));
+		p.setPiece(new Piece(Side.WHITE, Type.KING), 'e', '1');
+		p.setKingsideCastling(Side.WHITE, true);
+		assertFalse(p.getKingsideCastling(Side.WHITE));
+		p.setPiece(new Piece(Side.WHITE, Type.ROOK), 'h', '1');
+		p.setKingsideCastling(Side.WHITE, true);
+		assertTrue(p.getKingsideCastling(Side.WHITE));
 
-		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
-		p.setEnroqueCorto(Bando.NEGRO, true);
-		assertFalse(p.getEnroqueCorto(Bando.NEGRO));
-		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'h', '8');
-		p.setEnroqueCorto(Bando.NEGRO, true);
-		assertTrue(p.getEnroqueCorto(Bando.NEGRO));
+		p.setPiece(new Piece(Side.BLACK, Type.KING), 'e', '8');
+		p.setKingsideCastling(Side.BLACK, true);
+		assertFalse(p.getKingsideCastling(Side.BLACK));
+		p.setPiece(new Piece(Side.BLACK, Type.ROOK), 'h', '8');
+		p.setKingsideCastling(Side.BLACK, true);
+		assertTrue(p.getKingsideCastling(Side.BLACK));
 	}
 
 	/*
@@ -88,19 +88,19 @@
 	 */
 	public void testSetEnroqueLargo() {
 		Position p = new Position();
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
-		p.setEnroqueLargo(Bando.BLANCO, true);
-		assertEquals(false, p.getEnroqueLargo(Bando.BLANCO));
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'a', '1');
-		p.setEnroqueLargo(Bando.BLANCO, true);
-		assertTrue(p.getEnroqueLargo(Bando.BLANCO));
+		p.setPiece(new Piece(Side.WHITE, Type.KING), 'e', '1');
+		p.setQueensideCastling(Side.WHITE, true);
+		assertEquals(false, p.getQueensideCastling(Side.WHITE));
+		p.setPiece(new Piece(Side.WHITE, Type.ROOK), 'a', '1');
+		p.setQueensideCastling(Side.WHITE, true);
+		assertTrue(p.getQueensideCastling(Side.WHITE));
 
-		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
-		p.setEnroqueLargo(Bando.NEGRO, true);
-		assertFalse(p.getEnroqueLargo(Bando.NEGRO));
-		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'a', '8');
-		p.setEnroqueLargo(Bando.NEGRO, true);
-		assertTrue(p.getEnroqueLargo(Bando.NEGRO));
+		p.setPiece(new Piece(Side.BLACK, Type.KING), 'e', '8');
+		p.setQueensideCastling(Side.BLACK, true);
+		assertFalse(p.getQueensideCastling(Side.BLACK));
+		p.setPiece(new Piece(Side.BLACK, Type.ROOK), 'a', '8');
+		p.setQueensideCastling(Side.BLACK, true);
+		assertTrue(p.getQueensideCastling(Side.BLACK));
 	}
 
 	/*
@@ -117,29 +117,29 @@
 		Position p = new Position("8/8/8/7p/8/8/8/8 w - h 0 1");
 		// Al borrar la pieza, alPaso deberia resetearse, ya que no hay peon en
 		// esa columna
-		p.borrarPieza('h', '5');
-		assertEquals(p.getAlPaso(), 0);
+		p.removePiece('h', '5');
+		assertEquals(p.getEnPassant(), 0);
 		assertNull(p.getPieza('h', '5'));
 
-		p.setPosicion("8/8/8/8/8/8/8/R3K2R w KQ - 0 1");
-		p.borrarPieza('e', '1');
-		assertFalse(p.getEnroqueLargo(Bando.BLANCO));
-		assertFalse(p.getEnroqueCorto(Bando.BLANCO));
+		p.setFEN("8/8/8/8/8/8/8/R3K2R w KQ - 0 1");
+		p.removePiece('e', '1');
+		assertFalse(p.getQueensideCastling(Side.WHITE));
+		assertFalse(p.getKingsideCastling(Side.WHITE));
 
-		p.setPosicion("8/8/8/8/8/8/8/R3K2R w KQ - 0 1");
-		p.borrarPieza('h', '1');
-		assertTrue(p.getEnroqueLargo(Bando.BLANCO));
-		assertFalse(p.getEnroqueCorto(Bando.BLANCO));
+		p.setFEN("8/8/8/8/8/8/8/R3K2R w KQ - 0 1");
+		p.removePiece('h', '1');
+		assertTrue(p.getQueensideCastling(Side.WHITE));
+		assertFalse(p.getKingsideCastling(Side.WHITE));
 
-		p.setPosicion("r3k2r/8/8/8/8/8/8/8 w kq - 0 1");
-		p.borrarPieza('e', '8');
-		assertFalse(p.getEnroqueLargo(Bando.NEGRO));
-		assertFalse(p.getEnroqueCorto(Bando.NEGRO));
+		p.setFEN("r3k2r/8/8/8/8/8/8/8 w kq - 0 1");
+		p.removePiece('e', '8');
+		assertFalse(p.getQueensideCastling(Side.BLACK));
+		assertFalse(p.getKingsideCastling(Side.BLACK));
 
-		p.setPosicion("r3k2r/8/8/8/8/8/8/8 w kq - 0 1");
-		p.borrarPieza('a', '8');
-		assertFalse(p.getEnroqueLargo(Bando.NEGRO));
-		assertTrue(p.getEnroqueCorto(Bando.NEGRO));
+		p.setFEN("r3k2r/8/8/8/8/8/8/8 w kq - 0 1");
+		p.removePiece('a', '8');
+		assertFalse(p.getQueensideCastling(Side.BLACK));
+		assertTrue(p.getKingsideCastling(Side.BLACK));
 	}
 
 	/*
@@ -154,11 +154,11 @@
 	 */
 	public void testGetClavePosicion() {
 		Position p = new Position();
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
-		int clave = p.getClavePosicion();
-		p.borrarPieza('d', '4');
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
-		assertEquals(clave, p.getClavePosicion());
+		p.setPiece(new Piece(Side.WHITE, Type.KNIGHT), 'd', '4');
+		int clave = p.getPositionKey();
+		p.removePiece('d', '4');
+		p.setPiece(new Piece(Side.WHITE, Type.KNIGHT), 'd', '4');
+		assertEquals(clave, p.getPositionKey());
 	}
 
 	/*
@@ -167,19 +167,19 @@
 	public void testSetAlPaso() {
 		Position p = new Position();
 		// Comprobamos que no se pone siempre alPaso
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'a', '1');
-		p.setAlPaso('a');
-		assertEquals(p.getAlPaso(), 0);
+		p.setPiece(new Piece(Side.WHITE, Type.PAWN), 'a', '1');
+		p.setEnPassant('a');
+		assertEquals(p.getEnPassant(), 0);
 		// Comprobamos que al poner un peon negro en una casilla de alPaso, la
 		// funcion deja
-		p.setPieza(new Piece(Bando.NEGRO, Tipo.PEON), 'h', '5');
-		p.setAlPaso('h');
-		assertEquals(p.getAlPaso(), 'h');
+		p.setPiece(new Piece(Side.BLACK, Type.PAWN), 'h', '5');
+		p.setEnPassant('h');
+		assertEquals(p.getEnPassant(), 'h');
 		// Probamos lo mismo pero con un peon blanco
-		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'h', '4');
-		p.setTurno(Bando.NEGRO);
-		p.setAlPaso('h');
-		assertEquals(p.getAlPaso(), 'h');
+		p.setPiece(new Piece(Side.WHITE, Type.PAWN), 'h', '4');
+		p.setTurn(Side.BLACK);
+		p.setEnPassant('h');
+		assertEquals(p.getEnPassant(), 'h');
 	}
 
 	/*

Modified: trunk/MihailChessLib/com/mihail/test/RelojTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-14 13:38:53 UTC (rev 37)
+++ trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-14 13:42:39 UTC (rev 38)
@@ -11,11 +11,11 @@
 	public void update(Observable arg0, Object arg1) {
 		if (arg0 instanceof Clock) {
 			Clock r = (Clock) arg0;
-			if (r.getDecimas() == 0) {
-				System.out.println(r.getHoras() + ":" + r.getMinutos() + ":"
-						+ r.getSegundos() + "." + r.getDecimas());
+			if (r.getTenths() == 0) {
+				System.out.println(r.getHours() + ":" + r.getMinutes() + ":"
+						+ r.getSeconds() + "." + r.getTenths());
 			}
-			if (r.isFinTiempo())
+			if (r.isTimeFinished())
 				System.out.println("FIN TIEMPO");
 		}
 	}
@@ -30,7 +30,7 @@
 		relojTest = new RelojTest();
 
 		reloj.addObserver(relojTest);
-		reloj.comenzar();
-		reloj.setParado(false);
+		reloj.start();
+		reloj.setStopped(false);
 	}
 }



From gauleng at berlios.de  Sun Aug 14 15:44:19 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 15:44:19 +0200
Subject: [Mihailchess-svn] r39 - trunk/MihailChessLib/com/mihail/openings
Message-ID: <200508141344.j7EDiJKl004174@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 15:44:19 +0200 (Sun, 14 Aug 2005)
New Revision: 39

Modified:
   trunk/MihailChessLib/com/mihail/openings/Openings.java
Log:
More translations

Modified: trunk/MihailChessLib/com/mihail/openings/Openings.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 13:42:39 UTC (rev 38)
+++ trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 13:44:19 UTC (rev 39)
@@ -31,7 +31,7 @@
 	 * @param pos
 	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
 	 */
-	public String getApertura(Position pos) {
+	public String getOpening(Position pos) {
 		int clave = pos.getPositionKey();
 		if (aperturas.containsKey(clave))
 			return aperturas.get(clave);



From gauleng at berlios.de  Sun Aug 14 14:21:58 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 14:21:58 +0200
Subject: [Mihailchess-svn] r33 - in trunk/MihailChessLib/com/mihail: chess clock openings pgn test
Message-ID: <200508141221.j7ECLwR4001095@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 14:21:56 +0200 (Sun, 14 Aug 2005)
New Revision: 33

Added:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Board2D.java
   trunk/MihailChessLib/com/mihail/chess/DirectionVector.java
   trunk/MihailChessLib/com/mihail/chess/Movement.java
   trunk/MihailChessLib/com/mihail/chess/Piece.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
   trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java
   trunk/MihailChessLib/com/mihail/chess/Square.java
   trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
   trunk/MihailChessLib/com/mihail/clock/Clock.java
   trunk/MihailChessLib/com/mihail/clock/ClockException.java
   trunk/MihailChessLib/com/mihail/openings/Openings.java
   trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java
Removed:
   trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java
   trunk/MihailChessLib/com/mihail/chess/Casilla.java
   trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java
   trunk/MihailChessLib/com/mihail/chess/Logica.java
   trunk/MihailChessLib/com/mihail/chess/Movimiento.java
   trunk/MihailChessLib/com/mihail/chess/Pieza.java
   trunk/MihailChessLib/com/mihail/chess/Posicion.java
   trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
   trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java
   trunk/MihailChessLib/com/mihail/clock/Reloj.java
   trunk/MihailChessLib/com/mihail/clock/RelojException.java
   trunk/MihailChessLib/com/mihail/openings/Aperturas.java
   trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java
Modified:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/pgn/PGNParser.java
   trunk/MihailChessLib/com/mihail/test/PositionTest.java
   trunk/MihailChessLib/com/mihail/test/RelojTest.java
Log:
Primera translation

Deleted: trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,219 +0,0 @@
-package com.mihail.chess;
-
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.mihail.chess.Logica.Bando;
-
-/**
- * @author Wotan
- * 
- * TODO To change the template for this generated type comment go to Window -
- * Preferences - Java - Code Style - Code Templates
- */
-public class ArbolVariantes {
-	private class NodoArbol {
-		public Movimiento movimiento;
-
-		public ArrayList<ArbolVariantes> variantes;
-
-		public NodoArbol(Movimiento mov) {
-			movimiento = mov;
-		}
-	}
-
-	/**
-	 * Desplazamiento con respecto al principio de la partida. En el caso de la
-	 * variante principal, el desplazamiento es 0, pero en otro caso el
-	 * desplazamiento es igual el numero de movimiento en el que se encuentra la
-	 * variante.
-	 */
-
-	private int desplazamiento = 0;
-
-	private AbstractList<NodoArbol> arbol = new ArrayList<NodoArbol>();
-
-	/**
-	 * 
-	 */
-	public ArbolVariantes() {
-	}
-
-	private ArbolVariantes(int desp) {
-		desplazamiento = desp;
-	}
-
-	/**
-	 * A?ade el movimiento al final de la variante principal.
-	 * 
-	 * @param mov
-	 *            Movimiento que se a?ade.
-	 */
-	public void appendMovimiento(Movimiento mov) {
-		arbol.add(new NodoArbol(mov));
-	}
-
-	/**
-	 * Obtiene un movimiento a partir del numero de movimiento y el turno de
-	 * juego.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento
-	 * @param numero
-	 *            Numero del movimiento
-	 * @return Devuelve el movimiento correspondiente a color y numero
-	 */
-	public Movimiento getMovimiento(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-		if (n != null)
-			return n.movimiento;
-		return null;
-	}
-	
-	public Movimiento getMovimiento(int halfPly) {
-		return arbol.get(halfPly).movimiento;
-	}
-
-	/**
-	 * Comprueba si dado un movimiento, existen alternativas.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 * @return Un booleano que indica si para ese movimiento existen
-	 *         alternativas.
-	 */
-	public boolean existeVariante(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n != null && n.variantes != null)
-			return (!n.variantes.isEmpty());
-		return false;
-	}
-
-	/**
-	 * Devuelve el numero de variantes a un movimiento determinado.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 * @return El numero de alternativas a un movimiento.
-	 */
-	public int getNumVariantes(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n != null) {
-			if (n.variantes != null)
-				return n.variantes.size();
-		}
-		return 0;
-	}
-
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO)
-			return 0;
-		return 1;
-	}
-
-	// Funcion de utilidad.
-	private NodoArbol getNodo(Bando color, int numero) {
-		int indice = (numero - 1) * 2 + bandoToInt(color);
-		if (indice < arbol.size())
-			return arbol.get(indice);
-		return null;
-	}
-
-	/**
-	 * A?ade un movimiento como variante a otro movimiento.
-	 * 
-	 * @param mov
-	 *            Movimiento que se a?ade como alternativa
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 */
-	public void addVariante(Movimiento mov, Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n.variantes == null)
-			n.variantes = new ArrayList<ArbolVariantes>();
-
-		ArbolVariantes a = new ArbolVariantes(numero);
-		if (color == Bando.NEGRO) // Cada arbol de variantes debe empezar con un movimiento de blancas
-			a.appendMovimiento(new Movimiento());
-		a.appendMovimiento(mov);
-
-		n.variantes.add(a);
-	}
-
-	/**
-	 * Devuelve la variante numero num a un movimiento dado.
-	 * 
-	 * @param color
-	 * @param numero
-	 * @param num
-	 *            Numero de variante que se quiere obtener.
-	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
-	 */
-	public ArbolVariantes getVariante(Bando color, int numero, int num) {
-		NodoArbol n = getNodo(color, numero);
-		if (n != null)
-			return n.variantes.get(num);
-		return null;
-	}
-
-	/**
-	 * @return Devuelve el numero total de movimientos desde el comienzo de la
-	 *         partida. Solo cuenta los turnos jugados, no cuenta un movimiento
-	 *         por negras y otro por blancas.
-	 */
-	public int getNumMovimientos() {
-		return desplazamiento + ((arbol.size() + 1) / 2);
-	}
-
-	/**
-	 * Cuenta los medios movimientos, es decir, contando uno por cada movimiento
-	 * de negras y blancas.
-	 * 
-	 * @return Los medios movimientos desde el comienzo de la partida.
-	 */
-
-	public int getNumHalfPly() {
-		return arbol.size();
-	}
-
-	/**
-	 * Devuelve el ?ltimo movimiento de la variante actual.
-	 * 
-	 * @return
-	 */
-
-	public Movimiento getLastMovimiento() {
-		return arbol.get(arbol.size() - 1).movimiento;
-	}
-	
-	/**
-	 * Hace que una variante pase a ser la variante principal.
-	 * 
-	 * @param color
-	 * @param numero
-	 * @param num
-	 */
-	
-	public void promoteVariant(Bando color, int numero, int num) {
-		ArbolVariantes a = getVariante(color, numero, num);
-		int indice = (numero - 1) * 2 + bandoToInt(color);
-		NodoArbol n = getNodo(color, numero);
-		
-		ArbolVariantes newTree = new ArbolVariantes();
-		newTree.arbol  = (AbstractList<ArbolVariantes.NodoArbol>)arbol.subList(indice, arbol.size());
-		n.variantes.add(newTree);
-		
-		arbol.addAll(a.arbol);
-		n.variantes.remove(num);
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Board.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Logica.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,1033 @@
+package com.mihail.chess;
+
+import java.util.ArrayList;
+
+import com.mihail.chess.Piece.Tipo;
+
+public class Board {
+
+	public static enum Bando {
+		BLANCO, NEGRO;
+
+		public boolean equals(Bando b) {
+			return this == b;
+		}
+	}
+
+	public static enum Resultado {
+		JAQUE_MATE_BLANCO, JAQUE_MATE_NEGRO, TABLAS_REPETICION, TABLAS_50_MOV, TABLAS_INSUF_MATERIAL, TABLAS_AHOGADO
+	}
+
+	// public static final int JAQUE_MATE_BLANCO = 6;
+	// public static final int JAQUE_MATE_NEGRO = 1;
+	// public static final int TABLAS_REPETICION = 2;
+	// public static final int TABLAS_50_MOV = 3;
+	// public static final int TABLAS_INSUF_MATERIAL = 4;
+	// public static final int TABLAS_AHOGADO = 5;
+
+	/**
+	 * Este atributo sirve para guardar la lista de movimientos de una partida.
+	 */
+	private VariationsTree movimientos;
+
+	/**
+	 * Este atributo sirve para saber en que posicion de la lista de movimientos
+	 * nos encontramos, a la hora de avanzar y retroceder por una partida.
+	 * Siempre va una posici?n por delante de la aut?ntica posici?n
+	 */
+	private int indice;
+
+	/**
+	 * Este atributo se utiliza para las coronaciones.
+	 */
+	private Tipo coronar = Tipo.DAMA;
+
+	/**
+	 * Tabla hash usada para comprobar posiciones repetidas.
+	 */
+	private PositionsDictionary hash = new PositionsDictionary(51);
+
+	/**
+	 * Posicion actual en juego
+	 */
+	private Position posicion;
+
+	/**
+	 * Crea una nueva instancia de la clase y crea las piezas, colocandolas en
+	 * la posicion que indica el String posInicial.
+	 * 
+	 * @param posInicial
+	 *            Es un String que indica una posicion de juego, siguiendo el
+	 *            estandar FEN.
+	 */
+	public Board(Position posInicial) {
+		movimientos = new VariationsTree();
+		posicion = posInicial;
+		hash.insertar(posicion.getClavePosicion());
+	}
+
+	/**
+	 * Reinicia la posicion del tablero a la posicion inicial.
+	 */
+	public void reiniciarTablero() {
+		posicion.setPosicion(Position.CAD_INICIAL);
+	}
+
+	/**
+	 * Indica a que pieza queremos coronar por defecto.
+	 * 
+	 * @param c
+	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
+	 */
+
+	public void setCoronacion(Tipo c) {
+		coronar = c;
+	}
+
+	/**
+	 * Permite saber el numero total de movimientos de la partida.
+	 * 
+	 * @return Un entero, el numero en cuestion.
+	 */
+
+	public int getNumTotalMovimientos() {
+		return movimientos.getNumMovimientos();
+	}
+
+	public Position getPosicion() {
+		return this.posicion;
+	}
+
+	/**
+	 * Obtiene el resultado de la partida.
+	 * 
+	 * @return Devuelve un caracter: <BR>
+	 *         'B' -> Victoria Blanca <BR>
+	 *         'N' -> Victoria Negra <BR>
+	 *         'T' -> Tablas <BR>
+	 *         '\0' -> Partida Inacabada o Resultado Desconocido
+	 */
+	public Resultado getResultado() {
+		return movimientos.getLastMovimiento().getFinPartida();
+	}
+
+	/**
+	 * Calcula los movimientos validos para todas las piezas del tablero.
+	 */
+	public void calcularMovimientos() {
+		for (char i = 'a'; i <= 'h'; i++) {
+			for (char j = '1'; j <= '8'; j++) {
+				Piece p = posicion.getPieza(i, j);
+				if (p != null) {
+					if (!Piece.esBandoContrario(posicion.getTurno(), p)) {
+						calcularMovimientos(p);
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * Calcula los movimientos validos para una pieza en concreto, que se le
+	 * pasa como parametro.
+	 * 
+	 * @param pieza
+	 *            Pieza de la que queremos calcular sus movimientos legales
+	 */
+	private void calcularMovimientos(Piece pieza) {
+		pieza.getCasillasValidas().clear();
+		switch (pieza.getTipo()) {
+		case PEON:
+			// Peon
+			// Peon blanco
+			if (pieza.getBando() == Bando.BLANCO) {
+				// Movimiento hacia delante
+				// Hacemos dos iteraciones, una para el caso de que avance
+				// una casilla, otra para el caso de que avance dos
+				if (posicion.esVacia(pieza.getLetra(),
+						(char) (pieza.getNum() + 1))) {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+							.getLetra(), (char) (pieza.getNum() + 1))) {
+						pieza.anadirMov(pieza.getLetra(), (char) (pieza
+								.getNum() + 1));
+						if (pieza.getNum() == '2'
+								&& posicion.esVacia(pieza.getLetra(),
+										(char) (pieza.getNum() + 2))) {
+							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+									.getLetra(), (char) (pieza.getNum() + 2))) {
+								pieza.anadirMov(pieza.getLetra(), (char) (pieza
+										.getNum() + 2));
+							}
+						}
+					}
+				}
+				if (posicion.getAlPaso() != '\0'
+						&& pieza.getNum() == '5'
+						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
+					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+							.getNum() + 1));
+				}
+				// Movimientos para comer
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
+							(char) (pieza.getNum() + 1));
+					if (p != null && p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() + 1), (char) (pieza
+										.getNum() + 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() + 1),
+									(char) (pieza.getNum() + 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
+							(char) (pieza.getNum() - 1));
+					if (p != null && p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() - 1), (char) (pieza
+										.getNum() + 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() - 1),
+									(char) (pieza.getNum() + 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+			// Peon negro
+			else {
+				if (posicion.esVacia(pieza.getLetra(),
+						(char) (pieza.getNum() - 1))) {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+							.getLetra(), (char) (pieza.getNum() - 1))) {
+						pieza.anadirMov(pieza.getLetra(), (char) (pieza
+								.getNum() - 1));
+						if (pieza.getNum() == '7'
+								&& posicion.esVacia(pieza.getLetra(),
+										(char) (pieza.getNum() - 2))) {
+							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+									.getLetra(), (char) (pieza.getNum() - 2))) {
+								pieza.anadirMov(pieza.getLetra(), (char) (pieza
+										.getNum() - 2));
+							}
+						}
+					}
+				}
+				if (posicion.getAlPaso() != '\0'
+						&& pieza.getNum() == '4'
+						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
+					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+							.getNum() - 1));
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
+							(char) (pieza.getNum() + 1));
+					if (p != null && p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() + 1), (char) (pieza
+										.getNum() - 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() + 1),
+									(char) (pieza.getNum() - 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
+							(char) (pieza.getNum() - 1));
+					if (p != null && p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() - 1), (char) (pieza
+										.getNum() - 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() - 1),
+									(char) (pieza.getNum() - 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+			break;
+		case CABALLO:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				Square destino = pieza.getCasilla().add(v);
+				try {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+							.getLetra(), destino.getNumero())) {
+						Piece p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (p == null
+								|| (p != null && Piece.esBandoContrario(pieza,
+										p)))
+							pieza.anadirMov(destino);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			break;
+		case DAMA:
+		case ALFIL:
+		case TORRE:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				try {
+					Square destino = pieza.getCasilla().add(v);
+					Piece p = posicion.getPieza(destino.getLetra(), destino
+							.getNumero());
+					while (p == null) {
+						p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+								.getLetra(), destino.getNumero())) {
+							if (p == null
+									|| (p != null && Piece.esBandoContrario(
+											pieza, p))) {
+								pieza.anadirMov(destino);
+							}
+						}
+						destino = destino.add(v);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			break;
+		case REY:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				Square destino = pieza.getCasilla().add(v);
+				try {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+							.getLetra(), destino.getNumero())) {
+						Piece p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (p == null
+								|| (p != null && Piece.esBandoContrario(pieza,
+										p)))
+							pieza.anadirMov(destino);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			if (posicion.getEnroqueCorto(posicion.getTurno())
+					&& !esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))
+					&& posicion.esVacia((char) (pieza.getLetra() + 1), pieza
+							.getNum())
+					&& !esCasillaAtacada((char) (pieza.getLetra() + 1), (pieza
+							.getNum()))
+					&& posicion.esVacia((char) (pieza.getLetra() + 2), pieza
+							.getNum())
+					&& !esCasillaAtacada((char) (pieza.getLetra() + 2), (pieza
+							.getNum()))) {
+				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
+			}
+			if (posicion.getEnroqueLargo(posicion.getTurno())
+					&& !esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))
+					&& posicion.esVacia((char) (pieza.getLetra() - 1), pieza
+							.getNum())
+					&& !esCasillaAtacada((char) (pieza.getLetra() - 1), (pieza
+							.getNum()))
+					&& posicion.esVacia((char) (pieza.getLetra() - 2), pieza
+							.getNum())
+					&& !esCasillaAtacada((char) (pieza.getLetra() - 2), (pieza
+							.getNum()))) {
+				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
+			}
+			break;
+		}
+	}
+
+	/**
+	 * Metodo de utilidad que se comporta exactamente igual que
+	 * esCasillaAtacada(char, char)
+	 * 
+	 * @param c
+	 *            Casilla que queremos comprobar si esta siendo atacada
+	 * @return Devuelve un booleano indicando si es una casilla atacada o no
+	 */
+	public boolean esCasillaAtacada(Square c) {
+		return esCasillaAtacada(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * esCasillaAtacada determina si hay alguna pieza que ataque la casilla que
+	 * se le pasa como parametro. <BR>
+	 * NOTA sobre el codigo: se necesita comprobar el turno para: en el turno en
+	 * el que mueves necesitas saber que casillas estan atacadas por el bando
+	 * contrario, y solo por este bando. No interesan las casillas que ataca el
+	 * bando que mueve. Ademas se puede comprobar que una casillas es atacada
+	 * estando vacia lo cual implica que no hay colores contrarios y es
+	 * necesario conocer el turno para saber quien ataca
+	 * 
+	 * @param letra
+	 *            Letra de la casilla que queremos comprobar si esta siendo
+	 *            atacada
+	 * @param num
+	 *            N?mero de la casilla que queremos comprobart si est? siendo
+	 *            atacada
+	 * @return Devuelve un booleano indicando si es una casilla atacada o no
+	 */
+	public boolean esCasillaAtacada(char letra, char num) {
+		// Primero miro las casillas
+		// a salto de caballo. Despues, las verticales, horizontales y
+		// diagonales.
+
+		// Casillas a salto de caballo
+		ArrayList<DirectionVector> dir = new ArrayList<DirectionVector>();
+		dir.add(new DirectionVector(1, 2));
+		dir.add(new DirectionVector(-1, 2));
+		dir.add(new DirectionVector(2, 1));
+		dir.add(new DirectionVector(2, -1));
+		dir.add(new DirectionVector(1, -2));
+		dir.add(new DirectionVector(-1, -2));
+		dir.add(new DirectionVector(-2, 1));
+		dir.add(new DirectionVector(-2, -1));
+		for (DirectionVector v : dir) {
+			try {
+				Piece p = posicion.getPieza((char) (letra + v.getX()),
+						(char) (num + v.getY()));
+				if (p != null) {
+					if (Piece.esBandoContrario(posicion.getTurno(), p)
+							&& p.getTipo() == Tipo.CABALLO) {
+						return true;
+					}
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, 0));
+		dir.add(new DirectionVector(-1, 0));
+		dir.add(new DirectionVector(0, 1));
+		dir.add(new DirectionVector(0, -1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&& (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && p.getTipo() == Tipo.REY))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, 1));
+		dir.add(new DirectionVector(-1, 1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&& (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
+								.getTipo() == Tipo.PEON && p.getBando() == Bando.NEGRO))))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, -1));
+		dir.add(new DirectionVector(-1, -1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&& (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
+								.getTipo() == Tipo.PEON && p.getBando() == Bando.BLANCO))))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determina si un movimiento es legal, analizando la situacion en la
+	 * partida.
+	 * 
+	 * @param letOrig
+	 *            Letra de la casilla de origen.
+	 * @param numOrig
+	 *            Numero de la casilla de origen.
+	 * @param letDest
+	 *            Letra de la casilla de destino.
+	 * @param numDest
+	 *            Numero de la casilla de destino.
+	 * @return True si el movimiento es legal, false en caso contrario.
+	 */
+	private boolean esLegal(char letOrig, char numOrig, char letDest,
+			char numDest) {
+		boolean resultado;
+		Piece movida = posicion.getPieza(letOrig, numOrig);
+		Piece temp = posicion.getPieza(letDest, numDest);
+		posicion.borrarPiezaInternal(letOrig, numOrig);
+		posicion.setPiezaInternal(movida, letDest, numDest);
+		resultado = esCasillaAtacada(posicion.getKingPosition(posicion
+				.getTurno()));
+		posicion.borrarPiezaInternal(letDest, numDest);
+		posicion.setPiezaInternal(movida, letOrig, numOrig);
+		if (temp != null)
+			posicion.setPiezaInternal(temp, letDest, numDest);
+		return !resultado;
+	}
+
+	/**
+	 * Este metodo mueve una pieza en el tablero, comprobando que este
+	 * movimiento sea permitido.
+	 * 
+	 * @param origenLetra
+	 *            Es la letra de la casilla de origen
+	 * @param origenNum
+	 *            Es el numero de la casilla de origen
+	 * @param destinoLetra
+	 *            Es la letra de la casilla de destino
+	 * @param destinoNum
+	 *            Es el numero de la casilla de destino
+	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
+	 */
+	public Movement mover(char origenLetra, char origenNum,
+			char destinoLetra, char destinoNum) {
+		Piece piezaQueMueve;
+		int i;
+		Movement mov;
+		piezaQueMueve = posicion.getPieza(origenLetra, origenNum);
+
+		// Comprobamos que en la casilla de origen hay una pieza
+		if (piezaQueMueve == null) {
+			return null;
+		}
+
+		if (Piece.esBandoContrario(posicion.getTurno(), piezaQueMueve)) {
+			return null;
+		}
+		if (indice != movimientos.getNumHalfPly())
+			return null;
+		// Buscamos la casilla de destino entre las casillas validas de la
+		// pieza.
+		i = 0;
+		do {
+			// Buscamos la letra.
+			while ((i < piezaQueMueve.getCasillasValidas().size())
+					&& (destinoLetra != piezaQueMueve.getCasillasValidas().get(
+							i).getLetra())) {
+				i++;
+				// Comprobamos si el numero de la letra encontrada coincide.
+			}
+			if (i < piezaQueMueve.getCasillasValidas().size()) {
+				// Si se entra en el siguiente caso, es que el movimiento es
+				// valido
+				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
+						.getLetra()) {
+					mov = new Movement();
+					mov.setCasillaOrigen(new Square(origenLetra, origenNum));
+					mov
+							.setCasillaDestino(new Square(destinoLetra,
+									destinoNum));
+					mov.setNumeroMovimiento(posicion.getNumeroMovimiento());
+					mov.setBando(posicion.getTurno());
+					mov.setTipoPieza(piezaQueMueve.getTipo());
+
+					// Si se come ponemos el contador a 0
+					if (!posicion.esVacia(destinoLetra, destinoNum)) {
+						posicion.setContadorTablas(0);
+						hash.borrarTabla();
+						mov.setCasillaComer(new Square(destinoLetra,
+								destinoNum));
+						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
+								destinoNum).getTipo());
+						posicion.borrarPieza(mov.getCasillaComer());
+					}
+
+					// Se hacen los calculos especiales si se trata de un peon
+					if (piezaQueMueve.getTipo() == Tipo.PEON) {
+						// Se borra la pieza correspondiente si se come al paso
+						if (Math.abs(destinoLetra - origenLetra) == 1
+								&& posicion.esVacia(destinoLetra, destinoNum)) {
+							mov.setTipoPiezaComida(posicion.getPieza(
+									destinoLetra, origenNum).getTipo());
+							mov.setCasillaComer(new Square(destinoLetra,
+									origenNum));
+							posicion.borrarPieza(mov.getCasillaComer());
+						}
+						// Se establece la variable alPaso a su valor
+						// correspondiente
+						if (Math.abs(destinoNum - origenNum) == 2) {
+							posicion.setAlPaso(origenLetra);
+							mov.setAlPaso(posicion.getAlPaso());
+						} else {
+							posicion.setAlPaso('\0');
+						}
+						// Coronacion
+						if (destinoNum == '1' || destinoNum == '8') {
+							// if (mostrarDialogoCoronacion) {
+							// mostrarDialogoCoronacion ();
+							// }
+							piezaQueMueve = new Piece(piezaQueMueve.getBando(),
+									coronar);
+
+							mov.setCoronacion(coronar);
+						}
+						posicion.setContadorTablas(0);
+						hash.borrarTabla();
+					}
+					// Se hacen los calculos especiales si se trata de un rey
+					if (piezaQueMueve.getTipo() == Tipo.REY) {
+						// Movemos las torres en caso de enroque
+						if ((destinoLetra - origenLetra) == 2) {
+							Piece torre = posicion.getPieza('h', origenNum);
+							posicion.borrarPieza('h', origenNum);
+							posicion.setPieza(torre, 'f', origenNum);
+						} else {
+							if ((destinoLetra - origenLetra) == -2) {
+								Piece torre = posicion.getPieza('a', origenNum);
+								posicion.borrarPieza('a', origenNum);
+								posicion.setPieza(torre, 'd', origenNum);
+							}
+						}
+					}
+
+					mov.setContadorTablas(posicion.getContadorTablas());
+					boolean[][] enroque = new boolean[2][2];
+					enroque[0][0] = posicion.getEnroqueCorto(Bando.BLANCO);
+					enroque[0][1] = posicion.getEnroqueLargo(Bando.BLANCO);
+					enroque[1][0] = posicion.getEnroqueCorto(Bando.NEGRO);
+					enroque[1][1] = posicion.getEnroqueLargo(Bando.NEGRO);
+					mov.setEnroque(enroque);
+					if (posicion.getTurno() == Bando.NEGRO)
+						posicion.addNumeroMovimiento();
+					posicion.setTurno();
+
+					posicion.borrarPieza(origenLetra, origenNum);
+					posicion.setPieza(piezaQueMueve, destinoLetra, destinoNum);
+					posicion.addContadorTablas();
+					calcularMovimientos();
+
+					if (esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))) {
+						mov.setJaque(true);
+					} else {
+						mov.setJaque(false);
+					}
+					mov.setFinPartida(esFinPartida());
+
+					hash.insertar(posicion.getClavePosicion());
+					movimientos.appendMovimiento(mov);
+					indice++;
+					return mov;
+				} else {
+					i++;
+				}
+			} else {
+				return null;
+			}
+		} while (true);
+	}
+
+	/**
+	 * Avanza por la lista de movimientos de la partida.
+	 * 
+	 * @return El movimiento al que lleguemos en la lista de movimientos.
+	 */
+	public Movement avanzar() {
+		Movement mov;
+		Piece piezaQueMueve;
+		if (indice < movimientos.getNumHalfPly()) {
+			mov = movimientos.getMovimiento(indice);
+			piezaQueMueve = posicion.getPieza(mov.getCasillaOrigen());
+			// Si se come al paso
+			if (piezaQueMueve.getTipo() == Tipo.PEON
+					&& Math.abs(mov.getCasillaDestino().getLetra()
+							- mov.getCasillaOrigen().getLetra()) == 1
+					&& posicion.esVacia(mov.getCasillaDestino())) {
+				posicion.borrarPieza(mov.getCasillaComer());
+			}
+			// Si se corona
+			if (mov.getCoronacion() != null) {
+				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+						.getCoronacion());
+			}
+			// Se hacen los calculos especiales si se trata de un rey
+			if (piezaQueMueve.getTipo() == Tipo.REY) {
+				// Movemos las torres en caso de enroque
+				Square origen = mov.getCasillaOrigen();
+				Square destino = mov.getCasillaDestino();
+				if ((destino.getLetra() - origen.getLetra()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getNumero());
+					posicion.borrarPieza('h', origen.getNumero());
+					posicion.setPieza(torre, 'f', origen.getNumero());
+				} else {
+					if ((destino.getLetra() - origen.getLetra()) == -2) {
+						Piece torre = posicion
+								.getPieza('a', origen.getNumero());
+						posicion.borrarPieza('a', origen.getNumero());
+						posicion.setPieza(torre, 'd', origen.getNumero());
+					}
+				}
+			}
+			posicion.borrarPieza(mov.getCasillaOrigen());
+			posicion.setPieza(piezaQueMueve, mov.getCasillaDestino());
+			posicion.setContadorTablas(mov.getContadorTablas());
+			boolean[][] enroques = mov.getEnroque();
+			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
+			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
+			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
+			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
+			posicion.setAlPaso(mov.getAlPaso());
+			posicion.setTurno();
+			indice++;
+			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			return mov;
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Retrocede por la lista de movimientos de la partida.
+	 * 
+	 * @return El movimiento al que lleguemos en la lista de movimientos.
+	 */
+	public Movement retroceder() {
+		Movement mov;
+		Piece piezaQueMueve;
+		if (indice > 0) {
+			indice--;
+			mov = movimientos.getMovimiento(indice);
+			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
+			if (mov.getCoronacion() != null) {
+				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+						.getCoronacion());
+			}
+			if (piezaQueMueve.getTipo() == Tipo.REY) {
+				// Movemos las torres en caso de enroque
+				Square origen = mov.getCasillaOrigen();
+				Square destino = mov.getCasillaDestino();
+				if ((destino.getLetra() - origen.getLetra()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getNumero());
+					posicion.borrarPieza('h', origen.getNumero());
+					posicion.setPieza(torre, 'f', origen.getNumero());
+				} else {
+					if ((destino.getLetra() - origen.getLetra()) == -2) {
+						Piece torre = posicion
+								.getPieza('a', origen.getNumero());
+						posicion.borrarPieza('a', origen.getNumero());
+						posicion.setPieza(torre, 'd', origen.getNumero());
+					}
+				}
+			}
+			posicion.borrarPieza(mov.getCasillaDestino());
+			if (mov.getTipoPiezaComida() != null) {
+				posicion.setPieza(new Piece(
+						piezaQueMueve.getBando() == Bando.BLANCO ? Bando.BLANCO
+								: Bando.NEGRO, mov.getTipoPieza()), mov
+						.getCasillaComer());
+			}
+			posicion.setPieza(piezaQueMueve, mov.getCasillaOrigen());
+			posicion.setContadorTablas(mov.getContadorTablas());
+			boolean[][] enroques = mov.getEnroque();
+			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
+			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
+			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
+			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
+			posicion.setAlPaso(mov.getAlPaso());
+			posicion.setTurno();
+			return mov;
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Este metodo comprueba si se produce alguna situacion en la que termine
+	 * una partida.
+	 * 
+	 * @return Devuelve '\0' si la partida no se ha acabado, 'B' si las blancas
+	 *         han dado jaque mate, 'N' si las negras han dado jaque mate o 'T'
+	 *         si se produce una situacion de tablas.
+	 */
+	private Resultado esFinPartida() {
+		Piece pieza;
+		Resultado devolver = null;
+		boolean fin = false, fin2 = false, posibleMatInsuf = false;
+		char i, j;
+		// Tablas por 50 movimientos
+		if (posicion.getContadorTablas() == 50) {
+			fin = true;
+			devolver = Resultado.TABLAS_50_MOV;
+		}
+		// Tablas por repeticion de posiciones
+		if (hash.getRepeticiones(posicion.getClavePosicion()) == 3) {
+			fin = true;
+			devolver = Resultado.TABLAS_REPETICION;
+		}
+		// Tablas por material insuficiente
+		i = 'a';
+		j = '1';
+		while (i <= 'h' && !fin2) {
+			while (j <= '8' && !fin2) {
+				pieza = posicion.getPieza(i, j);
+				if (pieza != null) {
+					if (posibleMatInsuf) {
+						if (pieza.getTipo() != Tipo.REY) {
+							fin2 = true;
+						}
+					} else {
+						switch (pieza.getTipo()) {
+						case PEON:
+						case DAMA:
+						case TORRE:
+							fin2 = true;
+							break;
+						case ALFIL:
+						case CABALLO:
+							posibleMatInsuf = true;
+							break;
+						case REY:
+							break;
+						}
+					}
+				}
+				j++;
+			}
+			j = '1';
+			i++;
+		}
+		if (!fin2) {
+			fin = true;
+			devolver = Resultado.TABLAS_INSUF_MATERIAL;
+		}
+		// Miramos si hay movimientos posibles
+		i = 'a';
+		j = '1';
+		while (i <= 'h' && !fin) {
+			while (j <= '8' && !fin) {
+				pieza = posicion.getPieza(i, j);
+				if ((pieza != null)
+						&& (!Piece.esBandoContrario(posicion.getTurno(), pieza))
+						&& (!pieza.getCasillasValidas().isEmpty())) {
+					fin = true;
+				}
+				j++;
+			}
+			j = '1';
+			i++;
+		}
+		if (!fin) {
+			// Negras dan jaque mate
+			if (posicion.getTurno() == Bando.BLANCO)
+				if (esCasillaAtacada(posicion.getKingPosition(Bando.BLANCO))) {
+					devolver = Resultado.JAQUE_MATE_NEGRO;
+				} else {
+					devolver = Resultado.TABLAS_AHOGADO;
+				}
+			else
+			// Blancas dan jaque mate
+			if (esCasillaAtacada(posicion.getKingPosition(Bando.NEGRO))) {
+				devolver = Resultado.JAQUE_MATE_BLANCO;
+			}
+			// Tablas por ahogado
+			else {
+				devolver = Resultado.TABLAS_AHOGADO;
+			}
+		}
+		return devolver;
+	}
+
+	/**
+	 * Interpreta un movimiento en notacion algebraica y lo realiza en la
+	 * Logica. NOTA: Partimos de la base de que el turno corresponde con el
+	 * movimiento que se recibe: no se puede dar el caso de que se reciba un
+	 * movimiento de negras y que el turno pertenezca a blancas o viceversa.
+	 * 
+	 * @param mov
+	 *            String que contiene el movimiento en notacion algebraica.
+	 * @todo Poner las ambig?edades de la dama
+	 * @todo Puede ser que tengamos un problema: cuando una pieza esta clavada
+	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
+	 *       tenerlo en cuenta.
+	 */
+	public Movement moverALG(String mov) {
+		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
+		char tipoPieza = 'P';
+		Tipo piezaCoronacion = null;
+		int contadorOesEnroque = 0, i;
+		boolean finDestino = false;
+
+		for (i = mov.length() - 1; i >= 0; i--) {
+			switch (mov.charAt(i)) {
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+				if (!finDestino) {
+					destinoNum = mov.charAt(i);
+				} else {
+					origenNum = mov.charAt(i);
+				}
+				break;
+			case 'a':
+			case 'b':
+			case 'c':
+			case 'd':
+			case 'e':
+			case 'f':
+			case 'g':
+			case 'h':
+				if (!finDestino) {
+					destinoLetra = mov.charAt(i);
+				} else {
+					origenLetra = mov.charAt(i);
+				}
+				finDestino = true;
+				break;
+			case 'B':
+				if (i != 0) {
+					piezaCoronacion = Tipo.ALFIL;
+				} else {
+					tipoPieza = 'A';
+				}
+				break;
+			case 'K':
+				tipoPieza = 'R';
+				break;
+			case 'N':
+				if (i != 0) {
+					piezaCoronacion = Tipo.CABALLO;
+				} else {
+					tipoPieza = 'C';
+				}
+				break;
+			case 'Q':
+				if (i != 0) {
+					piezaCoronacion = Tipo.DAMA;
+				} else {
+					tipoPieza = 'D';
+				}
+				break;
+			case 'R':
+				if (i != 0) {
+					piezaCoronacion = Tipo.TORRE;
+				} else {
+					tipoPieza = 'T';
+				}
+				break;
+			case '0':
+			case 'o':
+			case 'O':
+				contadorOesEnroque++;
+				break;
+			case 'x':
+			case '+':
+			case '!':
+			case '?':
+			case '-':
+			case '=':
+				break;
+			default:
+				System.out.print("Caracter desconocido: " + mov.charAt(i));
+				break;
+			}
+		}
+		if(piezaCoronacion!=null) {
+			// TODO hacer el mostrarDialogoCoronacion;
+			coronar = piezaCoronacion;
+		}
+		// Enroque Corto
+		if (contadorOesEnroque == 2) {
+			origenLetra = 'e';
+			destinoLetra = 'g';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else if (contadorOesEnroque == 3) {
+			origenLetra = 'e';
+			destinoLetra = 'c';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else {
+			Square c = new Square(destinoLetra, destinoNum);
+			if (origenLetra == '\0' && origenNum != '\0') {
+				for (char ii = 'a'; ii <= 'h'; ii++) {
+					Piece p = posicion.getPieza(ii, origenNum);
+					if (p.canMove(c)) {
+						origenLetra = ii;
+						break;
+					}
+				}
+			} else if (origenLetra != '\0' && origenNum == '\0') {
+				for (char ii = '1'; ii <= '8'; ii++) {
+					Piece p = posicion.getPieza(origenLetra, ii);
+					if (p.canMove(c)) {
+						origenNum = ii;
+						break;
+					}
+				}
+			} else {
+				for (char ii = '1'; ii <= '8'; ii++) {
+					for (char jj = 'a'; jj <= 'h'; jj++) {
+						Piece p = posicion.getPieza(jj, ii);
+						if (p.canMove(c)) {
+							origenNum = ii;
+							break;
+						}
+					}
+				}
+			}
+		}
+		if (origenLetra == '\0' || origenNum == '\0' || destinoLetra == '\0'
+				|| destinoNum == '\0') {
+			System.out.println(tipoPieza + " " + origenLetra + " " + origenNum
+					+ " " + destinoLetra + " " + destinoNum);
+			return null;
+		} else {
+			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
+		}
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/chess/Board2D.java (from rev 32, trunk/MihailChessLib/com/mihail/chess/Tablero2D.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,569 @@
+package com.mihail.chess;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Font;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Image;
+import java.awt.MediaTracker;
+import java.awt.Point;
+import java.awt.geom.Rectangle2D;
+
+import javax.swing.ImageIcon;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+
+import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Piece.Tipo;
+
+/**
+ * Esta clase se encarga de proporcionar una vista b?sica de la l?gica, usada
+ * como modelo. No proporciona ningun metodo de manejo de eventos, y enmascara
+ * las funciones de la l?gica interna.
+ * 
+ * @author Pedro Su?rez Casal
+ * @author Iago Porto D?az
+ */
+public class Board2D extends JPanel {
+
+	private static final long serialVersionUID = 1L;
+
+	/*
+	 * Tama?o del borde del tablero.
+	 */
+	private int BORDE = 30;
+
+	/*
+	 * Tama?o de la casilla.
+	 */
+	private int TAM;
+
+	/*
+	 * Tama?o anterior, para comparar si es necesario redimensionar.
+	 * 
+	 * @TODO ?Es necesario este atributo? Queda chapucero.
+	 */
+	private int TAMant;
+
+	/*
+	 * Coordenada 'x' de la casilla pulsada por ultima vez [0, 8]. Sirve para
+	 * indicar al metodo de dibujo que la casilla indicada no se debe dibujar si
+	 * se esta arrastrando la pieza.
+	 */
+	protected int posX;
+
+	/*
+	 * Coordenada 'y' de la casilla pulsada por ultima vez [0, 8].
+	 */
+	protected int posY;
+
+	// Espacios que hay que dejar alrededor del tablero cuando se redimensiona
+	private int bordeSUP = 0;
+
+	private int bordeLAT = 0;
+
+	// Logica interna del tablero
+
+	protected Position tablero;
+
+	// Versiones ajustadas al tama?o correcto de las imagenes
+	private Image[][] piezas = new Image[2][6];
+
+	// Indica el sentido en el que se esta dibujando el tablero
+	private boolean sentido = true;
+
+	// Matriz en la que se van marcando las casillas seleccionada
+	// 'S' -> Casilla seleccionada (amarillo transparente)
+	// 'C' -> Indica que se comio (cuadro rojo)
+	private char seleccion[][] = new char[8][8];
+
+	// Indica si se esta arrastrando una pieza
+	private boolean arrastrando = false;
+
+	/*
+	 * Posicion de la pieza que se esta arrastrando. Se usa en el metodo de
+	 * dibujo para dibujar la pieza piezaArrastrada en el lugar correcto. TODO
+	 * Remodelar para a?adir objetos arbitrarios al tablero, entre ellos piezas
+	 * que estan siendo arrastradas.
+	 */
+	private int posPiezaX, posPiezaY;
+
+	/*
+	 * Imagen de la pieza qu esta siendo arrastrada.
+	 */
+	private Image piezaArrastrada;
+
+	/*
+	 * Colores que se dibujan las casillas en caso de que el tema no lo
+	 * establezca.
+	 */
+	private Color[] colorLiso = new Color[2];
+
+	/*
+	 * Tema que esta usando el tablero para dibujarse.
+	 */
+
+	private BoardTheme theme;
+
+	public Board2D(BoardTheme theme) {
+		this(theme, 60);
+	}
+
+	public Board2D(BoardTheme theme, int tam) {
+		super();
+		tablero = new Position();
+
+		TAM = tam;
+
+		// this.setAutoscrolls(true);
+		this.theme = theme;
+
+		redimensionar();
+	}
+
+	/**
+	 * Se encarga de cambiar el sentido del tablero.
+	 */
+
+	public void rotarTablero() {
+		sentido = !sentido;
+		repaint();
+	}
+
+	public Dimension getPreferredSize() {
+		return (new Dimension(8 * TAM + BORDE * 2, 8 * TAM + BORDE * 2));
+	}
+
+	public void paintComponent(Graphics g) {
+		Piece temp;
+		// Actualizamos el tama?o de la casilla en caso de que redimensionen el
+		// tablero
+		int TAMtotal = Math.min(getWidth(), getHeight());
+		Graphics2D g2d = (Graphics2D) g;
+		TAMant = TAM;
+		TAM = (TAMtotal - BORDE * 2) / 8;
+		if (TAMant != TAM) {
+			redimensionar();
+		}
+
+		// Hints de renderizado
+		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+
+		if(theme.getBackground()==null) {
+			g.setColor(Color.LIGHT_GRAY);
+			g.fillRect(0, 0, getWidth(), getHeight());
+		} else {
+			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
+		}
+
+		if (getWidth() < getHeight()) {
+			bordeSUP = (getHeight() - getWidth()) / 2;
+			bordeLAT = 0;
+		} else {
+			bordeLAT = (getWidth() - getHeight()) / 2;
+			bordeSUP = 0;
+		}
+		g.setClip(bordeLAT, bordeSUP, TAMtotal, TAMtotal);
+		g.translate(bordeLAT, bordeSUP);
+
+		// Borde tablero
+		dibujarBorde(g);
+		// Bucle para dibujar el tablero
+
+		g.setClip(BORDE, BORDE, getWidth() - BORDE, getHeight() - BORDE);
+		g.translate(BORDE, BORDE);
+		for (int j = 0; j < 8; j++) {
+			for (int i = 0; i < 8; i++) {
+				// En funcion de nuestra posicion escogemos el color para
+				// casillas blancas o negras
+				// if (activado) {
+				int v = (i + j) % 2;
+				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
+						: Bando.NEGRO);
+				if (textura != null)
+
+					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
+
+				else {
+					g.setColor(colorLiso[v]);
+					g.fillRect(i * TAM, j * TAM, TAM, TAM);
+				}
+
+				// Dibujamos la casilla
+				//
+				// En caso de que la casilla que tratamos este seleccionada, la
+				// marcamos de color verde
+				int ii = i, jj = j;
+				if (!sentido) {
+					ii = 7 - i;
+					jj = 7 - j;
+				}
+
+				// En funcion del caracter de seleccion dibujamos una cosa u
+				// otra
+				switch (seleccion[ii][jj]) {
+				case 'S':
+					g.setColor(new Color(255, 255, 0, 50));
+					g.fill3DRect(i * TAM, j * TAM, TAM, TAM, true);
+					break;
+				case 'M':
+					g2d.setStroke(new BasicStroke(2.0F, BasicStroke.CAP_BUTT,
+							BasicStroke.JOIN_ROUND));
+					g.setColor(new Color(220, 0, 0));
+					g2d.draw(new Rectangle2D.Float(i * TAM, j * TAM, TAM - 1,
+							TAM - 1));
+
+					// g.drawRect(i * TAM, j * TAM, TAM-1, TAM-1);
+					break;
+				default:
+				}
+
+				// Comprobamos si existe pieza en esa casilla, y en ese caso la
+				// dibujamos
+				char letra, numero;
+				// Se comprueba el sentido en el que dibujamos
+				if (sentido) {
+					numero = (char) ((7 - j) + '1');
+					letra = (char) (i + 'a');
+				} else {
+					numero = (char) (j + '1');
+					letra = (char) ((7 - i) + 'a');
+				}
+
+				if ((temp = tablero.getPieza(letra, numero)) != null) {
+					if (arrastrando
+							&& ((sentido && i == posX && j == posY) || (!sentido
+									&& i == 7 - posX && j == 7 - posY))) {
+						continue;
+					}
+
+					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
+					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
+				}
+			}
+
+		}
+
+		// Este es el caso de que haya que dibujar la pieza a arrastrar. Se
+		// dibuja por encima de todo el resto del tablero
+		if (piezaArrastrada != null) {
+			g.translate(-bordeLAT, -bordeSUP);
+			g.translate(-BORDE, -BORDE);
+			g.setClip(posPiezaX - TAM / 2, posPiezaY - TAM / 2, TAM, TAM);
+			if (arrastrando) {
+				g.drawImage(piezaArrastrada, posPiezaX - TAM / 2, posPiezaY
+						- TAM / 2, null);
+			}
+		}
+
+	}
+
+	/**
+	 * @return Devuelve el tama?o del borde del tablero.
+	 */
+
+	public int getBorde() {
+		return BORDE;
+	}
+
+	/**
+	 * @return Devuelve el tama?o de las casilla.
+	 */
+
+	public int getTamanhoCasilla() {
+		return TAM;
+	}
+
+	/**
+	 * @param tam
+	 *            Establece el tama?o de las casilla.
+	 */
+
+	public void setTamanhoCasilla(int tam) {
+		TAM = tam;
+	}
+
+	/**
+	 * Establece que una pieza se esta arrastrando para que la dibuje en la
+	 * posicion correspondiente.
+	 * 
+	 * @param arrastrando
+	 *            El valor al que queremos establecer si se esta arrastrando o
+	 *            no.
+	 */
+	public void setArrastrando(boolean arrastrando) {
+		this.arrastrando = arrastrando;
+	}
+
+	/**
+	 * @param piezaArrastrada
+	 *            Establece al imagen a arrastrar.
+	 */
+	public void setPiezaArrastrada(Image piezaArrastrada) {
+		this.piezaArrastrada = piezaArrastrada;
+	}
+
+	/**
+	 * @return Devuelve si la casilla indicada por (i, j) tiene algun tipo de
+	 *         seleccion.
+	 */
+
+	public char getSeleccion(int i, int j) {
+		return seleccion[i][j];
+	}
+
+	/**
+	 * Establece la seleccion de una casilla.
+	 * 
+	 * @param s
+	 *            Seleccion a la que establecemos la casilla.
+	 */
+	public void setSeleccion(char s, int i, int j) {
+		this.seleccion[i][j] = s;
+	}
+
+	public Point getPosPiezaArrastrada() {
+		return new Point(posPiezaX, posPiezaY);
+	}
+
+	/**
+	 * @param posPiezaX
+	 *            The posPiezaX to set.
+	 */
+	public void setPosPiezaArrastrada(int posPiezaX, int posPiezaY) {
+		this.posPiezaX = posPiezaX;
+		this.posPiezaY = posPiezaY;
+	}
+
+	/**
+	 * @return Devuelve el borde lateral, el espacio que puede sobrar a los
+	 *         lados del tablero.
+	 */
+	public int getBordeLateral() {
+		return bordeLAT;
+	}
+
+	/**
+	 * @return Devuelve el borde superior, el espacio que puede sobrar arriba y
+	 *         abajo del tablero.
+	 */
+	public int getBordeSuperior() {
+		return bordeSUP;
+	}
+
+	/**
+	 * Indica el sentido en el que se esta dibujando el tablero
+	 * 
+	 * @return Devuelve true si las blancas estan abajo y false si las negras
+	 *         estan abajo.
+	 */
+
+	public boolean isSentido() {
+		return sentido;
+	}
+
+	/**
+	 * Establece el sentido del tablero.
+	 * 
+	 * @param sentido
+	 *            The sentido to set.
+	 */
+	public void setSentido(boolean sentido) {
+		this.sentido = sentido;
+	}
+
+	/**
+	 * Obtiene el color liso de las casillas de un color.
+	 * 
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
+	 * @return El color liso.
+	 */
+	public Color getColorLiso(Bando b) {
+		return colorLiso[bandoToInt(b)];
+	}
+
+	/**
+	 * Establece el color liso de las casillas de un color. Este color solo se
+	 * mostrara en caso de que el tema no establezca una textura para las
+	 * casillas.
+	 * 
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
+	 * @param colorLiso
+	 *            El color liso.
+	 */
+
+	public void setColorLiso(Bando b, Color colorLiso) {
+		this.colorLiso[bandoToInt(b)] = colorLiso;
+	}
+
+	/**
+	 * Establece el tema que usa el tablero para dibujarse.
+	 * 
+	 * @param theme
+	 *            Tema a establecer.
+	 */
+
+	public void setTema(BoardTheme theme) {
+		this.theme = theme;
+	}
+	
+	public void setPieza(Piece pieza, Square casilla) {
+		tablero.setPieza(pieza, casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void borrarPieza(Square casilla) {
+		tablero.borrarPieza(casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void setFEN(String pos) {
+		tablero.setPosicion(pos);
+		repaint();
+	}
+
+	/*
+	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
+	 * el centro de la casilla. TODO Modificar para que funcione con la esquina
+	 * superior izquierda?
+	 */
+
+	protected void repintarCasilla(int x, int y) {
+		repaint(x - TAM / 2, y - TAM / 2, TAM, TAM);
+	}
+
+	/**
+	 * Metodo de utilidad para obtener de forma sencilla la casilla
+	 * correspondiente a la que pertenece un pixel en la posicion (x, y).
+	 * 
+	 * @param x
+	 *            Coordenada x
+	 * @param y
+	 *            Coordenada y
+	 * @return Devuelve un punto con las coordenadas de la casilla
+	 *         correspondiente al punto x, y. El valor devuelto estar? en el
+	 *         intervalo [0, 7].
+	 */
+	protected Point getCasilla(int x, int y) {
+		int posX = (x - BORDE - bordeLAT) / TAM, posY = (y - BORDE - bordeSUP)
+				/ TAM;
+		if (!isSentido()) {
+			posX = 7 - posX;
+			posY = 7 - posY;
+		}
+		return new Point(posX, posY);
+	}
+
+	private void dibujarBorde(Graphics g) {
+		Image borde = theme.getMarco();
+		if (borde != null) {
+			g.drawImage(borde, 0, 0, null);
+		} else { // Dibujamos a mano
+			g.setColor(Color.BLACK);
+
+			g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
+					getWidth(), getHeight()));
+			// char num = '8';
+			// char let = 'a';
+
+			g.setColor(new Color(209, 193, 134));
+			g.setFont(new Font("Arial", Font.BOLD, 12));
+
+			int yF = 8 * TAM + BORDE * 3 / 2 + 6;
+			for (int i = 0; i < 8; i++) {
+				int xF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
+					g.drawString(new Character((char) (i + 'A')).toString(),
+							xF, yF);
+				} else {
+					g.drawString(
+							new Character((char) (7 - i + 'A')).toString(), xF,
+							yF);
+				}
+			}
+			int xF = BORDE / 2 - 3;
+			for (int i = 0; i < 8; i++) {
+				yF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
+
+					g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
+
+				} else {
+					g.drawString(new Integer(i + 1).toString(), xF, yF);
+				}
+			}
+		}
+	}
+
+	private int bandoToInt(Bando b) {
+		if (b == Bando.BLANCO) {
+			return 0;
+		}
+		return 1;
+	}
+	
+	private int tipoToInt(Tipo tipo) {
+		switch(tipo) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		}
+		return -1;
+	}
+	
+	private Tipo intToTipo(int i) {
+		switch(i) {
+		case 0:
+			return Tipo.PEON;
+		case 1:
+			return Tipo.CABALLO;
+		case 2:
+			return Tipo.ALFIL;
+		case 3:
+			return Tipo.TORRE;
+		case 4:
+			return Tipo.DAMA;
+		case 5:
+			return Tipo.REY;
+		}
+		return null;
+	}
+
+	/*
+	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
+	 * tama?o adecuado del tablero
+	 */
+
+	private final void redimensionar() {
+		MediaTracker media = new MediaTracker(this);
+		for (int i = 0; i < 2; i++) {
+			for (int j = 0; j < 6; j++) {
+				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
+						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
+				media.addImage(piezas[i][j], 1);
+			}
+		}
+		try {
+			media.waitForID(1);
+		} catch (InterruptedException e) {
+			JOptionPane.showMessageDialog(this,
+					"Redimensionado de Imagenes Interrumpido:\n"
+							+ e.getMessage());
+		}
+	}
+}
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -13,8 +13,8 @@
 
 import javax.swing.ImageIcon;
 
-import com.mihail.chess.Logica.Bando;
-import com.mihail.chess.Pieza.Tipo;
+import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Piece.Tipo;
 
 /**
  * Representa el tema de imagenes de piezas, texturas de las casillas, textura

Deleted: trunk/MihailChessLib/com/mihail/chess/Casilla.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,111 +0,0 @@
-/*
- * Created on 25-jul-2005
- *
- * MihailChess - Casilla.java
- * 
- * Autores:  Iago Porto Diaz
- * 			 Pedro Suarez Casal
- * 
- */
-package com.mihail.chess;
-
-/**
- * Representa una casilla en un tablero de ajedrez. Simplemente almacena informacion sobre
- * la letra y el numero.
- * @author wotan
- *
- */
-
-public class Casilla {
-
-	private char letra;
-
-	private char numero;
-
-	/**
-	 * Crea una casilla con la letra y numero iguales a cero.
-	 *
-	 */
-	
-	public Casilla() {
-		this.letra = 0;
-		this.numero = 0;
-	}
-	
-	/**
-	 * Crea una casilla con la letra y numero indicados.
-	 * 
-	 * @param letra Letra de la casilla
-	 * @param numero Numera de la casilla
-	 */
-
-	public Casilla(char letra, char numero) {
-		this.letra = letra;
-		this.numero = numero;
-	}
-
-	public boolean equals(Object o) {
-		if (o instanceof Casilla) {
-			Casilla c = (Casilla) o;
-			return c.letra == letra && c.numero == numero;
-		}
-		return false;
-	}
-	
-	/**
-	 * Suma a la casilla actual un vector de direccion, dando como resultado otra casilla.
-	 * A la letra se le suma la direccion x y al numero la direccion y.
-	 * 
-	 * @param v El vector que queremos sumar a la casilla actual.
-	 * @return Otra casilla resultado de sumar a la casilla actual el vector recibido.
-	 */
-
-	public Casilla add(VectorDireccion v) {
-		return new Casilla((char) (this.letra + v.getX()),
-				(char) (this.numero + v.getY()));
-	}
-	
-	/**
-	 * Obtiene la letra de la casilla.
-	 * 
-	 * @return La letra de la casilla
-	 */
-
-	public char getLetra() {
-		return letra;
-	}
-	
-	/**
-	 * Establece la letra de la casilla.
-	 * 
-	 * @param letra La letra de la casilla
-	 */
-
-	public void setLetra(char letra) {
-		this.letra = letra;
-	}
-	
-	/**
-	 * Obtiene el numero de la casilla.
-	 * 
-	 * @return El numero de la casilla
-	 */
-
-	public char getNumero() {
-		return numero;
-	}
-	
-	/**
-	 * Establece el numero de la casilla.
-	 * 
-	 * @param numero El numero de la casilla
-	 */
-
-	public void setNumero(char numero) {
-		this.numero = numero;
-	}
-
-	public String toString() {
-		return letra + "" + numero;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,125 +0,0 @@
-package com.mihail.chess;
-
-import java.util.ArrayList;
-
-/**
- * Esta clase define un objeto TablaHash, que representa a la tabla hash que se
- * usa para almacenar las claves que identifican las posiciones a lo largo de la
- * partida de ajedrez. Asocia a cada clave de posici?n el n?mero de
- * repeticiones.
- * 
- * @author Pedro Su?rez Casal
- * @author Iago Porto D?az
- */
-public final class DiccionarioPosiciones {
-	private ArrayList[] tabla;
-
-	private int tam;
-
-	/**
-	 * Crea una nueva tabla hash del tama?o indicado. Normalmente se creara una
-	 * tabla con un tama?o proximo a 40-50, para situarse en el peor caso de
-	 * repeticiones, y aumentar el rendimiento de la tabla.
-	 */
-	public DiccionarioPosiciones(int t) {
-		tabla = new ArrayList[t];
-		for (int i = 0; i < tabla.length; i++)
-			tabla[i] = new ArrayList();
-		tam = t;
-	}
-
-	/**
-	 * Inserta una clave de posicion dentro de la tabla. Cuando inserta una de
-	 * las claves tambien comprueba si esa posicion esta guardada. Si lo esta,
-	 * vuelve a guardar la clave con el numero de repeticiones aumentado, si no,
-	 * a?ade un nuevo elemento con las repeticiones a 1.
-	 * 
-	 * @param clave
-	 *            Clave que queremos insertar dentro de la tabla
-	 */
-	public void insertar(int clave) {
-		int pos = clave % tam;
-		int i = 0;
-
-		while (i < tabla[pos].size()
-				&& ((Item) tabla[pos].get(i)).getClave() != clave)
-			i++;
-
-		if (i < tabla[pos].size()) {
-			if (((Item) tabla[pos].get(i)).getClave() == clave)
-				((Item) tabla[pos].get(i)).aumentarRep();
-		} else
-			tabla[pos].add(new Item(clave));
-	}
-
-	/**
-	 * Borra todos los elementos de la tabla.
-	 */
-	public void borrarTabla() {
-		for (int i = 0; i < tabla.length; i++)
-			tabla[i].clear();
-	}
-
-	/**
-	 * Obtiene el numero de repeticiones de una posicion dada.
-	 * 
-	 * @param clave
-	 *            La clave asociada con una posicion.
-	 * @return El numero de repeticiones de la clave recibida.
-	 */
-	public int getRepeticiones(int clave) {
-		int pos = clave % tam;
-		int i = 0;
-
-		while (i < tabla[pos].size()
-				&& ((Item) (tabla[pos].get(i))).getClave() != clave)
-			i++;
-
-		if (i < tabla[pos].size())
-			return ((Item) tabla[pos].get(i)).getRepeticiones();
-		return -1;
-	}
-
-	public String toString() {
-		String cad = "[";
-		for (int i = 0; i < tabla.length; i++) {
-			cad += "[";
-			for (int j = 0; j < tabla[i].size(); j++) {
-				cad += tabla[i].get(j);
-			}
-			cad += "]";
-		}
-
-		cad += "]";
-		return cad;
-	}
-	
-	private final class Item {
-		private int clave;
-
-		private int repeticiones = 1;
-
-		public Item(int num) {
-			clave = num;
-		}
-
-		public int getClave() {
-			return clave;
-		}
-
-		public int getRepeticiones() {
-			return repeticiones;
-		}
-
-		public void aumentarRep() {
-			repeticiones++;
-		}
-
-		public String toString() {
-			String cad = "(" + clave + ", " + repeticiones + ")";
-
-			return cad;
-		}
-
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/DirectionVector.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/DirectionVector.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,77 @@
+package com.mihail.chess;
+
+/**
+ * Almacena la direcci?n en la que una pieza puede mover. Cuando se crea un
+ * nuevo vector direcci?n, se entiende que la x y la y indican las componentes
+ * del vector dentro del tablero. Adem?s el vector debe ser 'unitario' para que
+ * la l?gica lo interprete correctamente. Por ejemplo, si queremos indicar los
+ * movimientos posibles de una dama, basta con indicar 8 vectores de direcci?n:
+ * (1, 0) (1, 1) (1, -1) (0, 1) (0, -1) (-1, 0) (-1, 1) (-1, -1). Esto
+ * proporciona gran flexibilidad a la hora de definir nuevas piezas en sistemas
+ * de ajedrez alternativos. Podriamos definir una pieza que se mueva unicamente
+ * como (1, 2) y (0, 1). TODO indicar los vectores que deben ser estrictamente
+ * unitarios, para diferenciar piezas que se mueven una casilla de las que se
+ * mueven toda la fila. Quiza sea conveniente indicarlo en Pieza, junto con si
+ * la pieza puede saltar a otras.
+ */
+
+public class DirectionVector {
+	private int x, y;
+
+	/**
+	 * Crea un nuevo vector de direcci?n.
+	 * 
+	 * @param x_
+	 *            Desplazamiento permitido en sentido horizontal, es decir, a
+	 *            traves de las filas
+	 * @param y_
+	 *            Desplazamiento permitido en sentido vertical, es decir, a
+	 *            traves de las columnas
+	 */
+	public DirectionVector(int x_, int y_) {
+		x = x_;
+		y = y_;
+	}
+
+	/**
+	 * Comprueba si un vector es multiplo de otro. Por ejemplo, devolveria true
+	 * en caso que al vector (1, 1) se le pase el vector (2, 2).
+	 * 
+	 * @param v
+	 *            Vector con el que queremos comprobar si es la misma direccion.
+	 * @return Un booleano si este vector y el recibido siguen la misma
+	 *         direccion.
+	 */
+	public boolean esMismaDireccion(DirectionVector v) {
+		int difX, difY;
+
+		if ((x == 0 && v.getX() != 0) || (y == 0 && v.getY() != 0))
+			return false;
+
+		if (v.getX() == 0 && x == 0)
+			difX = 1;
+		else
+			difX = v.getX() / x;
+
+		if (v.getY() == 0 && y == 0)
+			difY = 1;
+		else
+			difY = v.getY() / y;
+
+		return (difY == difX);
+	}
+
+	/**
+	 * Devuelve el desplazamiento horizontal de este vector.
+	 */
+	public int getX() {
+		return x;
+	}
+
+	/**
+	 * Devuelve el desplazamiento vertical de este vector.
+	 */
+	public int getY() {
+		return y;
+	}
+}

Deleted: trunk/MihailChessLib/com/mihail/chess/Logica.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,1033 +0,0 @@
-package com.mihail.chess;
-
-import java.util.ArrayList;
-
-import com.mihail.chess.Pieza.Tipo;
-
-public class Logica {
-
-	public static enum Bando {
-		BLANCO, NEGRO;
-
-		public boolean equals(Bando b) {
-			return this == b;
-		}
-	}
-
-	public static enum Resultado {
-		JAQUE_MATE_BLANCO, JAQUE_MATE_NEGRO, TABLAS_REPETICION, TABLAS_50_MOV, TABLAS_INSUF_MATERIAL, TABLAS_AHOGADO
-	}
-
-	// public static final int JAQUE_MATE_BLANCO = 6;
-	// public static final int JAQUE_MATE_NEGRO = 1;
-	// public static final int TABLAS_REPETICION = 2;
-	// public static final int TABLAS_50_MOV = 3;
-	// public static final int TABLAS_INSUF_MATERIAL = 4;
-	// public static final int TABLAS_AHOGADO = 5;
-
-	/**
-	 * Este atributo sirve para guardar la lista de movimientos de una partida.
-	 */
-	private ArbolVariantes movimientos;
-
-	/**
-	 * Este atributo sirve para saber en que posicion de la lista de movimientos
-	 * nos encontramos, a la hora de avanzar y retroceder por una partida.
-	 * Siempre va una posici?n por delante de la aut?ntica posici?n
-	 */
-	private int indice;
-
-	/**
-	 * Este atributo se utiliza para las coronaciones.
-	 */
-	private Tipo coronar = Tipo.DAMA;
-
-	/**
-	 * Tabla hash usada para comprobar posiciones repetidas.
-	 */
-	private DiccionarioPosiciones hash = new DiccionarioPosiciones(51);
-
-	/**
-	 * Posicion actual en juego
-	 */
-	private Posicion posicion;
-
-	/**
-	 * Crea una nueva instancia de la clase y crea las piezas, colocandolas en
-	 * la posicion que indica el String posInicial.
-	 * 
-	 * @param posInicial
-	 *            Es un String que indica una posicion de juego, siguiendo el
-	 *            estandar FEN.
-	 */
-	public Logica(Posicion posInicial) {
-		movimientos = new ArbolVariantes();
-		posicion = posInicial;
-		hash.insertar(posicion.getClavePosicion());
-	}
-
-	/**
-	 * Reinicia la posicion del tablero a la posicion inicial.
-	 */
-	public void reiniciarTablero() {
-		posicion.setPosicion(Posicion.CAD_INICIAL);
-	}
-
-	/**
-	 * Indica a que pieza queremos coronar por defecto.
-	 * 
-	 * @param c
-	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
-	 */
-
-	public void setCoronacion(Tipo c) {
-		coronar = c;
-	}
-
-	/**
-	 * Permite saber el numero total de movimientos de la partida.
-	 * 
-	 * @return Un entero, el numero en cuestion.
-	 */
-
-	public int getNumTotalMovimientos() {
-		return movimientos.getNumMovimientos();
-	}
-
-	public Posicion getPosicion() {
-		return this.posicion;
-	}
-
-	/**
-	 * Obtiene el resultado de la partida.
-	 * 
-	 * @return Devuelve un caracter: <BR>
-	 *         'B' -> Victoria Blanca <BR>
-	 *         'N' -> Victoria Negra <BR>
-	 *         'T' -> Tablas <BR>
-	 *         '\0' -> Partida Inacabada o Resultado Desconocido
-	 */
-	public Resultado getResultado() {
-		return movimientos.getLastMovimiento().getFinPartida();
-	}
-
-	/**
-	 * Calcula los movimientos validos para todas las piezas del tablero.
-	 */
-	public void calcularMovimientos() {
-		for (char i = 'a'; i <= 'h'; i++) {
-			for (char j = '1'; j <= '8'; j++) {
-				Pieza p = posicion.getPieza(i, j);
-				if (p != null) {
-					if (!Pieza.esBandoContrario(posicion.getTurno(), p)) {
-						calcularMovimientos(p);
-					}
-				}
-			}
-		}
-	}
-
-	/**
-	 * Calcula los movimientos validos para una pieza en concreto, que se le
-	 * pasa como parametro.
-	 * 
-	 * @param pieza
-	 *            Pieza de la que queremos calcular sus movimientos legales
-	 */
-	private void calcularMovimientos(Pieza pieza) {
-		pieza.getCasillasValidas().clear();
-		switch (pieza.getTipo()) {
-		case PEON:
-			// Peon
-			// Peon blanco
-			if (pieza.getBando() == Bando.BLANCO) {
-				// Movimiento hacia delante
-				// Hacemos dos iteraciones, una para el caso de que avance
-				// una casilla, otra para el caso de que avance dos
-				if (posicion.esVacia(pieza.getLetra(),
-						(char) (pieza.getNum() + 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() + 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() + 1));
-						if (pieza.getNum() == '2'
-								&& posicion.esVacia(pieza.getLetra(),
-										(char) (pieza.getNum() + 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() + 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() + 2));
-							}
-						}
-					}
-				}
-				if (posicion.getAlPaso() != '\0'
-						&& pieza.getNum() == '5'
-						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
-							.getNum() + 1));
-				}
-				// Movimientos para comer
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() + 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() + 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-			// Peon negro
-			else {
-				if (posicion.esVacia(pieza.getLetra(),
-						(char) (pieza.getNum() - 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() - 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() - 1));
-						if (pieza.getNum() == '7'
-								&& posicion.esVacia(pieza.getLetra(),
-										(char) (pieza.getNum() - 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() - 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() - 2));
-							}
-						}
-					}
-				}
-				if (posicion.getAlPaso() != '\0'
-						&& pieza.getNum() == '4'
-						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
-							.getNum() - 1));
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() - 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() - 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-			break;
-		case CABALLO:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				Casilla destino = pieza.getCasilla().add(v);
-				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Pieza p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (p == null
-								|| (p != null && Pieza.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			break;
-		case DAMA:
-		case ALFIL:
-		case TORRE:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				try {
-					Casilla destino = pieza.getCasilla().add(v);
-					Pieza p = posicion.getPieza(destino.getLetra(), destino
-							.getNumero());
-					while (p == null) {
-						p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-								.getLetra(), destino.getNumero())) {
-							if (p == null
-									|| (p != null && Pieza.esBandoContrario(
-											pieza, p))) {
-								pieza.anadirMov(destino);
-							}
-						}
-						destino = destino.add(v);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			break;
-		case REY:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				Casilla destino = pieza.getCasilla().add(v);
-				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Pieza p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (p == null
-								|| (p != null && Pieza.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			if (posicion.getEnroqueCorto(posicion.getTurno())
-					&& !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&& posicion.esVacia((char) (pieza.getLetra() + 1), pieza
-							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() + 1), (pieza
-							.getNum()))
-					&& posicion.esVacia((char) (pieza.getLetra() + 2), pieza
-							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() + 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
-			}
-			if (posicion.getEnroqueLargo(posicion.getTurno())
-					&& !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&& posicion.esVacia((char) (pieza.getLetra() - 1), pieza
-							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() - 1), (pieza
-							.getNum()))
-					&& posicion.esVacia((char) (pieza.getLetra() - 2), pieza
-							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() - 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
-			}
-			break;
-		}
-	}
-
-	/**
-	 * Metodo de utilidad que se comporta exactamente igual que
-	 * esCasillaAtacada(char, char)
-	 * 
-	 * @param c
-	 *            Casilla que queremos comprobar si esta siendo atacada
-	 * @return Devuelve un booleano indicando si es una casilla atacada o no
-	 */
-	public boolean esCasillaAtacada(Casilla c) {
-		return esCasillaAtacada(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * esCasillaAtacada determina si hay alguna pieza que ataque la casilla que
-	 * se le pasa como parametro. <BR>
-	 * NOTA sobre el codigo: se necesita comprobar el turno para: en el turno en
-	 * el que mueves necesitas saber que casillas estan atacadas por el bando
-	 * contrario, y solo por este bando. No interesan las casillas que ataca el
-	 * bando que mueve. Ademas se puede comprobar que una casillas es atacada
-	 * estando vacia lo cual implica que no hay colores contrarios y es
-	 * necesario conocer el turno para saber quien ataca
-	 * 
-	 * @param letra
-	 *            Letra de la casilla que queremos comprobar si esta siendo
-	 *            atacada
-	 * @param num
-	 *            N?mero de la casilla que queremos comprobart si est? siendo
-	 *            atacada
-	 * @return Devuelve un booleano indicando si es una casilla atacada o no
-	 */
-	public boolean esCasillaAtacada(char letra, char num) {
-		// Primero miro las casillas
-		// a salto de caballo. Despues, las verticales, horizontales y
-		// diagonales.
-
-		// Casillas a salto de caballo
-		ArrayList<VectorDireccion> dir = new ArrayList<VectorDireccion>();
-		dir.add(new VectorDireccion(1, 2));
-		dir.add(new VectorDireccion(-1, 2));
-		dir.add(new VectorDireccion(2, 1));
-		dir.add(new VectorDireccion(2, -1));
-		dir.add(new VectorDireccion(1, -2));
-		dir.add(new VectorDireccion(-1, -2));
-		dir.add(new VectorDireccion(-2, 1));
-		dir.add(new VectorDireccion(-2, -1));
-		for (VectorDireccion v : dir) {
-			try {
-				Pieza p = posicion.getPieza((char) (letra + v.getX()),
-						(char) (num + v.getY()));
-				if (p != null) {
-					if (Pieza.esBandoContrario(posicion.getTurno(), p)
-							&& p.getTipo() == Tipo.CABALLO) {
-						return true;
-					}
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, 0));
-		dir.add(new VectorDireccion(-1, 0));
-		dir.add(new VectorDireccion(0, 1));
-		dir.add(new VectorDireccion(0, -1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && p.getTipo() == Tipo.REY))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, 1));
-		dir.add(new VectorDireccion(-1, 1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Bando.NEGRO))))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, -1));
-		dir.add(new VectorDireccion(-1, -1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Bando.BLANCO))))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-
-		return false;
-	}
-
-	/**
-	 * Determina si un movimiento es legal, analizando la situacion en la
-	 * partida.
-	 * 
-	 * @param letOrig
-	 *            Letra de la casilla de origen.
-	 * @param numOrig
-	 *            Numero de la casilla de origen.
-	 * @param letDest
-	 *            Letra de la casilla de destino.
-	 * @param numDest
-	 *            Numero de la casilla de destino.
-	 * @return True si el movimiento es legal, false en caso contrario.
-	 */
-	private boolean esLegal(char letOrig, char numOrig, char letDest,
-			char numDest) {
-		boolean resultado;
-		Pieza movida = posicion.getPieza(letOrig, numOrig);
-		Pieza temp = posicion.getPieza(letDest, numDest);
-		posicion.borrarPiezaInternal(letOrig, numOrig);
-		posicion.setPiezaInternal(movida, letDest, numDest);
-		resultado = esCasillaAtacada(posicion.getKingPosition(posicion
-				.getTurno()));
-		posicion.borrarPiezaInternal(letDest, numDest);
-		posicion.setPiezaInternal(movida, letOrig, numOrig);
-		if (temp != null)
-			posicion.setPiezaInternal(temp, letDest, numDest);
-		return !resultado;
-	}
-
-	/**
-	 * Este metodo mueve una pieza en el tablero, comprobando que este
-	 * movimiento sea permitido.
-	 * 
-	 * @param origenLetra
-	 *            Es la letra de la casilla de origen
-	 * @param origenNum
-	 *            Es el numero de la casilla de origen
-	 * @param destinoLetra
-	 *            Es la letra de la casilla de destino
-	 * @param destinoNum
-	 *            Es el numero de la casilla de destino
-	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
-	 */
-	public Movimiento mover(char origenLetra, char origenNum,
-			char destinoLetra, char destinoNum) {
-		Pieza piezaQueMueve;
-		int i;
-		Movimiento mov;
-		piezaQueMueve = posicion.getPieza(origenLetra, origenNum);
-
-		// Comprobamos que en la casilla de origen hay una pieza
-		if (piezaQueMueve == null) {
-			return null;
-		}
-
-		if (Pieza.esBandoContrario(posicion.getTurno(), piezaQueMueve)) {
-			return null;
-		}
-		if (indice != movimientos.getNumHalfPly())
-			return null;
-		// Buscamos la casilla de destino entre las casillas validas de la
-		// pieza.
-		i = 0;
-		do {
-			// Buscamos la letra.
-			while ((i < piezaQueMueve.getCasillasValidas().size())
-					&& (destinoLetra != piezaQueMueve.getCasillasValidas().get(
-							i).getLetra())) {
-				i++;
-				// Comprobamos si el numero de la letra encontrada coincide.
-			}
-			if (i < piezaQueMueve.getCasillasValidas().size()) {
-				// Si se entra en el siguiente caso, es que el movimiento es
-				// valido
-				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
-						.getLetra()) {
-					mov = new Movimiento();
-					mov.setCasillaOrigen(new Casilla(origenLetra, origenNum));
-					mov
-							.setCasillaDestino(new Casilla(destinoLetra,
-									destinoNum));
-					mov.setNumeroMovimiento(posicion.getNumeroMovimiento());
-					mov.setBando(posicion.getTurno());
-					mov.setTipoPieza(piezaQueMueve.getTipo());
-
-					// Si se come ponemos el contador a 0
-					if (!posicion.esVacia(destinoLetra, destinoNum)) {
-						posicion.setContadorTablas(0);
-						hash.borrarTabla();
-						mov.setCasillaComer(new Casilla(destinoLetra,
-								destinoNum));
-						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
-								destinoNum).getTipo());
-						posicion.borrarPieza(mov.getCasillaComer());
-					}
-
-					// Se hacen los calculos especiales si se trata de un peon
-					if (piezaQueMueve.getTipo() == Tipo.PEON) {
-						// Se borra la pieza correspondiente si se come al paso
-						if (Math.abs(destinoLetra - origenLetra) == 1
-								&& posicion.esVacia(destinoLetra, destinoNum)) {
-							mov.setTipoPiezaComida(posicion.getPieza(
-									destinoLetra, origenNum).getTipo());
-							mov.setCasillaComer(new Casilla(destinoLetra,
-									origenNum));
-							posicion.borrarPieza(mov.getCasillaComer());
-						}
-						// Se establece la variable alPaso a su valor
-						// correspondiente
-						if (Math.abs(destinoNum - origenNum) == 2) {
-							posicion.setAlPaso(origenLetra);
-							mov.setAlPaso(posicion.getAlPaso());
-						} else {
-							posicion.setAlPaso('\0');
-						}
-						// Coronacion
-						if (destinoNum == '1' || destinoNum == '8') {
-							// if (mostrarDialogoCoronacion) {
-							// mostrarDialogoCoronacion ();
-							// }
-							piezaQueMueve = new Pieza(piezaQueMueve.getBando(),
-									coronar);
-
-							mov.setCoronacion(coronar);
-						}
-						posicion.setContadorTablas(0);
-						hash.borrarTabla();
-					}
-					// Se hacen los calculos especiales si se trata de un rey
-					if (piezaQueMueve.getTipo() == Tipo.REY) {
-						// Movemos las torres en caso de enroque
-						if ((destinoLetra - origenLetra) == 2) {
-							Pieza torre = posicion.getPieza('h', origenNum);
-							posicion.borrarPieza('h', origenNum);
-							posicion.setPieza(torre, 'f', origenNum);
-						} else {
-							if ((destinoLetra - origenLetra) == -2) {
-								Pieza torre = posicion.getPieza('a', origenNum);
-								posicion.borrarPieza('a', origenNum);
-								posicion.setPieza(torre, 'd', origenNum);
-							}
-						}
-					}
-
-					mov.setContadorTablas(posicion.getContadorTablas());
-					boolean[][] enroque = new boolean[2][2];
-					enroque[0][0] = posicion.getEnroqueCorto(Bando.BLANCO);
-					enroque[0][1] = posicion.getEnroqueLargo(Bando.BLANCO);
-					enroque[1][0] = posicion.getEnroqueCorto(Bando.NEGRO);
-					enroque[1][1] = posicion.getEnroqueLargo(Bando.NEGRO);
-					mov.setEnroque(enroque);
-					if (posicion.getTurno() == Bando.NEGRO)
-						posicion.addNumeroMovimiento();
-					posicion.setTurno();
-
-					posicion.borrarPieza(origenLetra, origenNum);
-					posicion.setPieza(piezaQueMueve, destinoLetra, destinoNum);
-					posicion.addContadorTablas();
-					calcularMovimientos();
-
-					if (esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))) {
-						mov.setJaque(true);
-					} else {
-						mov.setJaque(false);
-					}
-					mov.setFinPartida(esFinPartida());
-
-					hash.insertar(posicion.getClavePosicion());
-					movimientos.appendMovimiento(mov);
-					indice++;
-					return mov;
-				} else {
-					i++;
-				}
-			} else {
-				return null;
-			}
-		} while (true);
-	}
-
-	/**
-	 * Avanza por la lista de movimientos de la partida.
-	 * 
-	 * @return El movimiento al que lleguemos en la lista de movimientos.
-	 */
-	public Movimiento avanzar() {
-		Movimiento mov;
-		Pieza piezaQueMueve;
-		if (indice < movimientos.getNumHalfPly()) {
-			mov = movimientos.getMovimiento(indice);
-			piezaQueMueve = posicion.getPieza(mov.getCasillaOrigen());
-			// Si se come al paso
-			if (piezaQueMueve.getTipo() == Tipo.PEON
-					&& Math.abs(mov.getCasillaDestino().getLetra()
-							- mov.getCasillaOrigen().getLetra()) == 1
-					&& posicion.esVacia(mov.getCasillaDestino())) {
-				posicion.borrarPieza(mov.getCasillaComer());
-			}
-			// Si se corona
-			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Pieza(piezaQueMueve.getBando(), mov
-						.getCoronacion());
-			}
-			// Se hacen los calculos especiales si se trata de un rey
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
-				// Movemos las torres en caso de enroque
-				Casilla origen = mov.getCasillaOrigen();
-				Casilla destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Pieza torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
-				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
-						Pieza torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
-					}
-				}
-			}
-			posicion.borrarPieza(mov.getCasillaOrigen());
-			posicion.setPieza(piezaQueMueve, mov.getCasillaDestino());
-			posicion.setContadorTablas(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
-			indice++;
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
-			return mov;
-		} else {
-			return null;
-		}
-	}
-
-	/**
-	 * Retrocede por la lista de movimientos de la partida.
-	 * 
-	 * @return El movimiento al que lleguemos en la lista de movimientos.
-	 */
-	public Movimiento retroceder() {
-		Movimiento mov;
-		Pieza piezaQueMueve;
-		if (indice > 0) {
-			indice--;
-			mov = movimientos.getMovimiento(indice);
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
-			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
-			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Pieza(piezaQueMueve.getBando(), mov
-						.getCoronacion());
-			}
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
-				// Movemos las torres en caso de enroque
-				Casilla origen = mov.getCasillaOrigen();
-				Casilla destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Pieza torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
-				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
-						Pieza torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
-					}
-				}
-			}
-			posicion.borrarPieza(mov.getCasillaDestino());
-			if (mov.getTipoPiezaComida() != null) {
-				posicion.setPieza(new Pieza(
-						piezaQueMueve.getBando() == Bando.BLANCO ? Bando.BLANCO
-								: Bando.NEGRO, mov.getTipoPieza()), mov
-						.getCasillaComer());
-			}
-			posicion.setPieza(piezaQueMueve, mov.getCasillaOrigen());
-			posicion.setContadorTablas(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
-			return mov;
-		} else {
-			return null;
-		}
-	}
-
-	/**
-	 * Este metodo comprueba si se produce alguna situacion en la que termine
-	 * una partida.
-	 * 
-	 * @return Devuelve '\0' si la partida no se ha acabado, 'B' si las blancas
-	 *         han dado jaque mate, 'N' si las negras han dado jaque mate o 'T'
-	 *         si se produce una situacion de tablas.
-	 */
-	private Resultado esFinPartida() {
-		Pieza pieza;
-		Resultado devolver = null;
-		boolean fin = false, fin2 = false, posibleMatInsuf = false;
-		char i, j;
-		// Tablas por 50 movimientos
-		if (posicion.getContadorTablas() == 50) {
-			fin = true;
-			devolver = Resultado.TABLAS_50_MOV;
-		}
-		// Tablas por repeticion de posiciones
-		if (hash.getRepeticiones(posicion.getClavePosicion()) == 3) {
-			fin = true;
-			devolver = Resultado.TABLAS_REPETICION;
-		}
-		// Tablas por material insuficiente
-		i = 'a';
-		j = '1';
-		while (i <= 'h' && !fin2) {
-			while (j <= '8' && !fin2) {
-				pieza = posicion.getPieza(i, j);
-				if (pieza != null) {
-					if (posibleMatInsuf) {
-						if (pieza.getTipo() != Tipo.REY) {
-							fin2 = true;
-						}
-					} else {
-						switch (pieza.getTipo()) {
-						case PEON:
-						case DAMA:
-						case TORRE:
-							fin2 = true;
-							break;
-						case ALFIL:
-						case CABALLO:
-							posibleMatInsuf = true;
-							break;
-						case REY:
-							break;
-						}
-					}
-				}
-				j++;
-			}
-			j = '1';
-			i++;
-		}
-		if (!fin2) {
-			fin = true;
-			devolver = Resultado.TABLAS_INSUF_MATERIAL;
-		}
-		// Miramos si hay movimientos posibles
-		i = 'a';
-		j = '1';
-		while (i <= 'h' && !fin) {
-			while (j <= '8' && !fin) {
-				pieza = posicion.getPieza(i, j);
-				if ((pieza != null)
-						&& (!Pieza.esBandoContrario(posicion.getTurno(), pieza))
-						&& (!pieza.getCasillasValidas().isEmpty())) {
-					fin = true;
-				}
-				j++;
-			}
-			j = '1';
-			i++;
-		}
-		if (!fin) {
-			// Negras dan jaque mate
-			if (posicion.getTurno() == Bando.BLANCO)
-				if (esCasillaAtacada(posicion.getKingPosition(Bando.BLANCO))) {
-					devolver = Resultado.JAQUE_MATE_NEGRO;
-				} else {
-					devolver = Resultado.TABLAS_AHOGADO;
-				}
-			else
-			// Blancas dan jaque mate
-			if (esCasillaAtacada(posicion.getKingPosition(Bando.NEGRO))) {
-				devolver = Resultado.JAQUE_MATE_BLANCO;
-			}
-			// Tablas por ahogado
-			else {
-				devolver = Resultado.TABLAS_AHOGADO;
-			}
-		}
-		return devolver;
-	}
-
-	/**
-	 * Interpreta un movimiento en notacion algebraica y lo realiza en la
-	 * Logica. NOTA: Partimos de la base de que el turno corresponde con el
-	 * movimiento que se recibe: no se puede dar el caso de que se reciba un
-	 * movimiento de negras y que el turno pertenezca a blancas o viceversa.
-	 * 
-	 * @param mov
-	 *            String que contiene el movimiento en notacion algebraica.
-	 * @todo Poner las ambig?edades de la dama
-	 * @todo Puede ser que tengamos un problema: cuando una pieza esta clavada
-	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
-	 *       tenerlo en cuenta.
-	 */
-	public Movimiento moverALG(String mov) {
-		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
-		char tipoPieza = 'P';
-		Tipo piezaCoronacion = null;
-		int contadorOesEnroque = 0, i;
-		boolean finDestino = false;
-
-		for (i = mov.length() - 1; i >= 0; i--) {
-			switch (mov.charAt(i)) {
-			case '1':
-			case '2':
-			case '3':
-			case '4':
-			case '5':
-			case '6':
-			case '7':
-			case '8':
-				if (!finDestino) {
-					destinoNum = mov.charAt(i);
-				} else {
-					origenNum = mov.charAt(i);
-				}
-				break;
-			case 'a':
-			case 'b':
-			case 'c':
-			case 'd':
-			case 'e':
-			case 'f':
-			case 'g':
-			case 'h':
-				if (!finDestino) {
-					destinoLetra = mov.charAt(i);
-				} else {
-					origenLetra = mov.charAt(i);
-				}
-				finDestino = true;
-				break;
-			case 'B':
-				if (i != 0) {
-					piezaCoronacion = Tipo.ALFIL;
-				} else {
-					tipoPieza = 'A';
-				}
-				break;
-			case 'K':
-				tipoPieza = 'R';
-				break;
-			case 'N':
-				if (i != 0) {
-					piezaCoronacion = Tipo.CABALLO;
-				} else {
-					tipoPieza = 'C';
-				}
-				break;
-			case 'Q':
-				if (i != 0) {
-					piezaCoronacion = Tipo.DAMA;
-				} else {
-					tipoPieza = 'D';
-				}
-				break;
-			case 'R':
-				if (i != 0) {
-					piezaCoronacion = Tipo.TORRE;
-				} else {
-					tipoPieza = 'T';
-				}
-				break;
-			case '0':
-			case 'o':
-			case 'O':
-				contadorOesEnroque++;
-				break;
-			case 'x':
-			case '+':
-			case '!':
-			case '?':
-			case '-':
-			case '=':
-				break;
-			default:
-				System.out.print("Caracter desconocido: " + mov.charAt(i));
-				break;
-			}
-		}
-		if(piezaCoronacion!=null) {
-			// TODO hacer el mostrarDialogoCoronacion;
-			coronar = piezaCoronacion;
-		}
-		// Enroque Corto
-		if (contadorOesEnroque == 2) {
-			origenLetra = 'e';
-			destinoLetra = 'g';
-			if (posicion.getTurno() == Bando.BLANCO) {
-				origenNum = '1';
-				destinoNum = '1';
-			} else { // turno == NEGRO
-				origenNum = '8';
-				destinoNum = '8';
-			}
-		} else if (contadorOesEnroque == 3) {
-			origenLetra = 'e';
-			destinoLetra = 'c';
-			if (posicion.getTurno() == Bando.BLANCO) {
-				origenNum = '1';
-				destinoNum = '1';
-			} else { // turno == NEGRO
-				origenNum = '8';
-				destinoNum = '8';
-			}
-		} else {
-			Casilla c = new Casilla(destinoLetra, destinoNum);
-			if (origenLetra == '\0' && origenNum != '\0') {
-				for (char ii = 'a'; ii <= 'h'; ii++) {
-					Pieza p = posicion.getPieza(ii, origenNum);
-					if (p.canMove(c)) {
-						origenLetra = ii;
-						break;
-					}
-				}
-			} else if (origenLetra != '\0' && origenNum == '\0') {
-				for (char ii = '1'; ii <= '8'; ii++) {
-					Pieza p = posicion.getPieza(origenLetra, ii);
-					if (p.canMove(c)) {
-						origenNum = ii;
-						break;
-					}
-				}
-			} else {
-				for (char ii = '1'; ii <= '8'; ii++) {
-					for (char jj = 'a'; jj <= 'h'; jj++) {
-						Pieza p = posicion.getPieza(jj, ii);
-						if (p.canMove(c)) {
-							origenNum = ii;
-							break;
-						}
-					}
-				}
-			}
-		}
-		if (origenLetra == '\0' || origenNum == '\0' || destinoLetra == '\0'
-				|| destinoNum == '\0') {
-			System.out.println(tipoPieza + " " + origenLetra + " " + origenNum
-					+ " " + destinoLetra + " " + destinoNum);
-			return null;
-		} else {
-			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
-		}
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/chess/Movement.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Movimiento.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,241 @@
+package com.mihail.chess;
+
+import static com.mihail.chess.Board.Bando;
+
+import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Piece.Tipo;
+
+/**
+ * Esta clase define un objeto Movimiento, que guarda informacion sobre el
+ * movimiento que se realiza y sobre el estado de la partida en ese momento (qu?
+ * enroques son posibles, es jaque, etc).
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Movement {
+
+	/**
+	 * Este atributo indica la letra de la casilla origen.
+	 */
+	// public char origenLetra;
+	/**
+	 * Este atributo indica el numero de la casilla origen.
+	 */
+	// public char origenNum;
+	private Square casillaOrigen;
+
+	/**
+	 * Este atributo indica la letra de la casilla destino.
+	 */
+	// public char destinoLetra;
+	/**
+	 * Este atributo indica el numero de la casilla destino.
+	 */
+	// public char destinoNum;
+	private Square casillaDestino;
+
+	/**
+	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
+	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
+	 * 1 como numero de movimiento.
+	 */
+	private int numeroMovimiento;
+
+	/**
+	 * Bando que mueve.
+	 */
+	private Bando bando;
+
+	/**
+	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
+	 * 
+	 */
+	private Tipo tipoPieza;
+
+	/**
+	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerLetra;
+	/**
+	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerNum;
+	private Square casillaComer;
+
+	/**
+	 * Este atributo indica si el movimiento produce un jaque.
+	 */
+	private boolean jaque;
+
+	/**
+	 * Este atributo indica si el movimiento termina la partida y quien es el
+	 * ganador o bien tablas. <BR>
+	 * 'B' -> Ganan blancas <BR>
+	 * 'N' -> Ganan negras <BR>
+	 * 'T' -> Tablas <BR>
+	 * 0 -> No ha terminado la partida
+	 */
+	private Resultado finPartida;
+
+	/**
+	 * Este atributo indica si se ha producido una coronacion y a que pieza se
+	 * promociona. <BR>
+	 * 'C' -> Caballo <BR>
+	 * 'A' -> Alfil <BR>
+	 * 'T' -> Torre <BR>
+	 * 'D' -> Dama <BR>
+	 * 0 -> No hay coronacion
+	 */
+	private Tipo coronacion;
+
+	/**
+	 * Este atributo indica el valor de contadorTablas en el momento que se
+	 * produce el movimiento.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos en el
+	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
+	 * enroque[0][0] -> Blancas, enroque corto <BR>
+	 * enroque[0][1] -> Blancas, enroque largo <BR>
+	 * enroque[1][0] -> Negras, enroque corto <BR>
+	 * enroque[1][1] -> Negras, enroque largo <BR>
+	 */
+	private boolean[][] enroque;
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+
+	/**
+	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	private Tipo tipoPiezaComida;
+
+	/**
+	 * Este atributo guarda la representacion del movimiento en notacion
+	 * algebraica.
+	 */
+	private String notacion;
+
+	public Square getCasillaDestino() {
+		return casillaDestino;
+	}
+
+	public void setCasillaDestino(Square casillaDestino) {
+		this.casillaDestino = casillaDestino;
+	}
+
+	public Square getCasillaOrigen() {
+		return casillaOrigen;
+	}
+
+	public void setCasillaOrigen(Square casillaOrigen) {
+		this.casillaOrigen = casillaOrigen;
+	}
+
+	public Bando getBando() {
+		return bando;
+	}
+
+	public void setBando(Bando bando) {
+		this.bando = bando;
+	}
+
+	public int getNumeroMovimiento() {
+		return numeroMovimiento;
+	}
+
+	public void setNumeroMovimiento(int numeroMovimiento) {
+		this.numeroMovimiento = numeroMovimiento;
+	}
+
+	public Tipo getTipoPieza() {
+		return tipoPieza;
+	}
+
+	public void setTipoPieza(Tipo tipoPieza) {
+		this.tipoPieza = tipoPieza;
+	}
+
+	public Square getCasillaComer() {
+		return casillaComer;
+	}
+
+	public void setCasillaComer(Square casillaComer) {
+		this.casillaComer = casillaComer;
+	}
+
+	public int getContadorTablas() {
+		return contadorTablas;
+	}
+
+	public void setContadorTablas(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+
+	public Tipo getCoronacion() {
+		return coronacion;
+	}
+
+	public void setCoronacion(Tipo coronacion) {
+		this.coronacion = coronacion;
+	}
+
+	public boolean[][] getEnroque() {
+		return enroque;
+	}
+
+	public void setEnroque(boolean[][] enroque) {
+		this.enroque = enroque;
+	}
+
+	public Resultado getFinPartida() {
+		return finPartida;
+	}
+
+	public void setFinPartida(Resultado finPartida) {
+		this.finPartida = finPartida;
+	}
+
+	public boolean isJaque() {
+		return jaque;
+	}
+
+	public void setJaque(boolean jaque) {
+		this.jaque = jaque;
+	}
+
+	public char getAlPaso() {
+		return alPaso;
+	}
+
+	public void setAlPaso(char alPaso) {
+		this.alPaso = alPaso;
+	}
+
+	public String getNotacion() {
+		return notacion;
+	}
+
+	public void setNotacion(String notacion) {
+		this.notacion = notacion;
+	}
+
+	public Tipo getTipoPiezaComida() {
+		return tipoPiezaComida;
+	}
+
+	public void setTipoPiezaComida(Tipo tipoPiezaComida) {
+		this.tipoPiezaComida = tipoPiezaComida;
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Movimiento.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,241 +0,0 @@
-package com.mihail.chess;
-
-import static com.mihail.chess.Logica.Bando;
-
-import com.mihail.chess.Logica.Resultado;
-import com.mihail.chess.Pieza.Tipo;
-
-/**
- * Esta clase define un objeto Movimiento, que guarda informacion sobre el
- * movimiento que se realiza y sobre el estado de la partida en ese momento (qu?
- * enroques son posibles, es jaque, etc).
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Movimiento {
-
-	/**
-	 * Este atributo indica la letra de la casilla origen.
-	 */
-	// public char origenLetra;
-	/**
-	 * Este atributo indica el numero de la casilla origen.
-	 */
-	// public char origenNum;
-	private Casilla casillaOrigen;
-
-	/**
-	 * Este atributo indica la letra de la casilla destino.
-	 */
-	// public char destinoLetra;
-	/**
-	 * Este atributo indica el numero de la casilla destino.
-	 */
-	// public char destinoNum;
-	private Casilla casillaDestino;
-
-	/**
-	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
-	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
-	 * 1 como numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Bando que mueve.
-	 */
-	private Bando bando;
-
-	/**
-	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
-	 * 
-	 */
-	private Tipo tipoPieza;
-
-	/**
-	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerLetra;
-	/**
-	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerNum;
-	private Casilla casillaComer;
-
-	/**
-	 * Este atributo indica si el movimiento produce un jaque.
-	 */
-	private boolean jaque;
-
-	/**
-	 * Este atributo indica si el movimiento termina la partida y quien es el
-	 * ganador o bien tablas. <BR>
-	 * 'B' -> Ganan blancas <BR>
-	 * 'N' -> Ganan negras <BR>
-	 * 'T' -> Tablas <BR>
-	 * 0 -> No ha terminado la partida
-	 */
-	private Resultado finPartida;
-
-	/**
-	 * Este atributo indica si se ha producido una coronacion y a que pieza se
-	 * promociona. <BR>
-	 * 'C' -> Caballo <BR>
-	 * 'A' -> Alfil <BR>
-	 * 'T' -> Torre <BR>
-	 * 'D' -> Dama <BR>
-	 * 0 -> No hay coronacion
-	 */
-	private Tipo coronacion;
-
-	/**
-	 * Este atributo indica el valor de contadorTablas en el momento que se
-	 * produce el movimiento.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos en el
-	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
-	 * enroque[0][0] -> Blancas, enroque corto <BR>
-	 * enroque[0][1] -> Blancas, enroque largo <BR>
-	 * enroque[1][0] -> Negras, enroque corto <BR>
-	 * enroque[1][1] -> Negras, enroque largo <BR>
-	 */
-	private boolean[][] enroque;
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	private Tipo tipoPiezaComida;
-
-	/**
-	 * Este atributo guarda la representacion del movimiento en notacion
-	 * algebraica.
-	 */
-	private String notacion;
-
-	public Casilla getCasillaDestino() {
-		return casillaDestino;
-	}
-
-	public void setCasillaDestino(Casilla casillaDestino) {
-		this.casillaDestino = casillaDestino;
-	}
-
-	public Casilla getCasillaOrigen() {
-		return casillaOrigen;
-	}
-
-	public void setCasillaOrigen(Casilla casillaOrigen) {
-		this.casillaOrigen = casillaOrigen;
-	}
-
-	public Bando getBando() {
-		return bando;
-	}
-
-	public void setBando(Bando bando) {
-		this.bando = bando;
-	}
-
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public Tipo getTipoPieza() {
-		return tipoPieza;
-	}
-
-	public void setTipoPieza(Tipo tipoPieza) {
-		this.tipoPieza = tipoPieza;
-	}
-
-	public Casilla getCasillaComer() {
-		return casillaComer;
-	}
-
-	public void setCasillaComer(Casilla casillaComer) {
-		this.casillaComer = casillaComer;
-	}
-
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
-	public Tipo getCoronacion() {
-		return coronacion;
-	}
-
-	public void setCoronacion(Tipo coronacion) {
-		this.coronacion = coronacion;
-	}
-
-	public boolean[][] getEnroque() {
-		return enroque;
-	}
-
-	public void setEnroque(boolean[][] enroque) {
-		this.enroque = enroque;
-	}
-
-	public Resultado getFinPartida() {
-		return finPartida;
-	}
-
-	public void setFinPartida(Resultado finPartida) {
-		this.finPartida = finPartida;
-	}
-
-	public boolean isJaque() {
-		return jaque;
-	}
-
-	public void setJaque(boolean jaque) {
-		this.jaque = jaque;
-	}
-
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	public void setAlPaso(char alPaso) {
-		this.alPaso = alPaso;
-	}
-
-	public String getNotacion() {
-		return notacion;
-	}
-
-	public void setNotacion(String notacion) {
-		this.notacion = notacion;
-	}
-
-	public Tipo getTipoPiezaComida() {
-		return tipoPiezaComida;
-	}
-
-	public void setTipoPiezaComida(Tipo tipoPiezaComida) {
-		this.tipoPiezaComida = tipoPiezaComida;
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Piece.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Pieza.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,223 @@
+package com.mihail.chess;
+
+import java.util.*;
+
+import static com.mihail.chess.Board.Bando;
+
+/**
+ * Esta clase define un objeto Pieza y sus caracteristicas: bando, tipo de pieza
+ * (peon, caballo, alfil, torre, dama, rey), posicion en la que se encuentra y
+ * casillas a donde podria mover, ademas de un indicador para saber si la pieza
+ * ha sido comida.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Piece {
+
+	public static enum Tipo {
+		PEON, CABALLO, ALFIL, TORRE, DAMA, REY
+	}
+
+	// Atributos
+
+	/**
+	 * Este atributo indica el bando de la pieza (blanco o negro): true -> bando
+	 * blanco false -> bando negro
+	 */
+	private Bando bando;
+
+	/**
+	 * Este atributo indica el tipo de pieza que es: <BR>
+	 * 'P' -> peon <BR>
+	 * 'C' -> caballo <BR>
+	 * 'A' -> alfil <BR>
+	 * 'T' -> torre <BR>
+	 * 'D' -> dama <BR>
+	 * 'R' -> rey
+	 */
+	private Tipo tipo;
+
+	private Square casilla;
+
+	/**
+	 * Este atributo es un array que almacena todas las casillas a las que puede
+	 * mover la pieza en una determinada situacion de partida, en donde: <BR>
+	 * casillasValidas[0] -> letras de las casillas <BR>
+	 * casillasValidas[1] -> numeros de las casillas <BR>
+	 * Son vectores de tama?o fijo.
+	 * 
+	 * @see java.util.ArrayList
+	 */
+	private ArrayList<Square> casillasValidas;
+
+	private DirectionVector[] direcciones;
+
+	/**
+	 * Inicializa una nueva instancia de esta clase.
+	 * 
+	 * @param ban
+	 *            True para Blancas, false para Negras
+	 * @param claseDePieza
+	 *            Es el tipo de la pieza {P,C,A,T,D,R}
+	 * @see #tipo
+	 */
+	public Piece(Bando ban, Tipo claseDePieza) {
+		bando = ban;
+		tipo = claseDePieza;
+		casilla = new Square();
+		switch (tipo) {
+		case PEON:
+			direcciones = new DirectionVector[1];
+			if (bando == Bando.BLANCO)
+				direcciones[0] = new DirectionVector(0, 1);
+			else
+				direcciones[0] = new DirectionVector(0, -1);
+			casillasValidas = new ArrayList<Square>(4);
+			break;
+		case TORRE:
+			direcciones = new DirectionVector[4];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			casillasValidas = new ArrayList<Square>(13);
+			break;
+		case ALFIL:
+			direcciones = new DirectionVector[4];
+			direcciones[0] = new DirectionVector(1, 1);
+			direcciones[1] = new DirectionVector(-1, 1);
+			direcciones[2] = new DirectionVector(1, -1);
+			direcciones[3] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList<Square>(13);
+			break;
+		case CABALLO:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 2);
+			direcciones[1] = new DirectionVector(-1, 2);
+			direcciones[2] = new DirectionVector(2, 1);
+			direcciones[3] = new DirectionVector(2, -1);
+
+			direcciones[4] = new DirectionVector(1, -2);
+			direcciones[5] = new DirectionVector(-1, -2);
+			direcciones[6] = new DirectionVector(-2, 1);
+			direcciones[7] = new DirectionVector(-2, -1);
+			casillasValidas = new ArrayList<Square>(8);
+			break;
+		case REY:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			direcciones[4] = new DirectionVector(1, 1);
+			direcciones[5] = new DirectionVector(-1, 1);
+			direcciones[6] = new DirectionVector(1, -1);
+			direcciones[7] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList<Square>(8);
+			break;
+		case DAMA:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			direcciones[4] = new DirectionVector(1, 1);
+			direcciones[5] = new DirectionVector(-1, 1);
+			direcciones[6] = new DirectionVector(1, -1);
+			direcciones[7] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList<Square>(27);
+			break;
+		}
+	}
+
+	/**
+	 * Permite saber si dos piezas son de bandos contrarios.
+	 * 
+	 * @param pieza1
+	 *            Pieza para saber si es de bando contrario a pieza2.
+	 * @param pieza2
+	 *            La otra pieza.
+	 * @return Devuelve true cuando pieza1 y pieza2 sean de bandos contrarios,
+	 *         false cuando sean del mismo bando.
+	 */
+	public final static boolean esBandoContrario(Piece pieza1, Piece pieza2) {
+		return pieza1.bando != pieza2.bando;
+	}
+
+	/**
+	 * Permite saber si una pieza pertenece al bando contrario al que tiene el
+	 * turno.
+	 * 
+	 * @param turno
+	 *            Indica de que bando es el turno.
+	 * @param pieza
+	 *            La pieza en cuestion.
+	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
+	 *         mover, false si es del mismo bando
+	 */
+	public final static boolean esBandoContrario(Bando turno, Piece pieza) {
+		return turno != pieza.bando;
+	}
+
+	/**
+	 * Inserta una casilla en la lista de casillas validas de un objeto Pieza.
+	 * 
+	 * @param let
+	 *            Es la casilla de destino que queremos a?adir
+	 * @param n
+	 *            Es el numero de destino que queremos a?adir
+	 */
+	public void anadirMov(char let, char n) {
+		this.casillasValidas.add(new Square(let, n));
+	}
+
+	public void anadirMov(Square c) {
+		this.casillasValidas.add(c);
+	}
+
+	public Bando getBando() {
+		return bando;
+	}
+
+	public ArrayList<Square> getCasillasValidas() {
+		return casillasValidas;
+	}
+
+	public DirectionVector[] getDirecciones() {
+		return direcciones;
+	}
+
+	public Tipo getTipo() {
+		return tipo;
+	}
+
+	public char getLetra() {
+		return casilla.getLetra();
+	}
+
+	public void setLetra(char let) {
+		casilla.setLetra(let);
+	}
+
+	public char getNum() {
+		return casilla.getNumero();
+	}
+
+	public void setNum(char num) {
+		casilla.setNumero(num);
+	}
+
+	public Square getCasilla() {
+		return casilla;
+	}
+
+	public void setCasilla(Square casilla) {
+		this.casilla = casilla;
+	}
+	
+	public boolean canMove(Square casilla) {
+		return casillasValidas.contains(casilla);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Pieza.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,223 +0,0 @@
-package com.mihail.chess;
-
-import java.util.*;
-
-import static com.mihail.chess.Logica.Bando;
-
-/**
- * Esta clase define un objeto Pieza y sus caracteristicas: bando, tipo de pieza
- * (peon, caballo, alfil, torre, dama, rey), posicion en la que se encuentra y
- * casillas a donde podria mover, ademas de un indicador para saber si la pieza
- * ha sido comida.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Pieza {
-
-	public static enum Tipo {
-		PEON, CABALLO, ALFIL, TORRE, DAMA, REY
-	}
-
-	// Atributos
-
-	/**
-	 * Este atributo indica el bando de la pieza (blanco o negro): true -> bando
-	 * blanco false -> bando negro
-	 */
-	private Bando bando;
-
-	/**
-	 * Este atributo indica el tipo de pieza que es: <BR>
-	 * 'P' -> peon <BR>
-	 * 'C' -> caballo <BR>
-	 * 'A' -> alfil <BR>
-	 * 'T' -> torre <BR>
-	 * 'D' -> dama <BR>
-	 * 'R' -> rey
-	 */
-	private Tipo tipo;
-
-	private Casilla casilla;
-
-	/**
-	 * Este atributo es un array que almacena todas las casillas a las que puede
-	 * mover la pieza en una determinada situacion de partida, en donde: <BR>
-	 * casillasValidas[0] -> letras de las casillas <BR>
-	 * casillasValidas[1] -> numeros de las casillas <BR>
-	 * Son vectores de tama?o fijo.
-	 * 
-	 * @see java.util.ArrayList
-	 */
-	private ArrayList<Casilla> casillasValidas;
-
-	private VectorDireccion[] direcciones;
-
-	/**
-	 * Inicializa una nueva instancia de esta clase.
-	 * 
-	 * @param ban
-	 *            True para Blancas, false para Negras
-	 * @param claseDePieza
-	 *            Es el tipo de la pieza {P,C,A,T,D,R}
-	 * @see #tipo
-	 */
-	public Pieza(Bando ban, Tipo claseDePieza) {
-		bando = ban;
-		tipo = claseDePieza;
-		casilla = new Casilla();
-		switch (tipo) {
-		case PEON:
-			direcciones = new VectorDireccion[1];
-			if (bando == Bando.BLANCO)
-				direcciones[0] = new VectorDireccion(0, 1);
-			else
-				direcciones[0] = new VectorDireccion(0, -1);
-			casillasValidas = new ArrayList<Casilla>(4);
-			break;
-		case TORRE:
-			direcciones = new VectorDireccion[4];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			casillasValidas = new ArrayList<Casilla>(13);
-			break;
-		case ALFIL:
-			direcciones = new VectorDireccion[4];
-			direcciones[0] = new VectorDireccion(1, 1);
-			direcciones[1] = new VectorDireccion(-1, 1);
-			direcciones[2] = new VectorDireccion(1, -1);
-			direcciones[3] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList<Casilla>(13);
-			break;
-		case CABALLO:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 2);
-			direcciones[1] = new VectorDireccion(-1, 2);
-			direcciones[2] = new VectorDireccion(2, 1);
-			direcciones[3] = new VectorDireccion(2, -1);
-
-			direcciones[4] = new VectorDireccion(1, -2);
-			direcciones[5] = new VectorDireccion(-1, -2);
-			direcciones[6] = new VectorDireccion(-2, 1);
-			direcciones[7] = new VectorDireccion(-2, -1);
-			casillasValidas = new ArrayList<Casilla>(8);
-			break;
-		case REY:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			direcciones[4] = new VectorDireccion(1, 1);
-			direcciones[5] = new VectorDireccion(-1, 1);
-			direcciones[6] = new VectorDireccion(1, -1);
-			direcciones[7] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList<Casilla>(8);
-			break;
-		case DAMA:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			direcciones[4] = new VectorDireccion(1, 1);
-			direcciones[5] = new VectorDireccion(-1, 1);
-			direcciones[6] = new VectorDireccion(1, -1);
-			direcciones[7] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList<Casilla>(27);
-			break;
-		}
-	}
-
-	/**
-	 * Permite saber si dos piezas son de bandos contrarios.
-	 * 
-	 * @param pieza1
-	 *            Pieza para saber si es de bando contrario a pieza2.
-	 * @param pieza2
-	 *            La otra pieza.
-	 * @return Devuelve true cuando pieza1 y pieza2 sean de bandos contrarios,
-	 *         false cuando sean del mismo bando.
-	 */
-	public final static boolean esBandoContrario(Pieza pieza1, Pieza pieza2) {
-		return pieza1.bando != pieza2.bando;
-	}
-
-	/**
-	 * Permite saber si una pieza pertenece al bando contrario al que tiene el
-	 * turno.
-	 * 
-	 * @param turno
-	 *            Indica de que bando es el turno.
-	 * @param pieza
-	 *            La pieza en cuestion.
-	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
-	 *         mover, false si es del mismo bando
-	 */
-	public final static boolean esBandoContrario(Bando turno, Pieza pieza) {
-		return turno != pieza.bando;
-	}
-
-	/**
-	 * Inserta una casilla en la lista de casillas validas de un objeto Pieza.
-	 * 
-	 * @param let
-	 *            Es la casilla de destino que queremos a?adir
-	 * @param n
-	 *            Es el numero de destino que queremos a?adir
-	 */
-	public void anadirMov(char let, char n) {
-		this.casillasValidas.add(new Casilla(let, n));
-	}
-
-	public void anadirMov(Casilla c) {
-		this.casillasValidas.add(c);
-	}
-
-	public Bando getBando() {
-		return bando;
-	}
-
-	public ArrayList<Casilla> getCasillasValidas() {
-		return casillasValidas;
-	}
-
-	public VectorDireccion[] getDirecciones() {
-		return direcciones;
-	}
-
-	public Tipo getTipo() {
-		return tipo;
-	}
-
-	public char getLetra() {
-		return casilla.getLetra();
-	}
-
-	public void setLetra(char let) {
-		casilla.setLetra(let);
-	}
-
-	public char getNum() {
-		return casilla.getNumero();
-	}
-
-	public void setNum(char num) {
-		casilla.setNumero(num);
-	}
-
-	public Casilla getCasilla() {
-		return casilla;
-	}
-
-	public void setCasilla(Casilla casilla) {
-		this.casilla = casilla;
-	}
-	
-	public boolean canMove(Casilla casilla) {
-		return casillasValidas.contains(casilla);
-	}
-}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Posicion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,874 +0,0 @@
-package com.mihail.chess;
-
-import static com.mihail.chess.Logica.Bando;
-import static com.mihail.chess.Pieza.Tipo;
-
-import com.mihail.chess.Logica.Resultado;
-import com.mihail.chess.Pieza.Tipo;
-
-public class Posicion {
-
-	/**
-	 * Constante que representa al bando blanco.
-	 */
-	// public final static int BLANCO = 0;
-	/**
-	 * Constante que representa al bando negro.
-	 */
-	// public final static int NEGRO = 1;
-	/**
-	 * Constante que representa la cadena FEN con la posici?n inicial en el
-	 * tablero.
-	 */
-	public final static String CAD_INICIAL = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
-
-	/**
-	 * Este atributo es la representacion del tablero en la logica del programa.
-	 * Es una matriz cuadrada de 64 casillas. El concepto de casilla no se
-	 * representa con un objeto: directamente se almacena un objeto Pieza o null
-	 * si la casilla esta vacia.
-	 */
-	private Pieza[][] tabla = new Pieza[8][8];
-
-	/**
-	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
-	 * blancas y NEGRO cuando mueven negras.
-	 */
-	private Bando turno;
-
-	/**
-	 * Este atributo indica el numero de movimiento por el que va la partida.
-	 * Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el 1 como
-	 * numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos. Es
-	 * un array 2x2, en donde: <BR>
-	 * enroque[0][0] -> Blancas, enroque corto <BR>
-	 * enroque[0][1] -> Blancas, enroque largo <BR>
-	 * enroque[1][0] -> Negras, enroque corto <BR>
-	 * enroque[1][1] -> Negras, enroque largo
-	 */
-	private boolean[][] enroque = new boolean[2][2];
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo sirve para contar movimientos a la hora de declarar las
-	 * tablas por la regla de los 50 movimientos.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Vamos almacenando la clave resultante para calcular la siguiente posicion
-	 * a partir de ella.
-	 */
-	private int clavePosicion;
-
-	/**
-	 * Tabla usada para guardar los indices para generar claves en la tabla
-	 * hash.
-	 */
-	private int[][][][] indices = new int[2][6][8][8];
-
-	/**
-	 * Este atributo contiene el numero de las casillas en las que se encuentran
-	 * los reyes. <BR>
-	 * letraPosRey[BLANCO] -> Rey Blanco <BR>
-	 * letraPosRey[NEGRO] -> Rey Negro <BR>
-	 */
-
-	private Casilla[] kingPosition = new Casilla[2];
-
-	public Posicion() {
-		for (int i = 0; i < 2; i++) {
-			for (int j = 0; j < 6; j++) {
-				for (int k = 0; k < 8; k++) {
-					for (int l = 0; l < 8; l++) {
-						indices[i][j][k][l] = i
-								* (new Double(Math.pow(10, 7))).intValue() + j
-								* (new Double(Math.pow(10, 6))).intValue() + k
-								* (new Double(Math.pow(10, 5))).intValue() + l
-								* (new Double(Math.pow(10, 4))).intValue() + i
-								* (new Double(Math.pow(10, 3))).intValue() + j
-								* (new Double(Math.pow(10, 2))).intValue() + k
-								* 10 + l;
-					}
-				}
-			}
-		}
-		turno = Bando.BLANCO;
-		kingPosition[0] = new Casilla();
-		kingPosition[1] = new Casilla();
-		enroque[0][0] = false;
-		enroque[0][1] = false;
-		enroque[1][0] = false;
-		enroque[1][1] = false;
-		alPaso = 0;
-		clavePosicion = 0;
-		contadorTablas = 0;
-		numeroMovimiento = 1;
-	}
-
-	public Posicion(String posicion) {
-		this();
-		setPosicion(posicion);
-	}
-
-	/**
-	 * Convierte el tipo de pieza expresado en castellano (P, C, A, etc.) al
-	 * ingles.
-	 * 
-	 * @param t
-	 *            Caracter que indica el tipo de pieza en castellano.
-	 * @return Tipo de pieza en ingles, es decir: <BR>
-	 *         P -> P <BR>
-	 *         C -> N <BR>
-	 *         A -> B <BR>
-	 *         T -> R <BR>
-	 *         D -> Q <BR>
-	 *         R -> K <BR>
-	 *         Otro caso -> \0
-	 */
-	private final static char tipoToEnglish(Tipo t) {
-		switch (t) {
-		case ALFIL:
-			return 'B';
-		case CABALLO:
-			return 'N';
-		case DAMA:
-			return 'Q';
-		case PEON:
-			return 'P';
-		case REY:
-			return 'K';
-		case TORRE:
-			return 'R';
-		default:
-			return '\0';
-		}
-	}
-
-	/**
-	 * Convierte el booleano que indica el bando de una pieza a un entero.
-	 * 
-	 * @param c
-	 *            Es el booleano en cuestion.
-	 * @return 0 si el turno es blanco y 1 si el turno es negro
-	 */
-	private final static int bandoToInt(Bando c) {
-		if (c == Bando.BLANCO) {
-			return 0;
-		}
-		return 1;
-	}
-
-	/**
-	 * Convierte el tipo de pieza expresado con un caracter (P, C, A, etc.) a un
-	 * entero.
-	 * 
-	 * @param c
-	 *            Caracter que indica el tipo de pieza.
-	 * @return El entero que corresponde al tipo de pieza, es decir: <BR>
-	 *         P -> 0 <BR>
-	 *         C -> 1 <BR>
-	 *         A -> 2 <BR>
-	 *         T -> 3 <BR>
-	 *         D -> 4 <BR>
-	 *         R -> 5 <BR>
-	 *         Otro caso -> -1
-	 */
-	private final static int tipoToInt(Tipo c) {
-		switch (c) {
-		case PEON:
-			return 0;
-		case CABALLO:
-			return 1;
-		case ALFIL:
-			return 2;
-		case TORRE:
-			return 3;
-		case DAMA:
-			return 4;
-		case REY:
-			return 5;
-		default:
-			return -1;
-		}
-	}
-
-	/**
-	 * Construye una cadena FEN a partir de la posicion que hay en el tablero.
-	 * 
-	 * @return Un string, la cadena FEN.
-	 */
-	public String getFEN() {
-		String cad = "";
-		int cont = 0;
-		for (int i = 7; i >= 0; i--) {
-			for (int j = 0; j < 8; j++) {
-				Pieza p = getPieza((char) ('a' + j), (char) ('1' + i));
-				if (p == null)
-					cont++;
-				else {
-					if (cont > 0)
-						cad += cont;
-					if (p.getBando() == Bando.BLANCO)
-						cad += tipoToEnglish(p.getTipo());
-					else
-						cad += (Character
-								.toLowerCase(tipoToEnglish(p.getTipo())));
-					cont = 0;
-				}
-			}
-			if (cont > 0)
-				cad += cont;
-			if (i > 0)
-				cad += '/';
-			cont = 0;
-		}
-
-		if (turno == Bando.BLANCO)
-			cad += " w";
-		else
-			cad += " b";
-
-		cad += " ";
-		if (!enroque[0][0] && !enroque[0][1] && !enroque[1][0]
-				&& !enroque[1][1])
-			cad += "-";
-		else {
-			if (enroque[0][0])
-				cad += "K";
-			if (enroque[0][1])
-				cad += "Q";
-			if (enroque[1][0])
-				cad += "k";
-			if (enroque[1][1])
-				cad += "q";
-		}
-		if (alPaso != '\0')
-			cad += (" " + alPaso);
-		else
-			cad += (" -");
-		cad += (" " + contadorTablas);
-		cad += (" " + numeroMovimiento);
-		return cad;
-	}
-
-	/**
-	 * Coloca las piezas en el tablero en la posicion que indica posInicial.
-	 * 
-	 * @param pos
-	 *            Es un String que indica una posicion de juego, siguiendo el
-	 *            estandar FEN.
-	 * @see getFEN()
-	 */
-	public void setPosicion(String pos) {
-		char let = 'a';
-		char num = '8';
-		for (int i = 0; i < 8; i++) {
-			for (int j = 0; j < 8; j++) {
-				tabla[i][j] = null;
-			}
-		}
-		/*
-		 * hash.borrarTabla (); movimientos.clear (); indice = 0;
-		 */
-		clavePosicion = 0;
-		String[] FEN = pos.split(" ");
-		for (int i = 0; i < FEN[0].length(); i++) {
-			switch (FEN[0].charAt(i)) {
-			case 'P':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), let, num);
-				let++;
-				break;
-			case 'p':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.PEON), let, num);
-				let++;
-				break;
-			case 'N':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), let, num);
-				let++;
-				break;
-			case 'n':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.CABALLO), let, num);
-				let++;
-				break;
-			case 'B':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.ALFIL), let, num);
-				let++;
-				break;
-			case 'b':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.ALFIL), let, num);
-				let++;
-				break;
-			case 'R':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), let, num);
-				let++;
-				break;
-			case 'r':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), let, num);
-				let++;
-				break;
-			case 'Q':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.DAMA), let, num);
-				let++;
-				break;
-			case 'q':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.DAMA), let, num);
-				let++;
-				break;
-			case 'K':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.REY), let, num);
-				let++;
-				break;
-			case 'k':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.REY), let, num);
-				let++;
-				break;
-			case '/':
-				let = 'a';
-				num--;
-				break;
-			case '1':
-			case '2':
-			case '3':
-			case '4':
-			case '5':
-			case '6':
-			case '7':
-			case '8':
-				let += (char) (FEN[0].charAt(i) - '0');
-				break;
-			default:
-			}
-		}
-		if (FEN[1].charAt(0) == 'w') {
-			setTurno(Bando.BLANCO);
-		} else {
-			setTurno(Bando.NEGRO);
-		}
-		for (int i = 0; i <= 1; i++) {
-			for (int j = 0; j <= 1; j++) {
-				enroque[i][j] = false;
-			}
-		}
-		if (FEN[2].charAt(0) != '-') {
-			for (int i = 0; i < FEN[2].length(); i++) {
-				switch (FEN[2].charAt(i)) {
-				case 'K':
-					setEnroqueCorto(Bando.BLANCO, true);
-					break;
-				case 'Q':
-					setEnroqueLargo(Bando.BLANCO, true);
-					break;
-				case 'k':
-					setEnroqueCorto(Bando.NEGRO, true);
-					break;
-				case 'q':
-					setEnroqueLargo(Bando.NEGRO, true);
-					break;
-				}
-			}
-
-		}
-		if (FEN[3].charAt(0) == '-') {
-			setAlPaso('\0');
-		} else {
-			setAlPaso(FEN[3].charAt(0));
-		}
-		setContadorTablas((new Integer(FEN[4])).intValue());
-		setNumeroMovimiento((new Integer(FEN[5])).intValue());
-	}
-
-	/**
-	 * Permite saber el numero de movimiento actual.
-	 * 
-	 * @return Un entero, el numero en cuestion.
-	 */
-
-	public int getNumMovimiento() {
-		return numeroMovimiento;
-	}
-
-	/**
-	 * Permite saber si el enroque corto esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque corto puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getEnroqueCorto(Bando c) {
-		switch (c) {
-		case BLANCO:
-			return enroque[0][0];
-		case NEGRO:
-			return enroque[1][0];
-		}
-		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
-				+ this);
-	}
-
-	/**
-	 * Permite saber si el enroque largo esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque largo puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getEnroqueLargo(Bando c) {
-		switch (c) {
-		case BLANCO:
-			return enroque[0][1];
-		case NEGRO:
-			return enroque[1][1];
-		}
-		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
-				+ this);
-	}
-
-	/**
-	 * Este metodo devuelve la pieza que se encuentra en una determinada
-	 * casilla. Si no hay ninguna pieza, devuelve null.
-	 * 
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 * @return Devuelve la pieza que se encuentra en la casilla (letra, num),
-	 *         null si la casilla esta vacia.
-	 */
-	public Pieza getPieza(char letra, char num) {
-		return tabla[num - '1'][letra - 'a'];
-	}
-	
-	public Pieza getPieza(Casilla c) {
-		return getPieza(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * Este metodo nos permite consultar el valor del turno.
-	 * 
-	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
-	 */
-	public Bando getTurno() {
-		return turno;
-	}
-
-	/**
-	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
-	 * viceversa.
-	 */
-	public void setTurno() {
-		if (turno == Bando.BLANCO) {
-			turno = Bando.NEGRO;
-		} else {
-			turno = Bando.BLANCO;
-		}
-	}
-
-	/**
-	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
-	 * 
-	 * @param t
-	 *            BLANCO -> blancas <BR>
-	 *            NEGRO -> negras
-	 */
-	public void setTurno(Bando t) {
-		turno = t;
-	}
-
-	public boolean setEnroqueCorto(Bando b, boolean c) {
-		if (!c) {
-			int x;
-			switch (b) {
-			case BLANCO:
-				x = 0;
-				break;
-			case NEGRO:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						"El Bando solo puede ser BLANCO o NEGRO: " + this);
-			}
-			enroque[x][0] = c;
-			return true;
-		}
-		if (b == Bando.BLANCO) {
-			Pieza p = getPieza('h', '1');
-			if (p != null
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getNumero() == '1'
-					&& p.getBando() == Bando.BLANCO
-					&& p.getTipo() == Tipo.TORRE) {
-				enroque[0][0] = c;
-				return true;
-			} else
-				return false;
-		} else if (b == Bando.NEGRO) {
-			Pieza p = getPieza('h', '8');
-			if (p != null
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
-				enroque[1][0] = c;
-				return true;
-			} else
-				return false;
-		}
-		return false;
-	}
-
-	public boolean setEnroqueLargo(Bando b, boolean c) {
-		if (!c) {
-			int x;
-			switch (b) {
-			case BLANCO:
-				x = 0;
-				break;
-			case NEGRO:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						"El Bando solo puede ser BLANCO o NEGRO: " + this);
-			}
-			enroque[x][1] = c;
-			return true;
-		}
-		if (b == Bando.BLANCO) {
-			Pieza p = getPieza('a', '1');
-			if (p != null
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
-					&& kingPosition[0].getNumero() == '1'
-					&& p.getBando() == Bando.BLANCO
-					&& p.getTipo() == Tipo.TORRE) {
-				enroque[0][1] = c;
-				return true;
-			} else
-				return false;
-		} else if (b == Bando.NEGRO) {
-			Pieza p = getPieza('a', '8');
-			if (p != null
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
-				enroque[1][1] = c;
-				return true;
-			} else
-				return false;
-		}
-		return false;
-	}
-
-	/**
-	 * @return Devuelve numeroMovimiento.
-	 */
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	/**
-	 * Este metodo pone una pieza en el tablero en la casilla indicada. Ademas,
-	 * cambia los atributos del objeto pieza que se le pasa como argumento,
-	 * actualizando su situacion en el tablero.
-	 * 
-	 * @param pieza
-	 *            Es la pieza que queremos poner en el tablero
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 */
-	public void setPieza(Pieza pieza, char letra, char num) {
-		pieza.setLetra(letra);
-		pieza.setNum(num);
-		tabla[num - '1'][letra - 'a'] = pieza;
-		clavePosicion = clavePosicion
-				^ indices[bandoToInt(pieza.getBando())][tipoToInt(pieza
-						.getTipo())][num - '1'][letra - 'a'];
-
-		if (pieza.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(pieza.getBando())] = pieza.getCasilla();
-		}
-	}
-	
-	public void setPieza(Pieza pieza, Casilla casilla) {
-		setPieza(pieza, casilla.getLetra(), casilla.getNumero());
-	}
-
-	public void borrarPieza(Casilla casilla) {
-		borrarPieza(casilla.getLetra(), casilla.getNumero());
-	}
-
-	/**
-	 * Este metodo borra la pieza que se encuentra en una determinada casilla.
-	 * Si la casilla esta vacia, no produce error y la deja vacia. Ademas,
-	 * modifica el atributo enJuego de la pieza.
-	 * 
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 */
-	public void borrarPieza(char letra, char num) {
-		int iNum = num - '1', iLetra = letra - 'a';
-		Pieza p = tabla[iNum][iLetra];
-		// Se actualiza el estado de los enroques en caso de que se borre un rey
-		// o una torre
-		if (p != null) {
-			if (p.getTipo() == Tipo.REY) {
-				if (p.getBando() == Bando.BLANCO) {
-					enroque[0][0] = false;
-					enroque[0][1] = false;
-					kingPosition[bandoToInt(Bando.BLANCO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.BLANCO)].setNumero('\0');
-				} else {
-					enroque[1][0] = false;
-					enroque[1][1] = false;
-					kingPosition[bandoToInt(Bando.NEGRO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.NEGRO)].setNumero('\0');
-				}
-			} else if (p.getTipo() == Tipo.TORRE) {
-				if (p.getLetra() == 'a' && p.getNum() == '1'
-						&& p.getBando() == Bando.BLANCO)
-					enroque[0][1] = false;
-				else if (p.getLetra() == 'h' && p.getNum() == '1'
-						&& p.getBando() == Bando.BLANCO)
-					enroque[0][0] = false;
-				else if (p.getLetra() == 'a' && p.getNum() == '8'
-						&& p.getBando() == Bando.NEGRO)
-					enroque[1][1] = false;
-				else if (p.getLetra() == 'h' && p.getNum() == '8'
-						&& p.getBando() == Bando.NEGRO)
-					enroque[1][0] = false;
-			} else if (p.getTipo() == Tipo.PEON) {
-				if (letra == alPaso
-						&& (p.getBando() == Bando.BLANCO && num == '4')
-						|| (p.getBando() == Bando.NEGRO && num == '5'))
-					alPaso = 0;
-			}
-			clavePosicion = clavePosicion
-					^ indices[bandoToInt(p.getBando())][tipoToInt(p.getTipo())][iNum][iLetra];
-			tabla[num - '1'][letra - 'a'] = null;
-		}
-	}
-	
-	public boolean esVacia(Casilla c) {
-		return esVacia(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * Consulta si una casilla esta vacia o no.
-	 * 
-	 * @return Devuelve true si la casilla esta vacia (contiene null), false en
-	 *         caso contrario.
-	 */
-	public boolean esVacia(char let, char num) {
-		return (getPieza(let, num) == null);
-	}
-
-	/**
-	 * Permite obtener la clave hash numerica de la posicion actual.
-	 * 
-	 * @return Un entero, la clave en cuestion.
-	 */
-	public int getClavePosicion() {
-		return clavePosicion;
-	}
-
-	/**
-	 * @return Returns the alPaso.
-	 */
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	/**
-	 * Establece la columna en la que un peon puede ser comido al paso. Es
-	 * decir, si un peon avanza dos casillas, entonces esa es la columna alPaso.
-	 * Es condicicion necesaria que en esa columna haya un peon que haya
-	 * avanzado dos casillas.
-	 * 
-	 * @param alPaso
-	 *            La columna en la qeu se puede comer al paso. Se indica con la
-	 *            letra de la columna.
-	 */
-	public void setAlPaso(char alPaso) {
-		if (alPaso == '\0') {
-			this.alPaso = alPaso;
-			return;
-		}
-		boolean encontrado = false;
-		Pieza p;
-		if (this.turno == Bando.NEGRO) {
-			p = getPieza(alPaso, '4');
-			encontrado = p != null && p.getBando() == Bando.BLANCO
-					&& p.getTipo() == Tipo.PEON;
-		} else {
-			p = getPieza(alPaso, '5');
-			encontrado = p != null && p.getBando() == Bando.NEGRO
-					&& p.getTipo() == Tipo.PEON;
-		}
-		if (encontrado)
-			this.alPaso = alPaso;
-	}
-
-	/**
-	 * @return Returns the contadorTablas.
-	 */
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	/**
-	 * @param contadorTablas
-	 *            The contadorTablas to set.
-	 */
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
-	public void addContadorTablas() {
-		this.contadorTablas++;
-	}
-
-	/**
-	 * @param numeroMovimiento
-	 *            The numeroMovimiento to set.
-	 */
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public void addNumeroMovimiento() {
-		this.numeroMovimiento++;
-	}
-
-	/**
-	 * @return Returns the kingPosition.
-	 */
-	public Casilla getKingPosition(Bando color) {
-		return kingPosition[bandoToInt(color)];
-	}
-	
-	/**
-	 * Genera la notaci?n algebraica de un movimiento.
-	 * 
-	 * @param mov
-	 *            Objeto movimiento del que se generara la notacion algebraica.
-	 * @return Una cadena con el movimiento expresado en notacion algebraica,
-	 *         (por ejemplo: Nf3, e6, Bd5...)
-	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
-	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
-	 */
-	private String generarNotacionALG (Movimiento mov) {
-		StringBuffer temp = new StringBuffer ();
-
-		if (mov.getTipoPieza() == Tipo.REY) {
-			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
-				if (mov.getCasillaDestino().getLetra() == 'g') {
-					temp.append ("O-O");
-				}
-				else { // mov.destinoLetra == 'c'
-					temp.append ("O-O-O");
-				}
-				return temp.toString ();
-			}
-		}
-		if (mov.getTipoPieza() != Tipo.PEON) {
-			temp.append (tipoToEnglish (mov.getTipoPieza()));
-		}
-		Pieza pieza = getPieza (mov.getCasillaDestino());
-		switch (mov.getTipoPieza()) {
-			case PEON:
-				if (mov.getCasillaComer() != null)
-					temp.append (mov.getCasillaOrigen().getLetra());
-				break;
-			case CABALLO:
-				for(VectorDireccion v: pieza.getDirecciones()) {
-					try {
-						Pieza p = getPieza(mov.getCasillaDestino().add(v));
-						if(p!=null && p.getTipo() == Tipo.CABALLO && p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
-								break;
-							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
-								break;
-							}
-						}
-					} catch(ArrayIndexOutOfBoundsException e) {}
-				}
-				break;
-
-			case ALFIL:
-			case TORRE:
-			case DAMA:
-				for(VectorDireccion v: pieza.getDirecciones()) {
-					try {
-						Casilla destino = mov.getCasillaDestino().add(v);
-						Pieza p;
-						while((p=getPieza(destino))==null) {
-							destino.add(v);
-						}
-						if(p!=null && p.getTipo() == pieza.getTipo() && p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
-								break;
-							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
-								break;
-							}
-						}
-					} catch(ArrayIndexOutOfBoundsException e) {}
-				}
-				break;
-		}
-
-		if (mov.getCasillaComer() != null)
-			temp.append ("x");
-
-		temp.append (mov.getCasillaDestino().toString());
-
-		if (mov.getCoronacion() != null)
-			temp.append ("=" + tipoToEnglish (mov.getCoronacion()));
-
-		if (mov.isJaque())
-			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
-					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
-				temp.append ("#");
-			else
-				temp.append ("+");
-		return temp.toString ();
-	}
-
-	/**
-	 * Funciones de uso interno. No usar directamente
-	 * 
-	 * @param letra
-	 * @param num
-	 */
-	void borrarPiezaInternal(char letra, char num) {
-		tabla[num - '1'][letra - 'a'] = null;
-	}
-
-	void setPiezaInternal(Pieza p, char letra, char num) {
-		tabla[num - '1'][letra - 'a'] = p;
-		if (p.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(p.getBando())].setLetra(letra);
-			kingPosition[bandoToInt(p.getBando())].setNumero(num);
-		}
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/chess/Position.java (from rev 32, trunk/MihailChessLib/com/mihail/chess/Posicion.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,874 @@
+package com.mihail.chess;
+
+import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Piece.Tipo;
+
+import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Piece.Tipo;
+
+public class Position {
+
+	/**
+	 * Constante que representa al bando blanco.
+	 */
+	// public final static int BLANCO = 0;
+	/**
+	 * Constante que representa al bando negro.
+	 */
+	// public final static int NEGRO = 1;
+	/**
+	 * Constante que representa la cadena FEN con la posici?n inicial en el
+	 * tablero.
+	 */
+	public final static String CAD_INICIAL = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
+
+	/**
+	 * Este atributo es la representacion del tablero en la logica del programa.
+	 * Es una matriz cuadrada de 64 casillas. El concepto de casilla no se
+	 * representa con un objeto: directamente se almacena un objeto Pieza o null
+	 * si la casilla esta vacia.
+	 */
+	private Piece[][] tabla = new Piece[8][8];
+
+	/**
+	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
+	 * blancas y NEGRO cuando mueven negras.
+	 */
+	private Bando turno;
+
+	/**
+	 * Este atributo indica el numero de movimiento por el que va la partida.
+	 * Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el 1 como
+	 * numero de movimiento.
+	 */
+	private int numeroMovimiento;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos. Es
+	 * un array 2x2, en donde: <BR>
+	 * enroque[0][0] -> Blancas, enroque corto <BR>
+	 * enroque[0][1] -> Blancas, enroque largo <BR>
+	 * enroque[1][0] -> Negras, enroque corto <BR>
+	 * enroque[1][1] -> Negras, enroque largo
+	 */
+	private boolean[][] enroque = new boolean[2][2];
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+
+	/**
+	 * Este atributo sirve para contar movimientos a la hora de declarar las
+	 * tablas por la regla de los 50 movimientos.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Vamos almacenando la clave resultante para calcular la siguiente posicion
+	 * a partir de ella.
+	 */
+	private int clavePosicion;
+
+	/**
+	 * Tabla usada para guardar los indices para generar claves en la tabla
+	 * hash.
+	 */
+	private int[][][][] indices = new int[2][6][8][8];
+
+	/**
+	 * Este atributo contiene el numero de las casillas en las que se encuentran
+	 * los reyes. <BR>
+	 * letraPosRey[BLANCO] -> Rey Blanco <BR>
+	 * letraPosRey[NEGRO] -> Rey Negro <BR>
+	 */
+
+	private Square[] kingPosition = new Square[2];
+
+	public Position() {
+		for (int i = 0; i < 2; i++) {
+			for (int j = 0; j < 6; j++) {
+				for (int k = 0; k < 8; k++) {
+					for (int l = 0; l < 8; l++) {
+						indices[i][j][k][l] = i
+								* (new Double(Math.pow(10, 7))).intValue() + j
+								* (new Double(Math.pow(10, 6))).intValue() + k
+								* (new Double(Math.pow(10, 5))).intValue() + l
+								* (new Double(Math.pow(10, 4))).intValue() + i
+								* (new Double(Math.pow(10, 3))).intValue() + j
+								* (new Double(Math.pow(10, 2))).intValue() + k
+								* 10 + l;
+					}
+				}
+			}
+		}
+		turno = Bando.BLANCO;
+		kingPosition[0] = new Square();
+		kingPosition[1] = new Square();
+		enroque[0][0] = false;
+		enroque[0][1] = false;
+		enroque[1][0] = false;
+		enroque[1][1] = false;
+		alPaso = 0;
+		clavePosicion = 0;
+		contadorTablas = 0;
+		numeroMovimiento = 1;
+	}
+
+	public Position(String posicion) {
+		this();
+		setPosicion(posicion);
+	}
+
+	/**
+	 * Convierte el tipo de pieza expresado en castellano (P, C, A, etc.) al
+	 * ingles.
+	 * 
+	 * @param t
+	 *            Caracter que indica el tipo de pieza en castellano.
+	 * @return Tipo de pieza en ingles, es decir: <BR>
+	 *         P -> P <BR>
+	 *         C -> N <BR>
+	 *         A -> B <BR>
+	 *         T -> R <BR>
+	 *         D -> Q <BR>
+	 *         R -> K <BR>
+	 *         Otro caso -> \0
+	 */
+	private final static char tipoToEnglish(Tipo t) {
+		switch (t) {
+		case ALFIL:
+			return 'B';
+		case CABALLO:
+			return 'N';
+		case DAMA:
+			return 'Q';
+		case PEON:
+			return 'P';
+		case REY:
+			return 'K';
+		case TORRE:
+			return 'R';
+		default:
+			return '\0';
+		}
+	}
+
+	/**
+	 * Convierte el booleano que indica el bando de una pieza a un entero.
+	 * 
+	 * @param c
+	 *            Es el booleano en cuestion.
+	 * @return 0 si el turno es blanco y 1 si el turno es negro
+	 */
+	private final static int bandoToInt(Bando c) {
+		if (c == Bando.BLANCO) {
+			return 0;
+		}
+		return 1;
+	}
+
+	/**
+	 * Convierte el tipo de pieza expresado con un caracter (P, C, A, etc.) a un
+	 * entero.
+	 * 
+	 * @param c
+	 *            Caracter que indica el tipo de pieza.
+	 * @return El entero que corresponde al tipo de pieza, es decir: <BR>
+	 *         P -> 0 <BR>
+	 *         C -> 1 <BR>
+	 *         A -> 2 <BR>
+	 *         T -> 3 <BR>
+	 *         D -> 4 <BR>
+	 *         R -> 5 <BR>
+	 *         Otro caso -> -1
+	 */
+	private final static int tipoToInt(Tipo c) {
+		switch (c) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		default:
+			return -1;
+		}
+	}
+
+	/**
+	 * Construye una cadena FEN a partir de la posicion que hay en el tablero.
+	 * 
+	 * @return Un string, la cadena FEN.
+	 */
+	public String getFEN() {
+		String cad = "";
+		int cont = 0;
+		for (int i = 7; i >= 0; i--) {
+			for (int j = 0; j < 8; j++) {
+				Piece p = getPieza((char) ('a' + j), (char) ('1' + i));
+				if (p == null)
+					cont++;
+				else {
+					if (cont > 0)
+						cad += cont;
+					if (p.getBando() == Bando.BLANCO)
+						cad += tipoToEnglish(p.getTipo());
+					else
+						cad += (Character
+								.toLowerCase(tipoToEnglish(p.getTipo())));
+					cont = 0;
+				}
+			}
+			if (cont > 0)
+				cad += cont;
+			if (i > 0)
+				cad += '/';
+			cont = 0;
+		}
+
+		if (turno == Bando.BLANCO)
+			cad += " w";
+		else
+			cad += " b";
+
+		cad += " ";
+		if (!enroque[0][0] && !enroque[0][1] && !enroque[1][0]
+				&& !enroque[1][1])
+			cad += "-";
+		else {
+			if (enroque[0][0])
+				cad += "K";
+			if (enroque[0][1])
+				cad += "Q";
+			if (enroque[1][0])
+				cad += "k";
+			if (enroque[1][1])
+				cad += "q";
+		}
+		if (alPaso != '\0')
+			cad += (" " + alPaso);
+		else
+			cad += (" -");
+		cad += (" " + contadorTablas);
+		cad += (" " + numeroMovimiento);
+		return cad;
+	}
+
+	/**
+	 * Coloca las piezas en el tablero en la posicion que indica posInicial.
+	 * 
+	 * @param pos
+	 *            Es un String que indica una posicion de juego, siguiendo el
+	 *            estandar FEN.
+	 * @see getFEN()
+	 */
+	public void setPosicion(String pos) {
+		char let = 'a';
+		char num = '8';
+		for (int i = 0; i < 8; i++) {
+			for (int j = 0; j < 8; j++) {
+				tabla[i][j] = null;
+			}
+		}
+		/*
+		 * hash.borrarTabla (); movimientos.clear (); indice = 0;
+		 */
+		clavePosicion = 0;
+		String[] FEN = pos.split(" ");
+		for (int i = 0; i < FEN[0].length(); i++) {
+			switch (FEN[0].charAt(i)) {
+			case 'P':
+				setPieza(new Piece(Bando.BLANCO, Tipo.PEON), let, num);
+				let++;
+				break;
+			case 'p':
+				setPieza(new Piece(Bando.NEGRO, Tipo.PEON), let, num);
+				let++;
+				break;
+			case 'N':
+				setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), let, num);
+				let++;
+				break;
+			case 'n':
+				setPieza(new Piece(Bando.NEGRO, Tipo.CABALLO), let, num);
+				let++;
+				break;
+			case 'B':
+				setPieza(new Piece(Bando.BLANCO, Tipo.ALFIL), let, num);
+				let++;
+				break;
+			case 'b':
+				setPieza(new Piece(Bando.NEGRO, Tipo.ALFIL), let, num);
+				let++;
+				break;
+			case 'R':
+				setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), let, num);
+				let++;
+				break;
+			case 'r':
+				setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), let, num);
+				let++;
+				break;
+			case 'Q':
+				setPieza(new Piece(Bando.BLANCO, Tipo.DAMA), let, num);
+				let++;
+				break;
+			case 'q':
+				setPieza(new Piece(Bando.NEGRO, Tipo.DAMA), let, num);
+				let++;
+				break;
+			case 'K':
+				setPieza(new Piece(Bando.BLANCO, Tipo.REY), let, num);
+				let++;
+				break;
+			case 'k':
+				setPieza(new Piece(Bando.NEGRO, Tipo.REY), let, num);
+				let++;
+				break;
+			case '/':
+				let = 'a';
+				num--;
+				break;
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+				let += (char) (FEN[0].charAt(i) - '0');
+				break;
+			default:
+			}
+		}
+		if (FEN[1].charAt(0) == 'w') {
+			setTurno(Bando.BLANCO);
+		} else {
+			setTurno(Bando.NEGRO);
+		}
+		for (int i = 0; i <= 1; i++) {
+			for (int j = 0; j <= 1; j++) {
+				enroque[i][j] = false;
+			}
+		}
+		if (FEN[2].charAt(0) != '-') {
+			for (int i = 0; i < FEN[2].length(); i++) {
+				switch (FEN[2].charAt(i)) {
+				case 'K':
+					setEnroqueCorto(Bando.BLANCO, true);
+					break;
+				case 'Q':
+					setEnroqueLargo(Bando.BLANCO, true);
+					break;
+				case 'k':
+					setEnroqueCorto(Bando.NEGRO, true);
+					break;
+				case 'q':
+					setEnroqueLargo(Bando.NEGRO, true);
+					break;
+				}
+			}
+
+		}
+		if (FEN[3].charAt(0) == '-') {
+			setAlPaso('\0');
+		} else {
+			setAlPaso(FEN[3].charAt(0));
+		}
+		setContadorTablas((new Integer(FEN[4])).intValue());
+		setNumeroMovimiento((new Integer(FEN[5])).intValue());
+	}
+
+	/**
+	 * Permite saber el numero de movimiento actual.
+	 * 
+	 * @return Un entero, el numero en cuestion.
+	 */
+
+	public int getNumMovimiento() {
+		return numeroMovimiento;
+	}
+
+	/**
+	 * Permite saber si el enroque corto esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque corto puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getEnroqueCorto(Bando c) {
+		switch (c) {
+		case BLANCO:
+			return enroque[0][0];
+		case NEGRO:
+			return enroque[1][0];
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+
+	/**
+	 * Permite saber si el enroque largo esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque largo puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getEnroqueLargo(Bando c) {
+		switch (c) {
+		case BLANCO:
+			return enroque[0][1];
+		case NEGRO:
+			return enroque[1][1];
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+
+	/**
+	 * Este metodo devuelve la pieza que se encuentra en una determinada
+	 * casilla. Si no hay ninguna pieza, devuelve null.
+	 * 
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 * @return Devuelve la pieza que se encuentra en la casilla (letra, num),
+	 *         null si la casilla esta vacia.
+	 */
+	public Piece getPieza(char letra, char num) {
+		return tabla[num - '1'][letra - 'a'];
+	}
+	
+	public Piece getPieza(Square c) {
+		return getPieza(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * Este metodo nos permite consultar el valor del turno.
+	 * 
+	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
+	 */
+	public Bando getTurno() {
+		return turno;
+	}
+
+	/**
+	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
+	 * viceversa.
+	 */
+	public void setTurno() {
+		if (turno == Bando.BLANCO) {
+			turno = Bando.NEGRO;
+		} else {
+			turno = Bando.BLANCO;
+		}
+	}
+
+	/**
+	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
+	 * 
+	 * @param t
+	 *            BLANCO -> blancas <BR>
+	 *            NEGRO -> negras
+	 */
+	public void setTurno(Bando t) {
+		turno = t;
+	}
+
+	public boolean setEnroqueCorto(Bando b, boolean c) {
+		if (!c) {
+			int x;
+			switch (b) {
+			case BLANCO:
+				x = 0;
+				break;
+			case NEGRO:
+				x = 1;
+				break;
+			default:
+				throw new AssertionError(
+						"El Bando solo puede ser BLANCO o NEGRO: " + this);
+			}
+			enroque[x][0] = c;
+			return true;
+		}
+		if (b == Bando.BLANCO) {
+			Piece p = getPieza('h', '1');
+			if (p != null
+					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Bando.BLANCO)].getNumero() == '1'
+					&& p.getBando() == Bando.BLANCO
+					&& p.getTipo() == Tipo.TORRE) {
+				enroque[0][0] = c;
+				return true;
+			} else
+				return false;
+		} else if (b == Bando.NEGRO) {
+			Piece p = getPieza('h', '8');
+			if (p != null
+					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
+					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
+				enroque[1][0] = c;
+				return true;
+			} else
+				return false;
+		}
+		return false;
+	}
+
+	public boolean setEnroqueLargo(Bando b, boolean c) {
+		if (!c) {
+			int x;
+			switch (b) {
+			case BLANCO:
+				x = 0;
+				break;
+			case NEGRO:
+				x = 1;
+				break;
+			default:
+				throw new AssertionError(
+						"El Bando solo puede ser BLANCO o NEGRO: " + this);
+			}
+			enroque[x][1] = c;
+			return true;
+		}
+		if (b == Bando.BLANCO) {
+			Piece p = getPieza('a', '1');
+			if (p != null
+					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
+					&& kingPosition[0].getNumero() == '1'
+					&& p.getBando() == Bando.BLANCO
+					&& p.getTipo() == Tipo.TORRE) {
+				enroque[0][1] = c;
+				return true;
+			} else
+				return false;
+		} else if (b == Bando.NEGRO) {
+			Piece p = getPieza('a', '8');
+			if (p != null
+					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
+					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
+				enroque[1][1] = c;
+				return true;
+			} else
+				return false;
+		}
+		return false;
+	}
+
+	/**
+	 * @return Devuelve numeroMovimiento.
+	 */
+	public int getNumeroMovimiento() {
+		return numeroMovimiento;
+	}
+
+	/**
+	 * Este metodo pone una pieza en el tablero en la casilla indicada. Ademas,
+	 * cambia los atributos del objeto pieza que se le pasa como argumento,
+	 * actualizando su situacion en el tablero.
+	 * 
+	 * @param pieza
+	 *            Es la pieza que queremos poner en el tablero
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 */
+	public void setPieza(Piece pieza, char letra, char num) {
+		pieza.setLetra(letra);
+		pieza.setNum(num);
+		tabla[num - '1'][letra - 'a'] = pieza;
+		clavePosicion = clavePosicion
+				^ indices[bandoToInt(pieza.getBando())][tipoToInt(pieza
+						.getTipo())][num - '1'][letra - 'a'];
+
+		if (pieza.getTipo() == Tipo.REY) {
+			kingPosition[bandoToInt(pieza.getBando())] = pieza.getCasilla();
+		}
+	}
+	
+	public void setPieza(Piece pieza, Square casilla) {
+		setPieza(pieza, casilla.getLetra(), casilla.getNumero());
+	}
+
+	public void borrarPieza(Square casilla) {
+		borrarPieza(casilla.getLetra(), casilla.getNumero());
+	}
+
+	/**
+	 * Este metodo borra la pieza que se encuentra en una determinada casilla.
+	 * Si la casilla esta vacia, no produce error y la deja vacia. Ademas,
+	 * modifica el atributo enJuego de la pieza.
+	 * 
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 */
+	public void borrarPieza(char letra, char num) {
+		int iNum = num - '1', iLetra = letra - 'a';
+		Piece p = tabla[iNum][iLetra];
+		// Se actualiza el estado de los enroques en caso de que se borre un rey
+		// o una torre
+		if (p != null) {
+			if (p.getTipo() == Tipo.REY) {
+				if (p.getBando() == Bando.BLANCO) {
+					enroque[0][0] = false;
+					enroque[0][1] = false;
+					kingPosition[bandoToInt(Bando.BLANCO)].setLetra('\0');
+					kingPosition[bandoToInt(Bando.BLANCO)].setNumero('\0');
+				} else {
+					enroque[1][0] = false;
+					enroque[1][1] = false;
+					kingPosition[bandoToInt(Bando.NEGRO)].setLetra('\0');
+					kingPosition[bandoToInt(Bando.NEGRO)].setNumero('\0');
+				}
+			} else if (p.getTipo() == Tipo.TORRE) {
+				if (p.getLetra() == 'a' && p.getNum() == '1'
+						&& p.getBando() == Bando.BLANCO)
+					enroque[0][1] = false;
+				else if (p.getLetra() == 'h' && p.getNum() == '1'
+						&& p.getBando() == Bando.BLANCO)
+					enroque[0][0] = false;
+				else if (p.getLetra() == 'a' && p.getNum() == '8'
+						&& p.getBando() == Bando.NEGRO)
+					enroque[1][1] = false;
+				else if (p.getLetra() == 'h' && p.getNum() == '8'
+						&& p.getBando() == Bando.NEGRO)
+					enroque[1][0] = false;
+			} else if (p.getTipo() == Tipo.PEON) {
+				if (letra == alPaso
+						&& (p.getBando() == Bando.BLANCO && num == '4')
+						|| (p.getBando() == Bando.NEGRO && num == '5'))
+					alPaso = 0;
+			}
+			clavePosicion = clavePosicion
+					^ indices[bandoToInt(p.getBando())][tipoToInt(p.getTipo())][iNum][iLetra];
+			tabla[num - '1'][letra - 'a'] = null;
+		}
+	}
+	
+	public boolean esVacia(Square c) {
+		return esVacia(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * Consulta si una casilla esta vacia o no.
+	 * 
+	 * @return Devuelve true si la casilla esta vacia (contiene null), false en
+	 *         caso contrario.
+	 */
+	public boolean esVacia(char let, char num) {
+		return (getPieza(let, num) == null);
+	}
+
+	/**
+	 * Permite obtener la clave hash numerica de la posicion actual.
+	 * 
+	 * @return Un entero, la clave en cuestion.
+	 */
+	public int getClavePosicion() {
+		return clavePosicion;
+	}
+
+	/**
+	 * @return Returns the alPaso.
+	 */
+	public char getAlPaso() {
+		return alPaso;
+	}
+
+	/**
+	 * Establece la columna en la que un peon puede ser comido al paso. Es
+	 * decir, si un peon avanza dos casillas, entonces esa es la columna alPaso.
+	 * Es condicicion necesaria que en esa columna haya un peon que haya
+	 * avanzado dos casillas.
+	 * 
+	 * @param alPaso
+	 *            La columna en la qeu se puede comer al paso. Se indica con la
+	 *            letra de la columna.
+	 */
+	public void setAlPaso(char alPaso) {
+		if (alPaso == '\0') {
+			this.alPaso = alPaso;
+			return;
+		}
+		boolean encontrado = false;
+		Piece p;
+		if (this.turno == Bando.NEGRO) {
+			p = getPieza(alPaso, '4');
+			encontrado = p != null && p.getBando() == Bando.BLANCO
+					&& p.getTipo() == Tipo.PEON;
+		} else {
+			p = getPieza(alPaso, '5');
+			encontrado = p != null && p.getBando() == Bando.NEGRO
+					&& p.getTipo() == Tipo.PEON;
+		}
+		if (encontrado)
+			this.alPaso = alPaso;
+	}
+
+	/**
+	 * @return Returns the contadorTablas.
+	 */
+	public int getContadorTablas() {
+		return contadorTablas;
+	}
+
+	/**
+	 * @param contadorTablas
+	 *            The contadorTablas to set.
+	 */
+	public void setContadorTablas(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+
+	public void addContadorTablas() {
+		this.contadorTablas++;
+	}
+
+	/**
+	 * @param numeroMovimiento
+	 *            The numeroMovimiento to set.
+	 */
+	public void setNumeroMovimiento(int numeroMovimiento) {
+		this.numeroMovimiento = numeroMovimiento;
+	}
+
+	public void addNumeroMovimiento() {
+		this.numeroMovimiento++;
+	}
+
+	/**
+	 * @return Returns the kingPosition.
+	 */
+	public Square getKingPosition(Bando color) {
+		return kingPosition[bandoToInt(color)];
+	}
+	
+	/**
+	 * Genera la notaci?n algebraica de un movimiento.
+	 * 
+	 * @param mov
+	 *            Objeto movimiento del que se generara la notacion algebraica.
+	 * @return Una cadena con el movimiento expresado en notacion algebraica,
+	 *         (por ejemplo: Nf3, e6, Bd5...)
+	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
+	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
+	 */
+	private String generarNotacionALG (Movement mov) {
+		StringBuffer temp = new StringBuffer ();
+
+		if (mov.getTipoPieza() == Tipo.REY) {
+			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
+				if (mov.getCasillaDestino().getLetra() == 'g') {
+					temp.append ("O-O");
+				}
+				else { // mov.destinoLetra == 'c'
+					temp.append ("O-O-O");
+				}
+				return temp.toString ();
+			}
+		}
+		if (mov.getTipoPieza() != Tipo.PEON) {
+			temp.append (tipoToEnglish (mov.getTipoPieza()));
+		}
+		Piece pieza = getPieza (mov.getCasillaDestino());
+		switch (mov.getTipoPieza()) {
+			case PEON:
+				if (mov.getCasillaComer() != null)
+					temp.append (mov.getCasillaOrigen().getLetra());
+				break;
+			case CABALLO:
+				for(DirectionVector v: pieza.getDirecciones()) {
+					try {
+						Piece p = getPieza(mov.getCasillaDestino().add(v));
+						if(p!=null && p.getTipo() == Tipo.CABALLO && p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+
+			case ALFIL:
+			case TORRE:
+			case DAMA:
+				for(DirectionVector v: pieza.getDirecciones()) {
+					try {
+						Square destino = mov.getCasillaDestino().add(v);
+						Piece p;
+						while((p=getPieza(destino))==null) {
+							destino.add(v);
+						}
+						if(p!=null && p.getTipo() == pieza.getTipo() && p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+		}
+
+		if (mov.getCasillaComer() != null)
+			temp.append ("x");
+
+		temp.append (mov.getCasillaDestino().toString());
+
+		if (mov.getCoronacion() != null)
+			temp.append ("=" + tipoToEnglish (mov.getCoronacion()));
+
+		if (mov.isJaque())
+			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
+					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
+				temp.append ("#");
+			else
+				temp.append ("+");
+		return temp.toString ();
+	}
+
+	/**
+	 * Funciones de uso interno. No usar directamente
+	 * 
+	 * @param letra
+	 * @param num
+	 */
+	void borrarPiezaInternal(char letra, char num) {
+		tabla[num - '1'][letra - 'a'] = null;
+	}
+
+	void setPiezaInternal(Piece p, char letra, char num) {
+		tabla[num - '1'][letra - 'a'] = p;
+		if (p.getTipo() == Tipo.REY) {
+			kingPosition[bandoToInt(p.getBando())].setLetra(letra);
+			kingPosition[bandoToInt(p.getBando())].setNumero(num);
+		}
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,125 @@
+package com.mihail.chess;
+
+import java.util.ArrayList;
+
+/**
+ * Esta clase define un objeto TablaHash, que representa a la tabla hash que se
+ * usa para almacenar las claves que identifican las posiciones a lo largo de la
+ * partida de ajedrez. Asocia a cada clave de posici?n el n?mero de
+ * repeticiones.
+ * 
+ * @author Pedro Su?rez Casal
+ * @author Iago Porto D?az
+ */
+public final class PositionsDictionary {
+	private ArrayList[] tabla;
+
+	private int tam;
+
+	/**
+	 * Crea una nueva tabla hash del tama?o indicado. Normalmente se creara una
+	 * tabla con un tama?o proximo a 40-50, para situarse en el peor caso de
+	 * repeticiones, y aumentar el rendimiento de la tabla.
+	 */
+	public PositionsDictionary(int t) {
+		tabla = new ArrayList[t];
+		for (int i = 0; i < tabla.length; i++)
+			tabla[i] = new ArrayList();
+		tam = t;
+	}
+
+	/**
+	 * Inserta una clave de posicion dentro de la tabla. Cuando inserta una de
+	 * las claves tambien comprueba si esa posicion esta guardada. Si lo esta,
+	 * vuelve a guardar la clave con el numero de repeticiones aumentado, si no,
+	 * a?ade un nuevo elemento con las repeticiones a 1.
+	 * 
+	 * @param clave
+	 *            Clave que queremos insertar dentro de la tabla
+	 */
+	public void insertar(int clave) {
+		int pos = clave % tam;
+		int i = 0;
+
+		while (i < tabla[pos].size()
+				&& ((Item) tabla[pos].get(i)).getClave() != clave)
+			i++;
+
+		if (i < tabla[pos].size()) {
+			if (((Item) tabla[pos].get(i)).getClave() == clave)
+				((Item) tabla[pos].get(i)).aumentarRep();
+		} else
+			tabla[pos].add(new Item(clave));
+	}
+
+	/**
+	 * Borra todos los elementos de la tabla.
+	 */
+	public void borrarTabla() {
+		for (int i = 0; i < tabla.length; i++)
+			tabla[i].clear();
+	}
+
+	/**
+	 * Obtiene el numero de repeticiones de una posicion dada.
+	 * 
+	 * @param clave
+	 *            La clave asociada con una posicion.
+	 * @return El numero de repeticiones de la clave recibida.
+	 */
+	public int getRepeticiones(int clave) {
+		int pos = clave % tam;
+		int i = 0;
+
+		while (i < tabla[pos].size()
+				&& ((Item) (tabla[pos].get(i))).getClave() != clave)
+			i++;
+
+		if (i < tabla[pos].size())
+			return ((Item) tabla[pos].get(i)).getRepeticiones();
+		return -1;
+	}
+
+	public String toString() {
+		String cad = "[";
+		for (int i = 0; i < tabla.length; i++) {
+			cad += "[";
+			for (int j = 0; j < tabla[i].size(); j++) {
+				cad += tabla[i].get(j);
+			}
+			cad += "]";
+		}
+
+		cad += "]";
+		return cad;
+	}
+	
+	private final class Item {
+		private int clave;
+
+		private int repeticiones = 1;
+
+		public Item(int num) {
+			clave = num;
+		}
+
+		public int getClave() {
+			return clave;
+		}
+
+		public int getRepeticiones() {
+			return repeticiones;
+		}
+
+		public void aumentarRep() {
+			repeticiones++;
+		}
+
+		public String toString() {
+			String cad = "(" + clave + ", " + repeticiones + ")";
+
+			return cad;
+		}
+
+	}
+}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Square.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Casilla.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Square.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,111 @@
+/*
+ * Created on 25-jul-2005
+ *
+ * MihailChess - Casilla.java
+ * 
+ * Autores:  Iago Porto Diaz
+ * 			 Pedro Suarez Casal
+ * 
+ */
+package com.mihail.chess;
+
+/**
+ * Representa una casilla en un tablero de ajedrez. Simplemente almacena informacion sobre
+ * la letra y el numero.
+ * @author wotan
+ *
+ */
+
+public class Square {
+
+	private char letra;
+
+	private char numero;
+
+	/**
+	 * Crea una casilla con la letra y numero iguales a cero.
+	 *
+	 */
+	
+	public Square() {
+		this.letra = 0;
+		this.numero = 0;
+	}
+	
+	/**
+	 * Crea una casilla con la letra y numero indicados.
+	 * 
+	 * @param letra Letra de la casilla
+	 * @param numero Numera de la casilla
+	 */
+
+	public Square(char letra, char numero) {
+		this.letra = letra;
+		this.numero = numero;
+	}
+
+	public boolean equals(Object o) {
+		if (o instanceof Square) {
+			Square c = (Square) o;
+			return c.letra == letra && c.numero == numero;
+		}
+		return false;
+	}
+	
+	/**
+	 * Suma a la casilla actual un vector de direccion, dando como resultado otra casilla.
+	 * A la letra se le suma la direccion x y al numero la direccion y.
+	 * 
+	 * @param v El vector que queremos sumar a la casilla actual.
+	 * @return Otra casilla resultado de sumar a la casilla actual el vector recibido.
+	 */
+
+	public Square add(DirectionVector v) {
+		return new Square((char) (this.letra + v.getX()),
+				(char) (this.numero + v.getY()));
+	}
+	
+	/**
+	 * Obtiene la letra de la casilla.
+	 * 
+	 * @return La letra de la casilla
+	 */
+
+	public char getLetra() {
+		return letra;
+	}
+	
+	/**
+	 * Establece la letra de la casilla.
+	 * 
+	 * @param letra La letra de la casilla
+	 */
+
+	public void setLetra(char letra) {
+		this.letra = letra;
+	}
+	
+	/**
+	 * Obtiene el numero de la casilla.
+	 * 
+	 * @return El numero de la casilla
+	 */
+
+	public char getNumero() {
+		return numero;
+	}
+	
+	/**
+	 * Establece el numero de la casilla.
+	 * 
+	 * @param numero El numero de la casilla
+	 */
+
+	public void setNumero(char numero) {
+		this.numero = numero;
+	}
+
+	public String toString() {
+		return letra + "" + numero;
+	}
+}

Deleted: trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,569 +0,0 @@
-package com.mihail.chess;
-
-import java.awt.BasicStroke;
-import java.awt.Color;
-import java.awt.Dimension;
-import java.awt.Font;
-import java.awt.GradientPaint;
-import java.awt.Graphics;
-import java.awt.Graphics2D;
-import java.awt.Image;
-import java.awt.MediaTracker;
-import java.awt.Point;
-import java.awt.geom.Rectangle2D;
-
-import javax.swing.ImageIcon;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-
-import com.mihail.chess.Logica.Bando;
-import com.mihail.chess.Pieza.Tipo;
-
-/**
- * Esta clase se encarga de proporcionar una vista b?sica de la l?gica, usada
- * como modelo. No proporciona ningun metodo de manejo de eventos, y enmascara
- * las funciones de la l?gica interna.
- * 
- * @author Pedro Su?rez Casal
- * @author Iago Porto D?az
- */
-public class Tablero2D extends JPanel {
-
-	private static final long serialVersionUID = 1L;
-
-	/*
-	 * Tama?o del borde del tablero.
-	 */
-	private int BORDE = 30;
-
-	/*
-	 * Tama?o de la casilla.
-	 */
-	private int TAM;
-
-	/*
-	 * Tama?o anterior, para comparar si es necesario redimensionar.
-	 * 
-	 * @TODO ?Es necesario este atributo? Queda chapucero.
-	 */
-	private int TAMant;
-
-	/*
-	 * Coordenada 'x' de la casilla pulsada por ultima vez [0, 8]. Sirve para
-	 * indicar al metodo de dibujo que la casilla indicada no se debe dibujar si
-	 * se esta arrastrando la pieza.
-	 */
-	protected int posX;
-
-	/*
-	 * Coordenada 'y' de la casilla pulsada por ultima vez [0, 8].
-	 */
-	protected int posY;
-
-	// Espacios que hay que dejar alrededor del tablero cuando se redimensiona
-	private int bordeSUP = 0;
-
-	private int bordeLAT = 0;
-
-	// Logica interna del tablero
-
-	protected Posicion tablero;
-
-	// Versiones ajustadas al tama?o correcto de las imagenes
-	private Image[][] piezas = new Image[2][6];
-
-	// Indica el sentido en el que se esta dibujando el tablero
-	private boolean sentido = true;
-
-	// Matriz en la que se van marcando las casillas seleccionada
-	// 'S' -> Casilla seleccionada (amarillo transparente)
-	// 'C' -> Indica que se comio (cuadro rojo)
-	private char seleccion[][] = new char[8][8];
-
-	// Indica si se esta arrastrando una pieza
-	private boolean arrastrando = false;
-
-	/*
-	 * Posicion de la pieza que se esta arrastrando. Se usa en el metodo de
-	 * dibujo para dibujar la pieza piezaArrastrada en el lugar correcto. TODO
-	 * Remodelar para a?adir objetos arbitrarios al tablero, entre ellos piezas
-	 * que estan siendo arrastradas.
-	 */
-	private int posPiezaX, posPiezaY;
-
-	/*
-	 * Imagen de la pieza qu esta siendo arrastrada.
-	 */
-	private Image piezaArrastrada;
-
-	/*
-	 * Colores que se dibujan las casillas en caso de que el tema no lo
-	 * establezca.
-	 */
-	private Color[] colorLiso = new Color[2];
-
-	/*
-	 * Tema que esta usando el tablero para dibujarse.
-	 */
-
-	private BoardTheme theme;
-
-	public Tablero2D(BoardTheme theme) {
-		this(theme, 60);
-	}
-
-	public Tablero2D(BoardTheme theme, int tam) {
-		super();
-		tablero = new Posicion();
-
-		TAM = tam;
-
-		// this.setAutoscrolls(true);
-		this.theme = theme;
-
-		redimensionar();
-	}
-
-	/**
-	 * Se encarga de cambiar el sentido del tablero.
-	 */
-
-	public void rotarTablero() {
-		sentido = !sentido;
-		repaint();
-	}
-
-	public Dimension getPreferredSize() {
-		return (new Dimension(8 * TAM + BORDE * 2, 8 * TAM + BORDE * 2));
-	}
-
-	public void paintComponent(Graphics g) {
-		Pieza temp;
-		// Actualizamos el tama?o de la casilla en caso de que redimensionen el
-		// tablero
-		int TAMtotal = Math.min(getWidth(), getHeight());
-		Graphics2D g2d = (Graphics2D) g;
-		TAMant = TAM;
-		TAM = (TAMtotal - BORDE * 2) / 8;
-		if (TAMant != TAM) {
-			redimensionar();
-		}
-
-		// Hints de renderizado
-		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
-		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
-
-		if(theme.getBackground()==null) {
-			g.setColor(Color.LIGHT_GRAY);
-			g.fillRect(0, 0, getWidth(), getHeight());
-		} else {
-			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
-		}
-
-		if (getWidth() < getHeight()) {
-			bordeSUP = (getHeight() - getWidth()) / 2;
-			bordeLAT = 0;
-		} else {
-			bordeLAT = (getWidth() - getHeight()) / 2;
-			bordeSUP = 0;
-		}
-		g.setClip(bordeLAT, bordeSUP, TAMtotal, TAMtotal);
-		g.translate(bordeLAT, bordeSUP);
-
-		// Borde tablero
-		dibujarBorde(g);
-		// Bucle para dibujar el tablero
-
-		g.setClip(BORDE, BORDE, getWidth() - BORDE, getHeight() - BORDE);
-		g.translate(BORDE, BORDE);
-		for (int j = 0; j < 8; j++) {
-			for (int i = 0; i < 8; i++) {
-				// En funcion de nuestra posicion escogemos el color para
-				// casillas blancas o negras
-				// if (activado) {
-				int v = (i + j) % 2;
-				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
-						: Bando.NEGRO);
-				if (textura != null)
-
-					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
-
-				else {
-					g.setColor(colorLiso[v]);
-					g.fillRect(i * TAM, j * TAM, TAM, TAM);
-				}
-
-				// Dibujamos la casilla
-				//
-				// En caso de que la casilla que tratamos este seleccionada, la
-				// marcamos de color verde
-				int ii = i, jj = j;
-				if (!sentido) {
-					ii = 7 - i;
-					jj = 7 - j;
-				}
-
-				// En funcion del caracter de seleccion dibujamos una cosa u
-				// otra
-				switch (seleccion[ii][jj]) {
-				case 'S':
-					g.setColor(new Color(255, 255, 0, 50));
-					g.fill3DRect(i * TAM, j * TAM, TAM, TAM, true);
-					break;
-				case 'M':
-					g2d.setStroke(new BasicStroke(2.0F, BasicStroke.CAP_BUTT,
-							BasicStroke.JOIN_ROUND));
-					g.setColor(new Color(220, 0, 0));
-					g2d.draw(new Rectangle2D.Float(i * TAM, j * TAM, TAM - 1,
-							TAM - 1));
-
-					// g.drawRect(i * TAM, j * TAM, TAM-1, TAM-1);
-					break;
-				default:
-				}
-
-				// Comprobamos si existe pieza en esa casilla, y en ese caso la
-				// dibujamos
-				char letra, numero;
-				// Se comprueba el sentido en el que dibujamos
-				if (sentido) {
-					numero = (char) ((7 - j) + '1');
-					letra = (char) (i + 'a');
-				} else {
-					numero = (char) (j + '1');
-					letra = (char) ((7 - i) + 'a');
-				}
-
-				if ((temp = tablero.getPieza(letra, numero)) != null) {
-					if (arrastrando
-							&& ((sentido && i == posX && j == posY) || (!sentido
-									&& i == 7 - posX && j == 7 - posY))) {
-						continue;
-					}
-
-					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
-					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
-				}
-			}
-
-		}
-
-		// Este es el caso de que haya que dibujar la pieza a arrastrar. Se
-		// dibuja por encima de todo el resto del tablero
-		if (piezaArrastrada != null) {
-			g.translate(-bordeLAT, -bordeSUP);
-			g.translate(-BORDE, -BORDE);
-			g.setClip(posPiezaX - TAM / 2, posPiezaY - TAM / 2, TAM, TAM);
-			if (arrastrando) {
-				g.drawImage(piezaArrastrada, posPiezaX - TAM / 2, posPiezaY
-						- TAM / 2, null);
-			}
-		}
-
-	}
-
-	/**
-	 * @return Devuelve el tama?o del borde del tablero.
-	 */
-
-	public int getBorde() {
-		return BORDE;
-	}
-
-	/**
-	 * @return Devuelve el tama?o de las casilla.
-	 */
-
-	public int getTamanhoCasilla() {
-		return TAM;
-	}
-
-	/**
-	 * @param tam
-	 *            Establece el tama?o de las casilla.
-	 */
-
-	public void setTamanhoCasilla(int tam) {
-		TAM = tam;
-	}
-
-	/**
-	 * Establece que una pieza se esta arrastrando para que la dibuje en la
-	 * posicion correspondiente.
-	 * 
-	 * @param arrastrando
-	 *            El valor al que queremos establecer si se esta arrastrando o
-	 *            no.
-	 */
-	public void setArrastrando(boolean arrastrando) {
-		this.arrastrando = arrastrando;
-	}
-
-	/**
-	 * @param piezaArrastrada
-	 *            Establece al imagen a arrastrar.
-	 */
-	public void setPiezaArrastrada(Image piezaArrastrada) {
-		this.piezaArrastrada = piezaArrastrada;
-	}
-
-	/**
-	 * @return Devuelve si la casilla indicada por (i, j) tiene algun tipo de
-	 *         seleccion.
-	 */
-
-	public char getSeleccion(int i, int j) {
-		return seleccion[i][j];
-	}
-
-	/**
-	 * Establece la seleccion de una casilla.
-	 * 
-	 * @param s
-	 *            Seleccion a la que establecemos la casilla.
-	 */
-	public void setSeleccion(char s, int i, int j) {
-		this.seleccion[i][j] = s;
-	}
-
-	public Point getPosPiezaArrastrada() {
-		return new Point(posPiezaX, posPiezaY);
-	}
-
-	/**
-	 * @param posPiezaX
-	 *            The posPiezaX to set.
-	 */
-	public void setPosPiezaArrastrada(int posPiezaX, int posPiezaY) {
-		this.posPiezaX = posPiezaX;
-		this.posPiezaY = posPiezaY;
-	}
-
-	/**
-	 * @return Devuelve el borde lateral, el espacio que puede sobrar a los
-	 *         lados del tablero.
-	 */
-	public int getBordeLateral() {
-		return bordeLAT;
-	}
-
-	/**
-	 * @return Devuelve el borde superior, el espacio que puede sobrar arriba y
-	 *         abajo del tablero.
-	 */
-	public int getBordeSuperior() {
-		return bordeSUP;
-	}
-
-	/**
-	 * Indica el sentido en el que se esta dibujando el tablero
-	 * 
-	 * @return Devuelve true si las blancas estan abajo y false si las negras
-	 *         estan abajo.
-	 */
-
-	public boolean isSentido() {
-		return sentido;
-	}
-
-	/**
-	 * Establece el sentido del tablero.
-	 * 
-	 * @param sentido
-	 *            The sentido to set.
-	 */
-	public void setSentido(boolean sentido) {
-		this.sentido = sentido;
-	}
-
-	/**
-	 * Obtiene el color liso de las casillas de un color.
-	 * 
-	 * @param b
-	 *            El tipo de las casillas, blancas o negras.
-	 * @return El color liso.
-	 */
-	public Color getColorLiso(Bando b) {
-		return colorLiso[bandoToInt(b)];
-	}
-
-	/**
-	 * Establece el color liso de las casillas de un color. Este color solo se
-	 * mostrara en caso de que el tema no establezca una textura para las
-	 * casillas.
-	 * 
-	 * @param b
-	 *            El tipo de las casillas, blancas o negras.
-	 * @param colorLiso
-	 *            El color liso.
-	 */
-
-	public void setColorLiso(Bando b, Color colorLiso) {
-		this.colorLiso[bandoToInt(b)] = colorLiso;
-	}
-
-	/**
-	 * Establece el tema que usa el tablero para dibujarse.
-	 * 
-	 * @param theme
-	 *            Tema a establecer.
-	 */
-
-	public void setTema(BoardTheme theme) {
-		this.theme = theme;
-	}
-	
-	public void setPieza(Pieza pieza, Casilla casilla) {
-		tablero.setPieza(pieza, casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
-	}
-	
-	public void borrarPieza(Casilla casilla) {
-		tablero.borrarPieza(casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
-	}
-	
-	public void setFEN(String pos) {
-		tablero.setPosicion(pos);
-		repaint();
-	}
-
-	/*
-	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
-	 * el centro de la casilla. TODO Modificar para que funcione con la esquina
-	 * superior izquierda?
-	 */
-
-	protected void repintarCasilla(int x, int y) {
-		repaint(x - TAM / 2, y - TAM / 2, TAM, TAM);
-	}
-
-	/**
-	 * Metodo de utilidad para obtener de forma sencilla la casilla
-	 * correspondiente a la que pertenece un pixel en la posicion (x, y).
-	 * 
-	 * @param x
-	 *            Coordenada x
-	 * @param y
-	 *            Coordenada y
-	 * @return Devuelve un punto con las coordenadas de la casilla
-	 *         correspondiente al punto x, y. El valor devuelto estar? en el
-	 *         intervalo [0, 7].
-	 */
-	protected Point getCasilla(int x, int y) {
-		int posX = (x - BORDE - bordeLAT) / TAM, posY = (y - BORDE - bordeSUP)
-				/ TAM;
-		if (!isSentido()) {
-			posX = 7 - posX;
-			posY = 7 - posY;
-		}
-		return new Point(posX, posY);
-	}
-
-	private void dibujarBorde(Graphics g) {
-		Image borde = theme.getMarco();
-		if (borde != null) {
-			g.drawImage(borde, 0, 0, null);
-		} else { // Dibujamos a mano
-			g.setColor(Color.BLACK);
-
-			g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
-					getWidth(), getHeight()));
-			// char num = '8';
-			// char let = 'a';
-
-			g.setColor(new Color(209, 193, 134));
-			g.setFont(new Font("Arial", Font.BOLD, 12));
-
-			int yF = 8 * TAM + BORDE * 3 / 2 + 6;
-			for (int i = 0; i < 8; i++) {
-				int xF = i * TAM + BORDE + TAM / 2;
-				if (sentido) {
-					g.drawString(new Character((char) (i + 'A')).toString(),
-							xF, yF);
-				} else {
-					g.drawString(
-							new Character((char) (7 - i + 'A')).toString(), xF,
-							yF);
-				}
-			}
-			int xF = BORDE / 2 - 3;
-			for (int i = 0; i < 8; i++) {
-				yF = i * TAM + BORDE + TAM / 2;
-				if (sentido) {
-
-					g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
-
-				} else {
-					g.drawString(new Integer(i + 1).toString(), xF, yF);
-				}
-			}
-		}
-	}
-
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO) {
-			return 0;
-		}
-		return 1;
-	}
-	
-	private int tipoToInt(Tipo tipo) {
-		switch(tipo) {
-		case PEON:
-			return 0;
-		case CABALLO:
-			return 1;
-		case ALFIL:
-			return 2;
-		case TORRE:
-			return 3;
-		case DAMA:
-			return 4;
-		case REY:
-			return 5;
-		}
-		return -1;
-	}
-	
-	private Tipo intToTipo(int i) {
-		switch(i) {
-		case 0:
-			return Tipo.PEON;
-		case 1:
-			return Tipo.CABALLO;
-		case 2:
-			return Tipo.ALFIL;
-		case 3:
-			return Tipo.TORRE;
-		case 4:
-			return Tipo.DAMA;
-		case 5:
-			return Tipo.REY;
-		}
-		return null;
-	}
-
-	/*
-	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
-	 * tama?o adecuado del tablero
-	 */
-
-	private final void redimensionar() {
-		MediaTracker media = new MediaTracker(this);
-		for (int i = 0; i < 2; i++) {
-			for (int j = 0; j < 6; j++) {
-				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
-						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
-				media.addImage(piezas[i][j], 1);
-			}
-		}
-		try {
-			media.waitForID(1);
-		} catch (InterruptedException e) {
-			JOptionPane.showMessageDialog(this,
-					"Redimensionado de Imagenes Interrumpido:\n"
-							+ e.getMessage());
-		}
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/VariationsTree.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,219 @@
+package com.mihail.chess;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.mihail.chess.Board.Bando;
+
+/**
+ * @author Wotan
+ * 
+ * TODO To change the template for this generated type comment go to Window -
+ * Preferences - Java - Code Style - Code Templates
+ */
+public class VariationsTree {
+	private class NodoArbol {
+		public Movement movimiento;
+
+		public ArrayList<VariationsTree> variantes;
+
+		public NodoArbol(Movement mov) {
+			movimiento = mov;
+		}
+	}
+
+	/**
+	 * Desplazamiento con respecto al principio de la partida. En el caso de la
+	 * variante principal, el desplazamiento es 0, pero en otro caso el
+	 * desplazamiento es igual el numero de movimiento en el que se encuentra la
+	 * variante.
+	 */
+
+	private int desplazamiento = 0;
+
+	private AbstractList<NodoArbol> arbol = new ArrayList<NodoArbol>();
+
+	/**
+	 * 
+	 */
+	public VariationsTree() {
+	}
+
+	private VariationsTree(int desp) {
+		desplazamiento = desp;
+	}
+
+	/**
+	 * A?ade el movimiento al final de la variante principal.
+	 * 
+	 * @param mov
+	 *            Movimiento que se a?ade.
+	 */
+	public void appendMovimiento(Movement mov) {
+		arbol.add(new NodoArbol(mov));
+	}
+
+	/**
+	 * Obtiene un movimiento a partir del numero de movimiento y el turno de
+	 * juego.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento
+	 * @param numero
+	 *            Numero del movimiento
+	 * @return Devuelve el movimiento correspondiente a color y numero
+	 */
+	public Movement getMovimiento(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+		if (n != null)
+			return n.movimiento;
+		return null;
+	}
+	
+	public Movement getMovimiento(int halfPly) {
+		return arbol.get(halfPly).movimiento;
+	}
+
+	/**
+	 * Comprueba si dado un movimiento, existen alternativas.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 * @return Un booleano que indica si para ese movimiento existen
+	 *         alternativas.
+	 */
+	public boolean existeVariante(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n != null && n.variantes != null)
+			return (!n.variantes.isEmpty());
+		return false;
+	}
+
+	/**
+	 * Devuelve el numero de variantes a un movimiento determinado.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 * @return El numero de alternativas a un movimiento.
+	 */
+	public int getNumVariantes(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n != null) {
+			if (n.variantes != null)
+				return n.variantes.size();
+		}
+		return 0;
+	}
+
+	private int bandoToInt(Bando b) {
+		if (b == Bando.BLANCO)
+			return 0;
+		return 1;
+	}
+
+	// Funcion de utilidad.
+	private NodoArbol getNodo(Bando color, int numero) {
+		int indice = (numero - 1) * 2 + bandoToInt(color);
+		if (indice < arbol.size())
+			return arbol.get(indice);
+		return null;
+	}
+
+	/**
+	 * A?ade un movimiento como variante a otro movimiento.
+	 * 
+	 * @param mov
+	 *            Movimiento que se a?ade como alternativa
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 */
+	public void addVariante(Movement mov, Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n.variantes == null)
+			n.variantes = new ArrayList<VariationsTree>();
+
+		VariationsTree a = new VariationsTree(numero);
+		if (color == Bando.NEGRO) // Cada arbol de variantes debe empezar con un movimiento de blancas
+			a.appendMovimiento(new Movement());
+		a.appendMovimiento(mov);
+
+		n.variantes.add(a);
+	}
+
+	/**
+	 * Devuelve la variante numero num a un movimiento dado.
+	 * 
+	 * @param color
+	 * @param numero
+	 * @param num
+	 *            Numero de variante que se quiere obtener.
+	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
+	 */
+	public VariationsTree getVariante(Bando color, int numero, int num) {
+		NodoArbol n = getNodo(color, numero);
+		if (n != null)
+			return n.variantes.get(num);
+		return null;
+	}
+
+	/**
+	 * @return Devuelve el numero total de movimientos desde el comienzo de la
+	 *         partida. Solo cuenta los turnos jugados, no cuenta un movimiento
+	 *         por negras y otro por blancas.
+	 */
+	public int getNumMovimientos() {
+		return desplazamiento + ((arbol.size() + 1) / 2);
+	}
+
+	/**
+	 * Cuenta los medios movimientos, es decir, contando uno por cada movimiento
+	 * de negras y blancas.
+	 * 
+	 * @return Los medios movimientos desde el comienzo de la partida.
+	 */
+
+	public int getNumHalfPly() {
+		return arbol.size();
+	}
+
+	/**
+	 * Devuelve el ?ltimo movimiento de la variante actual.
+	 * 
+	 * @return
+	 */
+
+	public Movement getLastMovimiento() {
+		return arbol.get(arbol.size() - 1).movimiento;
+	}
+	
+	/**
+	 * Hace que una variante pase a ser la variante principal.
+	 * 
+	 * @param color
+	 * @param numero
+	 * @param num
+	 */
+	
+	public void promoteVariant(Bando color, int numero, int num) {
+		VariationsTree a = getVariante(color, numero, num);
+		int indice = (numero - 1) * 2 + bandoToInt(color);
+		NodoArbol n = getNodo(color, numero);
+		
+		VariationsTree newTree = new VariationsTree();
+		newTree.arbol  = (AbstractList<VariationsTree.NodoArbol>)arbol.subList(indice, arbol.size());
+		n.variantes.add(newTree);
+		
+		arbol.addAll(a.arbol);
+		n.variantes.remove(num);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,77 +0,0 @@
-package com.mihail.chess;
-
-/**
- * Almacena la direcci?n en la que una pieza puede mover. Cuando se crea un
- * nuevo vector direcci?n, se entiende que la x y la y indican las componentes
- * del vector dentro del tablero. Adem?s el vector debe ser 'unitario' para que
- * la l?gica lo interprete correctamente. Por ejemplo, si queremos indicar los
- * movimientos posibles de una dama, basta con indicar 8 vectores de direcci?n:
- * (1, 0) (1, 1) (1, -1) (0, 1) (0, -1) (-1, 0) (-1, 1) (-1, -1). Esto
- * proporciona gran flexibilidad a la hora de definir nuevas piezas en sistemas
- * de ajedrez alternativos. Podriamos definir una pieza que se mueva unicamente
- * como (1, 2) y (0, 1). TODO indicar los vectores que deben ser estrictamente
- * unitarios, para diferenciar piezas que se mueven una casilla de las que se
- * mueven toda la fila. Quiza sea conveniente indicarlo en Pieza, junto con si
- * la pieza puede saltar a otras.
- */
-
-public class VectorDireccion {
-	private int x, y;
-
-	/**
-	 * Crea un nuevo vector de direcci?n.
-	 * 
-	 * @param x_
-	 *            Desplazamiento permitido en sentido horizontal, es decir, a
-	 *            traves de las filas
-	 * @param y_
-	 *            Desplazamiento permitido en sentido vertical, es decir, a
-	 *            traves de las columnas
-	 */
-	public VectorDireccion(int x_, int y_) {
-		x = x_;
-		y = y_;
-	}
-
-	/**
-	 * Comprueba si un vector es multiplo de otro. Por ejemplo, devolveria true
-	 * en caso que al vector (1, 1) se le pase el vector (2, 2).
-	 * 
-	 * @param v
-	 *            Vector con el que queremos comprobar si es la misma direccion.
-	 * @return Un booleano si este vector y el recibido siguen la misma
-	 *         direccion.
-	 */
-	public boolean esMismaDireccion(VectorDireccion v) {
-		int difX, difY;
-
-		if ((x == 0 && v.getX() != 0) || (y == 0 && v.getY() != 0))
-			return false;
-
-		if (v.getX() == 0 && x == 0)
-			difX = 1;
-		else
-			difX = v.getX() / x;
-
-		if (v.getY() == 0 && y == 0)
-			difY = 1;
-		else
-			difY = v.getY() / y;
-
-		return (difY == difX);
-	}
-
-	/**
-	 * Devuelve el desplazamiento horizontal de este vector.
-	 */
-	public int getX() {
-		return x;
-	}
-
-	/**
-	 * Devuelve el desplazamiento vertical de este vector.
-	 */
-	public int getY() {
-		return y;
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/clock/Clock.java (from rev 27, trunk/MihailChessLib/com/mihail/clock/Reloj.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/clock/Clock.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,174 @@
+package com.mihail.clock;
+
+import java.util.Observable;
+import java.util.TimerTask;
+import java.util.Timer;
+
+/**
+ * El funcionamiento de la clase Reloj se basa en el paradigma Modelo-Vista.
+ * Reloj representa un objeto observable. Una aplicacion que quiera usar un
+ * reloj ha de implementar la interfaz Observer, como explica la documentacion
+ * de la superclase Observable.<br>
+ * Reloj utiliza un Timer que, cada decima de segundo, decrementa el valor del
+ * reloj. Se pueden utilizar recargas, si bien se realizan de forma asincrona,
+ * estando obligado el observador a recargar el Reloj cuando lo desee. Presenta
+ * dos estados, parado y en marcha. Estos estados nos permiten parar el Reloj
+ * cuando sea el turno del oponente.<br>
+ * El metodo Observer.update() sera llamado cada vez que haya un cambio de
+ * estado en el Reloj, esto es, cada vez que se decrementa el tiempo. Es
+ * responsabilidad del observador controlar el fin de tiempo.<br>
+ * El manejo de la clase Reloj se realiza basicamente con tres metodos: comenzar
+ * (), setParado (boolean b) y recargar ().<br>
+ * Una vez instanciada la clase, se llamara a comenzar(). Esto hace que el Timer
+ * comience a funcionar. El estado inicial del Reloj sera de parado. Para
+ * ponerlo en marcha y pararlo sucesivamente, segun cambie el turno de juego en
+ * la partida, usaremos setParado (boolean b). Cuando el observador desee
+ * recargar el reloj, llamara a recarga (), sumandose en el reloj la cantidad
+ * establecida previamente en el constructor o usando setRecarga(int recarga).<br>
+ * 
+ * @author Pedro Su?rez Casal
+ * @author Iago Porto D?az
+ * 
+ * @see java.util.Observable
+ * @see java.util.Observer
+ * @see java.util.Timer
+ */
+public class Clock extends Observable {
+	protected int horas, minutos, segundos, decimas;
+
+	protected int recarga;
+
+	protected boolean parado;
+
+	protected static Timer tiempo = null;
+
+	public Clock(int h, int m, int s) throws ClockException {
+		parado = true;
+		horas = h;
+		minutos = m;
+		segundos = s;
+		if (h < 0)
+			throw new ClockException("Horas fuera de rango");
+		if (m < 0 || m > 59)
+			throw new ClockException("Minutos fuera de rango");
+		if (s < 0 || s > 59)
+			throw new ClockException("Segundos fuera de rango");
+		decimas = 0;
+		recarga = 0;
+	}
+
+	public Clock(int h, int m, int s, int rec) throws ClockException {
+		parado = true;
+		horas = h;
+		minutos = m;
+		segundos = s;
+		if (h < 0)
+			throw new ClockException("Horas fuera de rango");
+		if (m < 0 || m > 59)
+			throw new ClockException("Minutos fuera de rango");
+		if (s < 0 || s > 59)
+			throw new ClockException("Segundos fuera de rango");
+		decimas = 0;
+		recarga = rec;
+		if (rec < 0)
+			throw new ClockException("Recarga fuera de rango");
+	}
+
+	public void comenzar() {
+		if (tiempo == null) {
+			tiempo = new Timer();
+		}
+		parado = false;
+		tiempo.scheduleAtFixedRate(new TimerTask() {
+			public void run() {
+				tareasRun();
+			}
+		}, 0, 100);
+	}
+
+	protected void tareasRun() {
+		if (!parado) {
+			if (decimas != 0) {
+				decimas--;
+			} else {
+				if (segundos != 0) {
+					segundos--;
+				} else {
+					if (minutos != 0) {
+						minutos--;
+					} else {
+						horas--;
+						minutos = 59;
+					}
+					segundos = 59;
+				}
+				decimas = 9;
+			}
+			// Notifica que se han producido cambios en el reloj.
+			this.setChanged();
+			// Avisa a sus observadores de que se han producido cambios. Este
+			// metodo ya llama a clearChanged().
+			this.notifyObservers();
+			// // Sirve para que no aparezcan tiempos negativos en el
+			// // reloj (por ejemplo, al acabarse el tiempo).
+			// if (HORAS < 0 || MINUTOS < 0 || SEGUNDOS < 0) {
+			// HORAS = 0;
+			// MINUTOS = 0;
+			// SEGUNDOS = 0;
+			// DECIMAS = 0;
+			// }
+		}
+	}
+
+	public void setParado(boolean b) {
+		parado = b;
+	}
+
+	public void setTiempo(int h, int m, int s, int d) throws ClockException {
+		horas = h;
+		if (h < 0)
+			throw new ClockException("Horas fuera de rango");
+		if (m < 0 || m > 59)
+			throw new ClockException("Minutos fuera de rango");
+		else
+			minutos = m;
+		if (s < 0 || s > 59)
+			throw new ClockException("Segundos fuera de rango");
+		else
+			segundos = s;
+		decimas = d;
+	}
+
+	public void recargar() {
+		int simul, resto;
+		simul = segundos + recarga;
+		horas += simul / 3600;
+		resto = simul % 3600;
+		minutos += resto / 60;
+		segundos = resto % 60;
+	}
+
+	public boolean isFinTiempo() {
+		return horas < 0;
+	}
+
+	public void setRecarga(int segs) {
+		recarga = segs;
+	}
+
+	public int getHoras() {
+		return horas;
+	}
+
+	public int getMinutos() {
+		return minutos;
+	}
+
+	public int getSegundos() {
+		return segundos;
+	}
+
+	public int getDecimas() {
+		return decimas;
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/clock/ClockException.java (from rev 27, trunk/MihailChessLib/com/mihail/clock/RelojException.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/clock/ClockException.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,24 @@
+package com.mihail.clock;
+
+/**
+ * Esta clase define una RelojException, que son las excepciones que se lanzan
+ * cuando hay algun problema con los relojes.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ * 
+ */
+public class ClockException extends Exception {
+
+	private static final long serialVersionUID = 1L;
+
+	/**
+	 * Construye una RelojException con el mensaje de detalle especificado.
+	 * 
+	 * @param s
+	 *            Mensaje que detalla la excepcion.
+	 */
+	public ClockException(String s) {
+		super(s);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/clock/Reloj.java
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,174 +0,0 @@
-package com.mihail.clock;
-
-import java.util.Observable;
-import java.util.TimerTask;
-import java.util.Timer;
-
-/**
- * El funcionamiento de la clase Reloj se basa en el paradigma Modelo-Vista.
- * Reloj representa un objeto observable. Una aplicacion que quiera usar un
- * reloj ha de implementar la interfaz Observer, como explica la documentacion
- * de la superclase Observable.<br>
- * Reloj utiliza un Timer que, cada decima de segundo, decrementa el valor del
- * reloj. Se pueden utilizar recargas, si bien se realizan de forma asincrona,
- * estando obligado el observador a recargar el Reloj cuando lo desee. Presenta
- * dos estados, parado y en marcha. Estos estados nos permiten parar el Reloj
- * cuando sea el turno del oponente.<br>
- * El metodo Observer.update() sera llamado cada vez que haya un cambio de
- * estado en el Reloj, esto es, cada vez que se decrementa el tiempo. Es
- * responsabilidad del observador controlar el fin de tiempo.<br>
- * El manejo de la clase Reloj se realiza basicamente con tres metodos: comenzar
- * (), setParado (boolean b) y recargar ().<br>
- * Una vez instanciada la clase, se llamara a comenzar(). Esto hace que el Timer
- * comience a funcionar. El estado inicial del Reloj sera de parado. Para
- * ponerlo en marcha y pararlo sucesivamente, segun cambie el turno de juego en
- * la partida, usaremos setParado (boolean b). Cuando el observador desee
- * recargar el reloj, llamara a recarga (), sumandose en el reloj la cantidad
- * establecida previamente en el constructor o usando setRecarga(int recarga).<br>
- * 
- * @author Pedro Su?rez Casal
- * @author Iago Porto D?az
- * 
- * @see java.util.Observable
- * @see java.util.Observer
- * @see java.util.Timer
- */
-public class Reloj extends Observable {
-	protected int horas, minutos, segundos, decimas;
-
-	protected int recarga;
-
-	protected boolean parado;
-
-	protected static Timer tiempo = null;
-
-	public Reloj(int h, int m, int s) throws RelojException {
-		parado = true;
-		horas = h;
-		minutos = m;
-		segundos = s;
-		if (h < 0)
-			throw new RelojException("Horas fuera de rango");
-		if (m < 0 || m > 59)
-			throw new RelojException("Minutos fuera de rango");
-		if (s < 0 || s > 59)
-			throw new RelojException("Segundos fuera de rango");
-		decimas = 0;
-		recarga = 0;
-	}
-
-	public Reloj(int h, int m, int s, int rec) throws RelojException {
-		parado = true;
-		horas = h;
-		minutos = m;
-		segundos = s;
-		if (h < 0)
-			throw new RelojException("Horas fuera de rango");
-		if (m < 0 || m > 59)
-			throw new RelojException("Minutos fuera de rango");
-		if (s < 0 || s > 59)
-			throw new RelojException("Segundos fuera de rango");
-		decimas = 0;
-		recarga = rec;
-		if (rec < 0)
-			throw new RelojException("Recarga fuera de rango");
-	}
-
-	public void comenzar() {
-		if (tiempo == null) {
-			tiempo = new Timer();
-		}
-		parado = false;
-		tiempo.scheduleAtFixedRate(new TimerTask() {
-			public void run() {
-				tareasRun();
-			}
-		}, 0, 100);
-	}
-
-	protected void tareasRun() {
-		if (!parado) {
-			if (decimas != 0) {
-				decimas--;
-			} else {
-				if (segundos != 0) {
-					segundos--;
-				} else {
-					if (minutos != 0) {
-						minutos--;
-					} else {
-						horas--;
-						minutos = 59;
-					}
-					segundos = 59;
-				}
-				decimas = 9;
-			}
-			// Notifica que se han producido cambios en el reloj.
-			this.setChanged();
-			// Avisa a sus observadores de que se han producido cambios. Este
-			// metodo ya llama a clearChanged().
-			this.notifyObservers();
-			// // Sirve para que no aparezcan tiempos negativos en el
-			// // reloj (por ejemplo, al acabarse el tiempo).
-			// if (HORAS < 0 || MINUTOS < 0 || SEGUNDOS < 0) {
-			// HORAS = 0;
-			// MINUTOS = 0;
-			// SEGUNDOS = 0;
-			// DECIMAS = 0;
-			// }
-		}
-	}
-
-	public void setParado(boolean b) {
-		parado = b;
-	}
-
-	public void setTiempo(int h, int m, int s, int d) throws RelojException {
-		horas = h;
-		if (h < 0)
-			throw new RelojException("Horas fuera de rango");
-		if (m < 0 || m > 59)
-			throw new RelojException("Minutos fuera de rango");
-		else
-			minutos = m;
-		if (s < 0 || s > 59)
-			throw new RelojException("Segundos fuera de rango");
-		else
-			segundos = s;
-		decimas = d;
-	}
-
-	public void recargar() {
-		int simul, resto;
-		simul = segundos + recarga;
-		horas += simul / 3600;
-		resto = simul % 3600;
-		minutos += resto / 60;
-		segundos = resto % 60;
-	}
-
-	public boolean isFinTiempo() {
-		return horas < 0;
-	}
-
-	public void setRecarga(int segs) {
-		recarga = segs;
-	}
-
-	public int getHoras() {
-		return horas;
-	}
-
-	public int getMinutos() {
-		return minutos;
-	}
-
-	public int getSegundos() {
-		return segundos;
-	}
-
-	public int getDecimas() {
-		return decimas;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/clock/RelojException.java
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,24 +0,0 @@
-package com.mihail.clock;
-
-/**
- * Esta clase define una RelojException, que son las excepciones que se lanzan
- * cuando hay algun problema con los relojes.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- * 
- */
-public class RelojException extends Exception {
-
-	private static final long serialVersionUID = 1L;
-
-	/**
-	 * Construye una RelojException con el mensaje de detalle especificado.
-	 * 
-	 * @param s
-	 *            Mensaje que detalla la excepcion.
-	 */
-	public RelojException(String s) {
-		super(s);
-	}
-}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/openings/Aperturas.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,41 +0,0 @@
-package com.mihail.openings;
-
-import java.io.*;
-import java.util.Locale;
-
-import com.mihail.chess.*;
-
-public class Aperturas {
-	/**
-	 * Tabla hash con las aperturas.
-	 */
-	private DiccionarioAperturas aperturas;
-
-	/**
-	 * Recibe el tablero donde se va a mirar la apertura y el idioma en que se
-	 * quieren las aperturas.
-	 * 
-	 * @param loc
-	 * @throws FileNotFoundException
-	 * @throws IOException
-	 */
-	public Aperturas(Locale loc) throws FileNotFoundException, IOException {
-		// Se construye la Tabla Hash con las aperturas.
-		aperturas = new DiccionarioAperturas(loc);
-		aperturas.parse();
-	}
-
-	/**
-	 * Obtiene la apertura que se esta jugando en una Posicion pos
-	 * 
-	 * @param pos
-	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
-	 */
-	public String getApertura(Posicion pos) {
-		int clave = pos.getClavePosicion();
-		if (aperturas.containsKey(clave))
-			return aperturas.get(clave);
-		else
-			return null;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,123 +0,0 @@
-package com.mihail.openings;
-
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.*;
-
-/**
- * Esta clase define un objeto DiccionarioAperturas y se encarga de almacenar en
- * una tabla hash los nombres de las aperturas junto con una clave numerica que
- * los identifica. Ofrece soporte para varios idiomas.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-public final class DiccionarioAperturas {
-
-	/**
-	 * Tama?o de la Tabla Hash. Se elige 2017 porque es el numero primo mas
-	 * cercano a 2014, que es el numero de entradas del fichero eco.dat
-	 */
-	private final static int CAPACIDAD = 2017;
-
-	/**
-	 * Constante que representa el nombre del fichero donde estan las aperturas.
-	 */
-	private final static String NOMBRE_FICHERO_APERTURAS = "eco";
-
-	/**
-	 * Representa la extension que indica en que idioma estan las aperturas
-	 * (_es, _en, etc).
-	 */
-	private static String SUFIJO_FICHERO_APERTURAS;
-
-	/**
-	 * Constante que representa la extension del fichero donde estan las
-	 * aperturas.
-	 */
-	private final static String EXTENSION_FICHERO_APERTURAS = ".dat";
-
-	/**
-	 * Tabla Hash donde se almacenan los nombres de aperturas. Las claves se
-	 * generan a partir del numero de la posicion.
-	 */
-	private HashMap<Integer, String> tabla;
-
-	/**
-	 * Idioma de las aperturas.
-	 */
-	private Locale idioma;
-
-	/**
-	 * Crea una nueva instancia de la clase y crea la Tabla Hash con capacidad
-	 * CAPACIDAD.
-	 */
-	public DiccionarioAperturas(Locale id) {
-		tabla = new HashMap<Integer, String>(CAPACIDAD);
-		// Segun el idioma que se use en el programa, se cargan las aperturas en
-		// ingles o en castellano.
-		idioma = id;
-		String lang = idioma.getLanguage();
-		if (lang.equals("en") || lang.equals("de"))
-			SUFIJO_FICHERO_APERTURAS = "_en";
-		else
-			SUFIJO_FICHERO_APERTURAS = "_es";
-	}
-
-	/**
-	 * Lee el fichero de aperturas FICHERO_APERTURAS e introduce sus datos en la
-	 * Tabla Hash.
-	 */
-	public void parse() throws FileNotFoundException, IOException {
-		byte[] text;
-		String c;
-		String[] lineas, partes;
-		String eco, apertura, variante;
-		StringBuffer aInsertar;
-		Integer clave;
-		FileInputStream ent;
-		ent = new FileInputStream(NOMBRE_FICHERO_APERTURAS
-				+ SUFIJO_FICHERO_APERTURAS + EXTENSION_FICHERO_APERTURAS);
-		text = new byte[ent.available()];
-		ent.read(text);
-		ent.close();
-		c = new String(text);
-		lineas = c.split("\n");
-		for (int i = 0; i < lineas.length; i++) {
-			partes = lineas[i].split("\t");
-			clave = new Integer(partes[0]);
-			eco = partes[1];
-			apertura = partes[2];
-			variante = partes[3];
-			aInsertar = new StringBuffer(eco + " " + apertura + ", " + variante);
-			if (aInsertar.charAt(aInsertar.length() - 2) == ',') {
-				aInsertar.deleteCharAt(aInsertar.length() - 1);
-				aInsertar.deleteCharAt(aInsertar.length() - 1);
-			}
-			tabla.put(clave, aInsertar.toString());
-		}
-	}
-
-	/**
-	 * Este m?todo sirve para consultar si la tabla hash contiene la clave n.
-	 * 
-	 * @param clave
-	 *            La clave hash.
-	 * @return True si la contiene, false en caso contrario.
-	 */
-	public boolean containsKey(int clave) {
-		return tabla.containsKey(clave);
-	}
-
-	/**
-	 * Este m?todo sirve para obtener un nombre de apertura de la tabla hash.
-	 * 
-	 * @param clave
-	 *            La clave hash.
-	 * @return El string que corresponde con la clave n.
-	 */
-	public String get(int clave) {
-		return tabla.get(clave);
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/openings/Openings.java (from rev 27, trunk/MihailChessLib/com/mihail/openings/Aperturas.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,41 @@
+package com.mihail.openings;
+
+import java.io.*;
+import java.util.Locale;
+
+import com.mihail.chess.*;
+
+public class Openings {
+	/**
+	 * Tabla hash con las aperturas.
+	 */
+	private OpeningsDictionary aperturas;
+
+	/**
+	 * Recibe el tablero donde se va a mirar la apertura y el idioma en que se
+	 * quieren las aperturas.
+	 * 
+	 * @param loc
+	 * @throws FileNotFoundException
+	 * @throws IOException
+	 */
+	public Openings(Locale loc) throws FileNotFoundException, IOException {
+		// Se construye la Tabla Hash con las aperturas.
+		aperturas = new OpeningsDictionary(loc);
+		aperturas.parse();
+	}
+
+	/**
+	 * Obtiene la apertura que se esta jugando en una Posicion pos
+	 * 
+	 * @param pos
+	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
+	 */
+	public String getApertura(Position pos) {
+		int clave = pos.getClavePosicion();
+		if (aperturas.containsKey(clave))
+			return aperturas.get(clave);
+		else
+			return null;
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java (from rev 27, trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,123 @@
+package com.mihail.openings;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.*;
+
+/**
+ * Esta clase define un objeto DiccionarioAperturas y se encarga de almacenar en
+ * una tabla hash los nombres de las aperturas junto con una clave numerica que
+ * los identifica. Ofrece soporte para varios idiomas.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+public final class OpeningsDictionary {
+
+	/**
+	 * Tama?o de la Tabla Hash. Se elige 2017 porque es el numero primo mas
+	 * cercano a 2014, que es el numero de entradas del fichero eco.dat
+	 */
+	private final static int CAPACIDAD = 2017;
+
+	/**
+	 * Constante que representa el nombre del fichero donde estan las aperturas.
+	 */
+	private final static String NOMBRE_FICHERO_APERTURAS = "eco";
+
+	/**
+	 * Representa la extension que indica en que idioma estan las aperturas
+	 * (_es, _en, etc).
+	 */
+	private static String SUFIJO_FICHERO_APERTURAS;
+
+	/**
+	 * Constante que representa la extension del fichero donde estan las
+	 * aperturas.
+	 */
+	private final static String EXTENSION_FICHERO_APERTURAS = ".dat";
+
+	/**
+	 * Tabla Hash donde se almacenan los nombres de aperturas. Las claves se
+	 * generan a partir del numero de la posicion.
+	 */
+	private HashMap<Integer, String> tabla;
+
+	/**
+	 * Idioma de las aperturas.
+	 */
+	private Locale idioma;
+
+	/**
+	 * Crea una nueva instancia de la clase y crea la Tabla Hash con capacidad
+	 * CAPACIDAD.
+	 */
+	public OpeningsDictionary(Locale id) {
+		tabla = new HashMap<Integer, String>(CAPACIDAD);
+		// Segun el idioma que se use en el programa, se cargan las aperturas en
+		// ingles o en castellano.
+		idioma = id;
+		String lang = idioma.getLanguage();
+		if (lang.equals("en") || lang.equals("de"))
+			SUFIJO_FICHERO_APERTURAS = "_en";
+		else
+			SUFIJO_FICHERO_APERTURAS = "_es";
+	}
+
+	/**
+	 * Lee el fichero de aperturas FICHERO_APERTURAS e introduce sus datos en la
+	 * Tabla Hash.
+	 */
+	public void parse() throws FileNotFoundException, IOException {
+		byte[] text;
+		String c;
+		String[] lineas, partes;
+		String eco, apertura, variante;
+		StringBuffer aInsertar;
+		Integer clave;
+		FileInputStream ent;
+		ent = new FileInputStream(NOMBRE_FICHERO_APERTURAS
+				+ SUFIJO_FICHERO_APERTURAS + EXTENSION_FICHERO_APERTURAS);
+		text = new byte[ent.available()];
+		ent.read(text);
+		ent.close();
+		c = new String(text);
+		lineas = c.split("\n");
+		for (int i = 0; i < lineas.length; i++) {
+			partes = lineas[i].split("\t");
+			clave = new Integer(partes[0]);
+			eco = partes[1];
+			apertura = partes[2];
+			variante = partes[3];
+			aInsertar = new StringBuffer(eco + " " + apertura + ", " + variante);
+			if (aInsertar.charAt(aInsertar.length() - 2) == ',') {
+				aInsertar.deleteCharAt(aInsertar.length() - 1);
+				aInsertar.deleteCharAt(aInsertar.length() - 1);
+			}
+			tabla.put(clave, aInsertar.toString());
+		}
+	}
+
+	/**
+	 * Este m?todo sirve para consultar si la tabla hash contiene la clave n.
+	 * 
+	 * @param clave
+	 *            La clave hash.
+	 * @return True si la contiene, false en caso contrario.
+	 */
+	public boolean containsKey(int clave) {
+		return tabla.containsKey(clave);
+	}
+
+	/**
+	 * Este m?todo sirve para obtener un nombre de apertura de la tabla hash.
+	 * 
+	 * @param clave
+	 *            La clave hash.
+	 * @return El string que corresponde con la clave n.
+	 */
+	public String get(int clave) {
+		return tabla.get(clave);
+	}
+}
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/pgn/PGNParser.java
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/PGNParser.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/pgn/PGNParser.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -11,14 +11,14 @@
  * @author Martin Rademacher mano at radebatz.net
  * @versionServidor $Id: PGNParser.jj,v 1.4 2002/06/15 09:00:47 radebatz Exp $
  */
-public final class PGNParser extends Analizador implements PGNParserConstants {
+public final class PGNParser extends Parser implements PGNParserConstants {
 	public static final int NEXT_TOKEN = 1;
 
 	public static final int SKIP_TOKEN = 0;
 
 	public static final int EOF = -1;
 
-	Partida partida = new Partida();
+	Game partida = new Game();
 
 	public void analizar() throws ParseException {
 		while (parse() != -1) {
@@ -415,7 +415,7 @@
 		 * token.setTerminator(imageOf(gg)); return token;
 		 */
 		listaPartidas.add(partida);
-		partida = new Partida();
+		partida = new Game();
 	}
 
 	/**
@@ -1039,12 +1039,12 @@
 		java.io.FileWriter f = new java.io.FileWriter(archivo);
 
 		for (int i = 0; i < listaPartidas.size(); i++) {
-			Partida p = listaPartidas.get(i);
+			Game p = listaPartidas.get(i);
 			PGNParser.guardarPartida(archivo, p);
 		}
 	}
 
-	public static void guardarPartida(String archivo, Partida p)
+	public static void guardarPartida(String archivo, Game p)
 			throws IOException {
 		java.io.FileWriter f = new java.io.FileWriter(archivo, true);
 

Modified: trunk/MihailChessLib/com/mihail/test/PositionTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -9,12 +9,12 @@
  */
 package com.mihail.test;
 
-import com.mihail.chess.Pieza;
-import com.mihail.chess.Posicion;
+import com.mihail.chess.Piece;
+import com.mihail.chess.Position;
 import junit.framework.TestCase;
 
-import static com.mihail.chess.Logica.Bando;
-import static com.mihail.chess.Pieza.Tipo;
+import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Piece.Tipo;
 
 public class PositionTest extends TestCase {
 
@@ -22,7 +22,7 @@
 	 * Test method for 'com.mihail.chess.Position.Position()'
 	 */
 	public void testPosition() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		assertEquals("8/8/8/8/8/8/8/8 w - - 0 1", p.getFEN());
 	}
 
@@ -30,22 +30,22 @@
 	 * Test method for 'com.mihail.chess.Position.getFEN()'
 	 */
 	public void testGetFEN() {
-		Posicion p = new Posicion();
-		p.setPosicion(Posicion.CAD_INICIAL);
+		Position p = new Position();
+		p.setPosicion(Position.CAD_INICIAL);
 		assertEquals(
 				"rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1", p
 						.getFEN());
 	}
 
 	public void testSetPosicion() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 	}
 
 	/*
 	 * Test method for 'com.mihail.chess.Position.setTurno()'
 	 */
 	public void testSetTurno() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		Bando turno = p.getTurno();
 		p.setTurno();
 		p.setTurno();
@@ -56,7 +56,7 @@
 	 * Test method for 'com.mihail.chess.Position.setTurno(int)'
 	 */
 	public void testSetTurnoInt() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		p.setTurno(Bando.BLANCO);
 		assertEquals(Bando.BLANCO, p.getTurno());
 		p.setTurno(Bando.NEGRO);
@@ -67,18 +67,18 @@
 	 * Test method for 'com.mihail.chess.Position.setEnroqueCorto(int, boolean)'
 	 */
 	public void testSetEnroqueCorto() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.REY), 'e', '1');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
 		p.setEnroqueCorto(Bando.BLANCO, true);
 		assertFalse(p.getEnroqueCorto(Bando.BLANCO));
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), 'h', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'h', '1');
 		p.setEnroqueCorto(Bando.BLANCO, true);
 		assertTrue(p.getEnroqueCorto(Bando.BLANCO));
 
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.REY), 'e', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
 		p.setEnroqueCorto(Bando.NEGRO, true);
 		assertFalse(p.getEnroqueCorto(Bando.NEGRO));
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), 'h', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'h', '8');
 		p.setEnroqueCorto(Bando.NEGRO, true);
 		assertTrue(p.getEnroqueCorto(Bando.NEGRO));
 	}
@@ -87,18 +87,18 @@
 	 * Test method for 'com.mihail.chess.Position.setEnroqueLargo(int, boolean)'
 	 */
 	public void testSetEnroqueLargo() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.REY), 'e', '1');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
 		p.setEnroqueLargo(Bando.BLANCO, true);
 		assertEquals(false, p.getEnroqueLargo(Bando.BLANCO));
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), 'a', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'a', '1');
 		p.setEnroqueLargo(Bando.BLANCO, true);
 		assertTrue(p.getEnroqueLargo(Bando.BLANCO));
 
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.REY), 'e', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
 		p.setEnroqueLargo(Bando.NEGRO, true);
 		assertFalse(p.getEnroqueLargo(Bando.NEGRO));
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), 'a', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'a', '8');
 		p.setEnroqueLargo(Bando.NEGRO, true);
 		assertTrue(p.getEnroqueLargo(Bando.NEGRO));
 	}
@@ -114,7 +114,7 @@
 	 * Test method for 'com.mihail.chess.Position.borrarPieza(char, char)'
 	 */
 	public void testBorrarPieza() {
-		Posicion p = new Posicion("8/8/8/7p/8/8/8/8 w - h 0 1");
+		Position p = new Position("8/8/8/7p/8/8/8/8 w - h 0 1");
 		// Al borrar la pieza, alPaso deberia resetearse, ya que no hay peon en
 		// esa columna
 		p.borrarPieza('h', '5');
@@ -153,11 +153,11 @@
 	 * Test method for 'com.mihail.chess.Position.getClavePosicion()'
 	 */
 	public void testGetClavePosicion() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
 		int clave = p.getClavePosicion();
 		p.borrarPieza('d', '4');
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
 		assertEquals(clave, p.getClavePosicion());
 	}
 
@@ -165,18 +165,18 @@
 	 * Test method for 'com.mihail.chess.Position.setAlPaso(char)'
 	 */
 	public void testSetAlPaso() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		// Comprobamos que no se pone siempre alPaso
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), 'a', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'a', '1');
 		p.setAlPaso('a');
 		assertEquals(p.getAlPaso(), 0);
 		// Comprobamos que al poner un peon negro en una casilla de alPaso, la
 		// funcion deja
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.PEON), 'h', '5');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.PEON), 'h', '5');
 		p.setAlPaso('h');
 		assertEquals(p.getAlPaso(), 'h');
 		// Probamos lo mismo pero con un peon blanco
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), 'h', '4');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'h', '4');
 		p.setTurno(Bando.NEGRO);
 		p.setAlPaso('h');
 		assertEquals(p.getAlPaso(), 'h');

Modified: trunk/MihailChessLib/com/mihail/test/RelojTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -3,14 +3,14 @@
 import java.util.Observable;
 import java.util.Observer;
 
-import com.mihail.clock.Reloj;
-import com.mihail.clock.RelojException;
+import com.mihail.clock.Clock;
+import com.mihail.clock.ClockException;
 
 public class RelojTest implements Observer {
 
 	public void update(Observable arg0, Object arg1) {
-		if (arg0 instanceof Reloj) {
-			Reloj r = (Reloj) arg0;
+		if (arg0 instanceof Clock) {
+			Clock r = (Clock) arg0;
 			if (r.getDecimas() == 0) {
 				System.out.println(r.getHoras() + ":" + r.getMinutos() + ":"
 						+ r.getSegundos() + "." + r.getDecimas());
@@ -21,11 +21,11 @@
 	}
 
 	public static void main(String args[]) {
-		Reloj reloj = null;
+		Clock reloj = null;
 		RelojTest relojTest = null;
 		try {
-			reloj = new Reloj(0, 0, 10);
-		} catch (RelojException e) {
+			reloj = new Clock(0, 0, 10);
+		} catch (ClockException e) {
 		}
 		relojTest = new RelojTest();
 



From gauleng at berlios.de  Sun Aug 14 15:12:05 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 15:12:05 +0200
Subject: [Mihailchess-svn] r35 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508141312.j7EDC5NM002655@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 15:12:03 +0200 (Sun, 14 Aug 2005)
New Revision: 35

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Board2D.java
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/chess/Movement.java
   trunk/MihailChessLib/com/mihail/chess/Piece.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
   trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
Log:
A riesgo de que vuelva a pasar lo mismo, envio traducciones de poco en poco

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -6,16 +6,16 @@
 
 public class Board {
 
-	public static enum Bando {
-		BLANCO, NEGRO;
+	public static enum Side {
+		WHITE, BLACK;
 
-		public boolean equals(Bando b) {
+		public boolean equals(Side b) {
 			return this == b;
 		}
 	}
 
-	public static enum Resultado {
-		JAQUE_MATE_BLANCO, JAQUE_MATE_NEGRO, TABLAS_REPETICION, TABLAS_50_MOV, TABLAS_INSUF_MATERIAL, TABLAS_AHOGADO
+	public static enum Result {
+		WHITE_CHECKMATE, BLACK_CHECKMATE, REPETITION_DRAW, FIFTY_MOV_DRAW, INSUF_MATERIAL_DRAW, STALEMATE
 	}
 
 	// public static final int JAQUE_MATE_BLANCO = 6;
@@ -63,14 +63,14 @@
 	public Board(Position posInicial) {
 		movimientos = new VariationsTree();
 		posicion = posInicial;
-		hash.insertar(posicion.getClavePosicion());
+		hash.insertar(posicion.getPositionKey());
 	}
 
 	/**
 	 * Reinicia la posicion del tablero a la posicion inicial.
 	 */
-	public void reiniciarTablero() {
-		posicion.setPosicion(Position.CAD_INICIAL);
+	public void restartBoard() {
+		posicion.setFEN(Position.INITIAL_POSITION_FEN);
 	}
 
 	/**
@@ -80,7 +80,7 @@
 	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
 	 */
 
-	public void setCoronacion(Tipo c) {
+	public void setPromotionPiece(Tipo c) {
 		coronar = c;
 	}
 
@@ -90,11 +90,11 @@
 	 * @return Un entero, el numero en cuestion.
 	 */
 
-	public int getNumTotalMovimientos() {
+	public int getTotalFullmoveNumber() {
 		return movimientos.getNumMovimientos();
 	}
 
-	public Position getPosicion() {
+	public Position getPosition() {
 		return this.posicion;
 	}
 
@@ -107,19 +107,19 @@
 	 *         'T' -> Tablas <BR>
 	 *         '\0' -> Partida Inacabada o Resultado Desconocido
 	 */
-	public Resultado getResultado() {
+	public Result getResult() {
 		return movimientos.getLastMovimiento().getFinPartida();
 	}
 
 	/**
 	 * Calcula los movimientos validos para todas las piezas del tablero.
 	 */
-	public void calcularMovimientos() {
+	public void calculateMoves() {
 		for (char i = 'a'; i <= 'h'; i++) {
 			for (char j = '1'; j <= '8'; j++) {
 				Piece p = posicion.getPieza(i, j);
 				if (p != null) {
-					if (!Piece.esBandoContrario(posicion.getTurno(), p)) {
+					if (!Piece.esBandoContrario(posicion.getTurn(), p)) {
 						calcularMovimientos(p);
 					}
 				}
@@ -140,18 +140,18 @@
 		case PEON:
 			// Peon
 			// Peon blanco
-			if (pieza.getBando() == Bando.BLANCO) {
+			if (pieza.getBando() == Side.WHITE) {
 				// Movimiento hacia delante
 				// Hacemos dos iteraciones, una para el caso de que avance
 				// una casilla, otra para el caso de que avance dos
-				if (posicion.esVacia(pieza.getLetra(),
+				if (posicion.isEmpty(pieza.getLetra(),
 						(char) (pieza.getNum() + 1))) {
 					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
 							.getLetra(), (char) (pieza.getNum() + 1))) {
 						pieza.anadirMov(pieza.getLetra(), (char) (pieza
 								.getNum() + 1));
 						if (pieza.getNum() == '2'
-								&& posicion.esVacia(pieza.getLetra(),
+								&& posicion.isEmpty(pieza.getLetra(),
 										(char) (pieza.getNum() + 2))) {
 							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
 									.getLetra(), (char) (pieza.getNum() + 2))) {
@@ -161,17 +161,17 @@
 						}
 					}
 				}
-				if (posicion.getAlPaso() != '\0'
+				if (posicion.getEnPassant() != '\0'
 						&& pieza.getNum() == '5'
-						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+						&& Math.abs(pieza.getLetra() - posicion.getEnPassant()) == 1) {
+					pieza.anadirMov(posicion.getEnPassant(), (char) (pieza
 							.getNum() + 1));
 				}
 				// Movimientos para comer
 				try {
 					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
 							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
+					if (p != null && p.getBando() == Side.BLACK) {
 						if (esLegal(pieza.getLetra(), pieza.getNum(),
 								(char) (pieza.getLetra() + 1), (char) (pieza
 										.getNum() + 1))) {
@@ -184,7 +184,7 @@
 				try {
 					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
 							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
+					if (p != null && p.getBando() == Side.BLACK) {
 						if (esLegal(pieza.getLetra(), pieza.getNum(),
 								(char) (pieza.getLetra() - 1), (char) (pieza
 										.getNum() + 1))) {
@@ -197,14 +197,14 @@
 			}
 			// Peon negro
 			else {
-				if (posicion.esVacia(pieza.getLetra(),
+				if (posicion.isEmpty(pieza.getLetra(),
 						(char) (pieza.getNum() - 1))) {
 					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
 							.getLetra(), (char) (pieza.getNum() - 1))) {
 						pieza.anadirMov(pieza.getLetra(), (char) (pieza
 								.getNum() - 1));
 						if (pieza.getNum() == '7'
-								&& posicion.esVacia(pieza.getLetra(),
+								&& posicion.isEmpty(pieza.getLetra(),
 										(char) (pieza.getNum() - 2))) {
 							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
 									.getLetra(), (char) (pieza.getNum() - 2))) {
@@ -214,16 +214,16 @@
 						}
 					}
 				}
-				if (posicion.getAlPaso() != '\0'
+				if (posicion.getEnPassant() != '\0'
 						&& pieza.getNum() == '4'
-						&& Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+						&& Math.abs(pieza.getLetra() - posicion.getEnPassant()) == 1) {
+					pieza.anadirMov(posicion.getEnPassant(), (char) (pieza
 							.getNum() - 1));
 				}
 				try {
 					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
 							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
+					if (p != null && p.getBando() == Side.BLACK) {
 						if (esLegal(pieza.getLetra(), pieza.getNum(),
 								(char) (pieza.getLetra() + 1), (char) (pieza
 										.getNum() - 1))) {
@@ -236,7 +236,7 @@
 				try {
 					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
 							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Bando.NEGRO) {
+					if (p != null && p.getBando() == Side.BLACK) {
 						if (esLegal(pieza.getLetra(), pieza.getNum(),
 								(char) (pieza.getLetra() - 1), (char) (pieza
 										.getNum() - 1))) {
@@ -309,29 +309,29 @@
 				}
 			}
 
-			if (posicion.getEnroqueCorto(posicion.getTurno())
-					&& !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&& posicion.esVacia((char) (pieza.getLetra() + 1), pieza
+			if (posicion.getKingsideCastling(posicion.getTurn())
+					&& !isAttackedSquare(posicion.getKingPosition(posicion
+							.getTurn()))
+					&& posicion.isEmpty((char) (pieza.getLetra() + 1), pieza
 							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() + 1), (pieza
+					&& !isAttackedSquare((char) (pieza.getLetra() + 1), (pieza
 							.getNum()))
-					&& posicion.esVacia((char) (pieza.getLetra() + 2), pieza
+					&& posicion.isEmpty((char) (pieza.getLetra() + 2), pieza
 							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() + 2), (pieza
+					&& !isAttackedSquare((char) (pieza.getLetra() + 2), (pieza
 							.getNum()))) {
 				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
 			}
-			if (posicion.getEnroqueLargo(posicion.getTurno())
-					&& !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&& posicion.esVacia((char) (pieza.getLetra() - 1), pieza
+			if (posicion.getQueensideCastling(posicion.getTurn())
+					&& !isAttackedSquare(posicion.getKingPosition(posicion
+							.getTurn()))
+					&& posicion.isEmpty((char) (pieza.getLetra() - 1), pieza
 							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() - 1), (pieza
+					&& !isAttackedSquare((char) (pieza.getLetra() - 1), (pieza
 							.getNum()))
-					&& posicion.esVacia((char) (pieza.getLetra() - 2), pieza
+					&& posicion.isEmpty((char) (pieza.getLetra() - 2), pieza
 							.getNum())
-					&& !esCasillaAtacada((char) (pieza.getLetra() - 2), (pieza
+					&& !isAttackedSquare((char) (pieza.getLetra() - 2), (pieza
 							.getNum()))) {
 				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
 			}
@@ -347,8 +347,8 @@
 	 *            Casilla que queremos comprobar si esta siendo atacada
 	 * @return Devuelve un booleano indicando si es una casilla atacada o no
 	 */
-	public boolean esCasillaAtacada(Square c) {
-		return esCasillaAtacada(c.getLetra(), c.getNumero());
+	public boolean isAttackedSquare(Square c) {
+		return isAttackedSquare(c.getLetra(), c.getNumero());
 	}
 
 	/**
@@ -369,7 +369,7 @@
 	 *            atacada
 	 * @return Devuelve un booleano indicando si es una casilla atacada o no
 	 */
-	public boolean esCasillaAtacada(char letra, char num) {
+	public boolean isAttackedSquare(char letra, char num) {
 		// Primero miro las casillas
 		// a salto de caballo. Despues, las verticales, horizontales y
 		// diagonales.
@@ -389,7 +389,7 @@
 				Piece p = posicion.getPieza((char) (letra + v.getX()),
 						(char) (num + v.getY()));
 				if (p != null) {
-					if (Piece.esBandoContrario(posicion.getTurno(), p)
+					if (Piece.esBandoContrario(posicion.getTurn(), p)
 							&& p.getTipo() == Tipo.CABALLO) {
 						return true;
 					}
@@ -413,7 +413,7 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurno(), p)
+				if (Piece.esBandoContrario(posicion.getTurn(), p)
 						&& (p.getTipo() == Tipo.DAMA
 								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
 								&& letra + v.getX() == letDest && p.getTipo() == Tipo.REY))) {
@@ -436,11 +436,11 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurno(), p)
+				if (Piece.esBandoContrario(posicion.getTurn(), p)
 						&& (p.getTipo() == Tipo.DAMA
 								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
 								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Bando.NEGRO))))) {
+								.getTipo() == Tipo.PEON && p.getBando() == Side.BLACK))))) {
 					return true;
 				}
 			} catch (ArrayIndexOutOfBoundsException e) {
@@ -460,11 +460,11 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurno(), p)
+				if (Piece.esBandoContrario(posicion.getTurn(), p)
 						&& (p.getTipo() == Tipo.DAMA
 								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
 								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Bando.BLANCO))))) {
+								.getTipo() == Tipo.PEON && p.getBando() == Side.WHITE))))) {
 					return true;
 				}
 			} catch (ArrayIndexOutOfBoundsException e) {
@@ -495,8 +495,8 @@
 		Piece temp = posicion.getPieza(letDest, numDest);
 		posicion.borrarPiezaInternal(letOrig, numOrig);
 		posicion.setPiezaInternal(movida, letDest, numDest);
-		resultado = esCasillaAtacada(posicion.getKingPosition(posicion
-				.getTurno()));
+		resultado = isAttackedSquare(posicion.getKingPosition(posicion
+				.getTurn()));
 		posicion.borrarPiezaInternal(letDest, numDest);
 		posicion.setPiezaInternal(movida, letOrig, numOrig);
 		if (temp != null)
@@ -518,7 +518,7 @@
 	 *            Es el numero de la casilla de destino
 	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
 	 */
-	public Movement mover(char origenLetra, char origenNum,
+	public Movement move(char origenLetra, char origenNum,
 			char destinoLetra, char destinoNum) {
 		Piece piezaQueMueve;
 		int i;
@@ -530,7 +530,7 @@
 			return null;
 		}
 
-		if (Piece.esBandoContrario(posicion.getTurno(), piezaQueMueve)) {
+		if (Piece.esBandoContrario(posicion.getTurn(), piezaQueMueve)) {
 			return null;
 		}
 		if (indice != movimientos.getNumHalfPly())
@@ -556,39 +556,39 @@
 					mov
 							.setCasillaDestino(new Square(destinoLetra,
 									destinoNum));
-					mov.setNumeroMovimiento(posicion.getNumeroMovimiento());
-					mov.setBando(posicion.getTurno());
+					mov.setNumeroMovimiento(posicion.getFullmoveNumber());
+					mov.setBando(posicion.getTurn());
 					mov.setTipoPieza(piezaQueMueve.getTipo());
 
 					// Si se come ponemos el contador a 0
-					if (!posicion.esVacia(destinoLetra, destinoNum)) {
-						posicion.setContadorTablas(0);
+					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
+						posicion.setHalfmoveClock(0);
 						hash.borrarTabla();
 						mov.setCasillaComer(new Square(destinoLetra,
 								destinoNum));
 						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
 								destinoNum).getTipo());
-						posicion.borrarPieza(mov.getCasillaComer());
+						posicion.removePiece(mov.getCasillaComer());
 					}
 
 					// Se hacen los calculos especiales si se trata de un peon
 					if (piezaQueMueve.getTipo() == Tipo.PEON) {
 						// Se borra la pieza correspondiente si se come al paso
 						if (Math.abs(destinoLetra - origenLetra) == 1
-								&& posicion.esVacia(destinoLetra, destinoNum)) {
+								&& posicion.isEmpty(destinoLetra, destinoNum)) {
 							mov.setTipoPiezaComida(posicion.getPieza(
 									destinoLetra, origenNum).getTipo());
 							mov.setCasillaComer(new Square(destinoLetra,
 									origenNum));
-							posicion.borrarPieza(mov.getCasillaComer());
+							posicion.removePiece(mov.getCasillaComer());
 						}
 						// Se establece la variable alPaso a su valor
 						// correspondiente
 						if (Math.abs(destinoNum - origenNum) == 2) {
-							posicion.setAlPaso(origenLetra);
-							mov.setAlPaso(posicion.getAlPaso());
+							posicion.setEnPassant(origenLetra);
+							mov.setAlPaso(posicion.getEnPassant());
 						} else {
-							posicion.setAlPaso('\0');
+							posicion.setEnPassant('\0');
 						}
 						// Coronacion
 						if (destinoNum == '1' || destinoNum == '8') {
@@ -600,7 +600,7 @@
 
 							mov.setCoronacion(coronar);
 						}
-						posicion.setContadorTablas(0);
+						posicion.setHalfmoveClock(0);
 						hash.borrarTabla();
 					}
 					// Se hacen los calculos especiales si se trata de un rey
@@ -608,42 +608,42 @@
 						// Movemos las torres en caso de enroque
 						if ((destinoLetra - origenLetra) == 2) {
 							Piece torre = posicion.getPieza('h', origenNum);
-							posicion.borrarPieza('h', origenNum);
-							posicion.setPieza(torre, 'f', origenNum);
+							posicion.removePiece('h', origenNum);
+							posicion.setPiece(torre, 'f', origenNum);
 						} else {
 							if ((destinoLetra - origenLetra) == -2) {
 								Piece torre = posicion.getPieza('a', origenNum);
-								posicion.borrarPieza('a', origenNum);
-								posicion.setPieza(torre, 'd', origenNum);
+								posicion.removePiece('a', origenNum);
+								posicion.setPiece(torre, 'd', origenNum);
 							}
 						}
 					}
 
-					mov.setContadorTablas(posicion.getContadorTablas());
+					mov.setContadorTablas(posicion.getHalfmoveClock());
 					boolean[][] enroque = new boolean[2][2];
-					enroque[0][0] = posicion.getEnroqueCorto(Bando.BLANCO);
-					enroque[0][1] = posicion.getEnroqueLargo(Bando.BLANCO);
-					enroque[1][0] = posicion.getEnroqueCorto(Bando.NEGRO);
-					enroque[1][1] = posicion.getEnroqueLargo(Bando.NEGRO);
+					enroque[0][0] = posicion.getKingsideCastling(Side.WHITE);
+					enroque[0][1] = posicion.getQueensideCastling(Side.WHITE);
+					enroque[1][0] = posicion.getKingsideCastling(Side.BLACK);
+					enroque[1][1] = posicion.getQueensideCastling(Side.BLACK);
 					mov.setEnroque(enroque);
-					if (posicion.getTurno() == Bando.NEGRO)
-						posicion.addNumeroMovimiento();
-					posicion.setTurno();
+					if (posicion.getTurn() == Side.BLACK)
+						posicion.addFullmoveNumber();
+					posicion.setTurn();
 
-					posicion.borrarPieza(origenLetra, origenNum);
-					posicion.setPieza(piezaQueMueve, destinoLetra, destinoNum);
-					posicion.addContadorTablas();
-					calcularMovimientos();
+					posicion.removePiece(origenLetra, origenNum);
+					posicion.setPiece(piezaQueMueve, destinoLetra, destinoNum);
+					posicion.addHalfmoveClock();
+					calculateMoves();
 
-					if (esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))) {
+					if (isAttackedSquare(posicion.getKingPosition(posicion
+							.getTurn()))) {
 						mov.setJaque(true);
 					} else {
 						mov.setJaque(false);
 					}
 					mov.setFinPartida(esFinPartida());
 
-					hash.insertar(posicion.getClavePosicion());
+					hash.insertar(posicion.getPositionKey());
 					movimientos.appendMovimiento(mov);
 					indice++;
 					return mov;
@@ -661,7 +661,7 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Movement avanzar() {
+	public Movement goBack() {
 		Movement mov;
 		Piece piezaQueMueve;
 		if (indice < movimientos.getNumHalfPly()) {
@@ -671,8 +671,8 @@
 			if (piezaQueMueve.getTipo() == Tipo.PEON
 					&& Math.abs(mov.getCasillaDestino().getLetra()
 							- mov.getCasillaOrigen().getLetra()) == 1
-					&& posicion.esVacia(mov.getCasillaDestino())) {
-				posicion.borrarPieza(mov.getCasillaComer());
+					&& posicion.isEmpty(mov.getCasillaDestino())) {
+				posicion.removePiece(mov.getCasillaComer());
 			}
 			// Si se corona
 			if (mov.getCoronacion() != null) {
@@ -686,29 +686,29 @@
 				Square destino = mov.getCasillaDestino();
 				if ((destino.getLetra() - origen.getLetra()) == 2) {
 					Piece torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
+					posicion.removePiece('h', origen.getNumero());
+					posicion.setPiece(torre, 'f', origen.getNumero());
 				} else {
 					if ((destino.getLetra() - origen.getLetra()) == -2) {
 						Piece torre = posicion
 								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
+						posicion.removePiece('a', origen.getNumero());
+						posicion.setPiece(torre, 'd', origen.getNumero());
 					}
 				}
 			}
-			posicion.borrarPieza(mov.getCasillaOrigen());
-			posicion.setPieza(piezaQueMueve, mov.getCasillaDestino());
-			posicion.setContadorTablas(mov.getContadorTablas());
+			posicion.removePiece(mov.getCasillaOrigen());
+			posicion.setPiece(piezaQueMueve, mov.getCasillaDestino());
+			posicion.setHalfmoveClock(mov.getContadorTablas());
 			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
+			posicion.setKingsideCastling(Side.WHITE, enroques[0][0]);
+			posicion.setQueensideCastling(Side.WHITE, enroques[0][1]);
+			posicion.setKingsideCastling(Side.BLACK, enroques[1][0]);
+			posicion.setQueensideCastling(Side.BLACK, enroques[1][1]);
+			posicion.setEnPassant(mov.getAlPaso());
+			posicion.setTurn();
 			indice++;
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			posicion.setFullmoveNumber(mov.getNumeroMovimiento());
 			return mov;
 		} else {
 			return null;
@@ -720,13 +720,13 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Movement retroceder() {
+	public Movement goForward() {
 		Movement mov;
 		Piece piezaQueMueve;
 		if (indice > 0) {
 			indice--;
 			mov = movimientos.getMovimiento(indice);
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			posicion.setFullmoveNumber(mov.getNumeroMovimiento());
 			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
 			if (mov.getCoronacion() != null) {
 				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
@@ -738,33 +738,33 @@
 				Square destino = mov.getCasillaDestino();
 				if ((destino.getLetra() - origen.getLetra()) == 2) {
 					Piece torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
+					posicion.removePiece('h', origen.getNumero());
+					posicion.setPiece(torre, 'f', origen.getNumero());
 				} else {
 					if ((destino.getLetra() - origen.getLetra()) == -2) {
 						Piece torre = posicion
 								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
+						posicion.removePiece('a', origen.getNumero());
+						posicion.setPiece(torre, 'd', origen.getNumero());
 					}
 				}
 			}
-			posicion.borrarPieza(mov.getCasillaDestino());
+			posicion.removePiece(mov.getCasillaDestino());
 			if (mov.getTipoPiezaComida() != null) {
-				posicion.setPieza(new Piece(
-						piezaQueMueve.getBando() == Bando.BLANCO ? Bando.BLANCO
-								: Bando.NEGRO, mov.getTipoPieza()), mov
+				posicion.setPiece(new Piece(
+						piezaQueMueve.getBando() == Side.WHITE ? Side.WHITE
+								: Side.BLACK, mov.getTipoPieza()), mov
 						.getCasillaComer());
 			}
-			posicion.setPieza(piezaQueMueve, mov.getCasillaOrigen());
-			posicion.setContadorTablas(mov.getContadorTablas());
+			posicion.setPiece(piezaQueMueve, mov.getCasillaOrigen());
+			posicion.setHalfmoveClock(mov.getContadorTablas());
 			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
+			posicion.setKingsideCastling(Side.WHITE, enroques[0][0]);
+			posicion.setQueensideCastling(Side.WHITE, enroques[0][1]);
+			posicion.setKingsideCastling(Side.BLACK, enroques[1][0]);
+			posicion.setQueensideCastling(Side.BLACK, enroques[1][1]);
+			posicion.setEnPassant(mov.getAlPaso());
+			posicion.setTurn();
 			return mov;
 		} else {
 			return null;
@@ -779,20 +779,20 @@
 	 *         han dado jaque mate, 'N' si las negras han dado jaque mate o 'T'
 	 *         si se produce una situacion de tablas.
 	 */
-	private Resultado esFinPartida() {
+	private Result esFinPartida() {
 		Piece pieza;
-		Resultado devolver = null;
+		Result devolver = null;
 		boolean fin = false, fin2 = false, posibleMatInsuf = false;
 		char i, j;
 		// Tablas por 50 movimientos
-		if (posicion.getContadorTablas() == 50) {
+		if (posicion.getHalfmoveClock() == 50) {
 			fin = true;
-			devolver = Resultado.TABLAS_50_MOV;
+			devolver = Result.FIFTY_MOV_DRAW;
 		}
 		// Tablas por repeticion de posiciones
-		if (hash.getRepeticiones(posicion.getClavePosicion()) == 3) {
+		if (hash.getRepeticiones(posicion.getPositionKey()) == 3) {
 			fin = true;
-			devolver = Resultado.TABLAS_REPETICION;
+			devolver = Result.REPETITION_DRAW;
 		}
 		// Tablas por material insuficiente
 		i = 'a';
@@ -828,7 +828,7 @@
 		}
 		if (!fin2) {
 			fin = true;
-			devolver = Resultado.TABLAS_INSUF_MATERIAL;
+			devolver = Result.INSUF_MATERIAL_DRAW;
 		}
 		// Miramos si hay movimientos posibles
 		i = 'a';
@@ -837,7 +837,7 @@
 			while (j <= '8' && !fin) {
 				pieza = posicion.getPieza(i, j);
 				if ((pieza != null)
-						&& (!Piece.esBandoContrario(posicion.getTurno(), pieza))
+						&& (!Piece.esBandoContrario(posicion.getTurn(), pieza))
 						&& (!pieza.getCasillasValidas().isEmpty())) {
 					fin = true;
 				}
@@ -848,20 +848,20 @@
 		}
 		if (!fin) {
 			// Negras dan jaque mate
-			if (posicion.getTurno() == Bando.BLANCO)
-				if (esCasillaAtacada(posicion.getKingPosition(Bando.BLANCO))) {
-					devolver = Resultado.JAQUE_MATE_NEGRO;
+			if (posicion.getTurn() == Side.WHITE)
+				if (isAttackedSquare(posicion.getKingPosition(Side.WHITE))) {
+					devolver = Result.BLACK_CHECKMATE;
 				} else {
-					devolver = Resultado.TABLAS_AHOGADO;
+					devolver = Result.STALEMATE;
 				}
 			else
 			// Blancas dan jaque mate
-			if (esCasillaAtacada(posicion.getKingPosition(Bando.NEGRO))) {
-				devolver = Resultado.JAQUE_MATE_BLANCO;
+			if (isAttackedSquare(posicion.getKingPosition(Side.BLACK))) {
+				devolver = Result.WHITE_CHECKMATE;
 			}
 			// Tablas por ahogado
 			else {
-				devolver = Resultado.TABLAS_AHOGADO;
+				devolver = Result.STALEMATE;
 			}
 		}
 		return devolver;
@@ -880,7 +880,7 @@
 	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
 	 *       tenerlo en cuenta.
 	 */
-	public Movement moverALG(String mov) {
+	public Movement moveALG(String mov) {
 		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
 		char tipoPieza = 'P';
 		Tipo piezaCoronacion = null;
@@ -974,7 +974,7 @@
 		if (contadorOesEnroque == 2) {
 			origenLetra = 'e';
 			destinoLetra = 'g';
-			if (posicion.getTurno() == Bando.BLANCO) {
+			if (posicion.getTurn() == Side.WHITE) {
 				origenNum = '1';
 				destinoNum = '1';
 			} else { // turno == NEGRO
@@ -984,7 +984,7 @@
 		} else if (contadorOesEnroque == 3) {
 			origenLetra = 'e';
 			destinoLetra = 'c';
-			if (posicion.getTurno() == Bando.BLANCO) {
+			if (posicion.getTurn() == Side.WHITE) {
 				origenNum = '1';
 				destinoNum = '1';
 			} else { // turno == NEGRO
@@ -1027,7 +1027,7 @@
 					+ " " + destinoLetra + " " + destinoNum);
 			return null;
 		} else {
-			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
+			return move(origenLetra, origenNum, destinoLetra, destinoNum);
 		}
 	}
 }

Modified: trunk/MihailChessLib/com/mihail/chess/Board2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -16,7 +16,7 @@
 import javax.swing.JOptionPane;
 import javax.swing.JPanel;
 
-import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Board.Side;
 import com.mihail.chess.Piece.Tipo;
 
 /**
@@ -182,8 +182,8 @@
 				// casillas blancas o negras
 				// if (activado) {
 				int v = (i + j) % 2;
-				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
-						: Bando.NEGRO);
+				Image textura = theme.getImageCasilla(v == 0 ? Side.WHITE
+						: Side.BLACK);
 				if (textura != null)
 
 					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
@@ -383,7 +383,7 @@
 	 *            El tipo de las casillas, blancas o negras.
 	 * @return El color liso.
 	 */
-	public Color getColorLiso(Bando b) {
+	public Color getColorLiso(Side b) {
 		return colorLiso[bandoToInt(b)];
 	}
 
@@ -398,7 +398,7 @@
 	 *            El color liso.
 	 */
 
-	public void setColorLiso(Bando b, Color colorLiso) {
+	public void setColorLiso(Side b, Color colorLiso) {
 		this.colorLiso[bandoToInt(b)] = colorLiso;
 	}
 
@@ -414,17 +414,17 @@
 	}
 	
 	public void setPieza(Piece pieza, Square casilla) {
-		tablero.setPieza(pieza, casilla);
+		tablero.setPiece(pieza, casilla);
 		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
 	}
 	
 	public void borrarPieza(Square casilla) {
-		tablero.borrarPieza(casilla);
+		tablero.removePiece(casilla);
 		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
 	}
 	
 	public void setFEN(String pos) {
-		tablero.setPosicion(pos);
+		tablero.setFEN(pos);
 		repaint();
 	}
 
@@ -501,8 +501,8 @@
 		}
 	}
 
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO) {
+	private int bandoToInt(Side b) {
+		if (b == Side.WHITE) {
 			return 0;
 		}
 		return 1;
@@ -553,7 +553,7 @@
 		MediaTracker media = new MediaTracker(this);
 		for (int i = 0; i < 2; i++) {
 			for (int j = 0; j < 6; j++) {
-				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
+				piezas[i][j] = theme.getImagePiece(i==0?Side.WHITE:Side.BLACK, intToTipo(j))
 						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
 				media.addImage(piezas[i][j], 1);
 			}

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -13,7 +13,7 @@
 
 import javax.swing.ImageIcon;
 
-import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Board.Side;
 import com.mihail.chess.Piece.Tipo;
 
 /**
@@ -94,11 +94,11 @@
 		}
 	}
 	
-	public Image getImagePiece(Bando bando, Tipo tipo) {
+	public Image getImagePiece(Side bando, Tipo tipo) {
 		return pieceImages[bandoToInt(bando)][tipoToInt(tipo)];
 	}
 	
-	public Image getImageCasilla(Bando bando) {
+	public Image getImageCasilla(Side bando) {
 		return casillasImages[bandoToInt(bando)];
 	}
 	
@@ -110,8 +110,8 @@
 		return background;
 	}
 	
-	private int bandoToInt(Bando bando) {
-		return bando == Bando.BLANCO? 0:1;
+	private int bandoToInt(Side bando) {
+		return bando == Side.WHITE? 0:1;
 	}
 	
 	private int tipoToInt(Tipo tipo) {

Modified: trunk/MihailChessLib/com/mihail/chess/Movement.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -1,8 +1,8 @@
 package com.mihail.chess;
 
-import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Board.Side;
 
-import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Board.Result;
 import com.mihail.chess.Piece.Tipo;
 
 /**
@@ -46,7 +46,7 @@
 	/**
 	 * Bando que mueve.
 	 */
-	private Bando bando;
+	private Side bando;
 
 	/**
 	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
@@ -79,7 +79,7 @@
 	 * 'T' -> Tablas <BR>
 	 * 0 -> No ha terminado la partida
 	 */
-	private Resultado finPartida;
+	private Result finPartida;
 
 	/**
 	 * Este atributo indica si se ha producido una coronacion y a que pieza se
@@ -143,11 +143,11 @@
 		this.casillaOrigen = casillaOrigen;
 	}
 
-	public Bando getBando() {
+	public Side getBando() {
 		return bando;
 	}
 
-	public void setBando(Bando bando) {
+	public void setBando(Side bando) {
 		this.bando = bando;
 	}
 
@@ -199,11 +199,11 @@
 		this.enroque = enroque;
 	}
 
-	public Resultado getFinPartida() {
+	public Result getFinPartida() {
 		return finPartida;
 	}
 
-	public void setFinPartida(Resultado finPartida) {
+	public void setFinPartida(Result finPartida) {
 		this.finPartida = finPartida;
 	}
 

Modified: trunk/MihailChessLib/com/mihail/chess/Piece.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -2,7 +2,7 @@
 
 import java.util.*;
 
-import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Board.Side;
 
 /**
  * Esta clase define un objeto Pieza y sus caracteristicas: bando, tipo de pieza
@@ -26,7 +26,7 @@
 	 * Este atributo indica el bando de la pieza (blanco o negro): true -> bando
 	 * blanco false -> bando negro
 	 */
-	private Bando bando;
+	private Side bando;
 
 	/**
 	 * Este atributo indica el tipo de pieza que es: <BR>
@@ -63,14 +63,14 @@
 	 *            Es el tipo de la pieza {P,C,A,T,D,R}
 	 * @see #tipo
 	 */
-	public Piece(Bando ban, Tipo claseDePieza) {
+	public Piece(Side ban, Tipo claseDePieza) {
 		bando = ban;
 		tipo = claseDePieza;
 		casilla = new Square();
 		switch (tipo) {
 		case PEON:
 			direcciones = new DirectionVector[1];
-			if (bando == Bando.BLANCO)
+			if (bando == Side.WHITE)
 				direcciones[0] = new DirectionVector(0, 1);
 			else
 				direcciones[0] = new DirectionVector(0, -1);
@@ -157,7 +157,7 @@
 	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
 	 *         mover, false si es del mismo bando
 	 */
-	public final static boolean esBandoContrario(Bando turno, Piece pieza) {
+	public final static boolean esBandoContrario(Side turno, Piece pieza) {
 		return turno != pieza.bando;
 	}
 
@@ -177,7 +177,7 @@
 		this.casillasValidas.add(c);
 	}
 
-	public Bando getBando() {
+	public Side getBando() {
 		return bando;
 	}
 

Modified: trunk/MihailChessLib/com/mihail/chess/Position.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -1,9 +1,9 @@
 package com.mihail.chess;
 
-import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Board.Side;
 import static com.mihail.chess.Piece.Tipo;
 
-import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Board.Result;
 import com.mihail.chess.Piece.Tipo;
 
 public class Position {
@@ -20,7 +20,7 @@
 	 * Constante que representa la cadena FEN con la posici?n inicial en el
 	 * tablero.
 	 */
-	public final static String CAD_INICIAL = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
+	public final static String INITIAL_POSITION_FEN = "rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1";
 
 	/**
 	 * Este atributo es la representacion del tablero en la logica del programa.
@@ -34,7 +34,7 @@
 	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
 	 * blancas y NEGRO cuando mueven negras.
 	 */
-	private Bando turno;
+	private Side turno;
 
 	/**
 	 * Este atributo indica el numero de movimiento por el que va la partida.
@@ -104,7 +104,7 @@
 				}
 			}
 		}
-		turno = Bando.BLANCO;
+		turno = Side.WHITE;
 		kingPosition[0] = new Square();
 		kingPosition[1] = new Square();
 		enroque[0][0] = false;
@@ -119,7 +119,7 @@
 
 	public Position(String posicion) {
 		this();
-		setPosicion(posicion);
+		setFEN(posicion);
 	}
 
 	/**
@@ -163,8 +163,8 @@
 	 *            Es el booleano en cuestion.
 	 * @return 0 si el turno es blanco y 1 si el turno es negro
 	 */
-	private final static int bandoToInt(Bando c) {
-		if (c == Bando.BLANCO) {
+	private final static int bandoToInt(Side c) {
+		if (c == Side.WHITE) {
 			return 0;
 		}
 		return 1;
@@ -220,7 +220,7 @@
 				else {
 					if (cont > 0)
 						cad += cont;
-					if (p.getBando() == Bando.BLANCO)
+					if (p.getBando() == Side.WHITE)
 						cad += tipoToEnglish(p.getTipo());
 					else
 						cad += (Character
@@ -235,7 +235,7 @@
 			cont = 0;
 		}
 
-		if (turno == Bando.BLANCO)
+		if (turno == Side.WHITE)
 			cad += " w";
 		else
 			cad += " b";
@@ -271,7 +271,7 @@
 	 *            estandar FEN.
 	 * @see getFEN()
 	 */
-	public void setPosicion(String pos) {
+	public void setFEN(String pos) {
 		char let = 'a';
 		char num = '8';
 		for (int i = 0; i < 8; i++) {
@@ -287,51 +287,51 @@
 		for (int i = 0; i < FEN[0].length(); i++) {
 			switch (FEN[0].charAt(i)) {
 			case 'P':
-				setPieza(new Piece(Bando.BLANCO, Tipo.PEON), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.PEON), let, num);
 				let++;
 				break;
 			case 'p':
-				setPieza(new Piece(Bando.NEGRO, Tipo.PEON), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.PEON), let, num);
 				let++;
 				break;
 			case 'N':
-				setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.CABALLO), let, num);
 				let++;
 				break;
 			case 'n':
-				setPieza(new Piece(Bando.NEGRO, Tipo.CABALLO), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.CABALLO), let, num);
 				let++;
 				break;
 			case 'B':
-				setPieza(new Piece(Bando.BLANCO, Tipo.ALFIL), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.ALFIL), let, num);
 				let++;
 				break;
 			case 'b':
-				setPieza(new Piece(Bando.NEGRO, Tipo.ALFIL), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.ALFIL), let, num);
 				let++;
 				break;
 			case 'R':
-				setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.TORRE), let, num);
 				let++;
 				break;
 			case 'r':
-				setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.TORRE), let, num);
 				let++;
 				break;
 			case 'Q':
-				setPieza(new Piece(Bando.BLANCO, Tipo.DAMA), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.DAMA), let, num);
 				let++;
 				break;
 			case 'q':
-				setPieza(new Piece(Bando.NEGRO, Tipo.DAMA), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.DAMA), let, num);
 				let++;
 				break;
 			case 'K':
-				setPieza(new Piece(Bando.BLANCO, Tipo.REY), let, num);
+				setPiece(new Piece(Side.WHITE, Tipo.REY), let, num);
 				let++;
 				break;
 			case 'k':
-				setPieza(new Piece(Bando.NEGRO, Tipo.REY), let, num);
+				setPiece(new Piece(Side.BLACK, Tipo.REY), let, num);
 				let++;
 				break;
 			case '/':
@@ -352,9 +352,9 @@
 			}
 		}
 		if (FEN[1].charAt(0) == 'w') {
-			setTurno(Bando.BLANCO);
+			setTurn(Side.WHITE);
 		} else {
-			setTurno(Bando.NEGRO);
+			setTurn(Side.BLACK);
 		}
 		for (int i = 0; i <= 1; i++) {
 			for (int j = 0; j <= 1; j++) {
@@ -365,41 +365,31 @@
 			for (int i = 0; i < FEN[2].length(); i++) {
 				switch (FEN[2].charAt(i)) {
 				case 'K':
-					setEnroqueCorto(Bando.BLANCO, true);
+					setKingsideCastling(Side.WHITE, true);
 					break;
 				case 'Q':
-					setEnroqueLargo(Bando.BLANCO, true);
+					setQueensideCastling(Side.WHITE, true);
 					break;
 				case 'k':
-					setEnroqueCorto(Bando.NEGRO, true);
+					setKingsideCastling(Side.BLACK, true);
 					break;
 				case 'q':
-					setEnroqueLargo(Bando.NEGRO, true);
+					setQueensideCastling(Side.BLACK, true);
 					break;
 				}
 			}
 
 		}
 		if (FEN[3].charAt(0) == '-') {
-			setAlPaso('\0');
+			setEnPassant('\0');
 		} else {
-			setAlPaso(FEN[3].charAt(0));
+			setEnPassant(FEN[3].charAt(0));
 		}
-		setContadorTablas((new Integer(FEN[4])).intValue());
-		setNumeroMovimiento((new Integer(FEN[5])).intValue());
+		setHalfmoveClock((new Integer(FEN[4])).intValue());
+		setFullmoveNumber((new Integer(FEN[5])).intValue());
 	}
 
 	/**
-	 * Permite saber el numero de movimiento actual.
-	 * 
-	 * @return Un entero, el numero en cuestion.
-	 */
-
-	public int getNumMovimiento() {
-		return numeroMovimiento;
-	}
-
-	/**
 	 * Permite saber si el enroque corto esta disponible para un bando.
 	 * 
 	 * @param c
@@ -407,11 +397,11 @@
 	 * @return True si el enroque corto puede realizarse, false en caso
 	 *         contrario.
 	 */
-	public boolean getEnroqueCorto(Bando c) {
+	public boolean getKingsideCastling(Side c) {
 		switch (c) {
-		case BLANCO:
+		case WHITE:
 			return enroque[0][0];
-		case NEGRO:
+		case BLACK:
 			return enroque[1][0];
 		}
 		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
@@ -426,11 +416,11 @@
 	 * @return True si el enroque largo puede realizarse, false en caso
 	 *         contrario.
 	 */
-	public boolean getEnroqueLargo(Bando c) {
+	public boolean getQueensideCastling(Side c) {
 		switch (c) {
-		case BLANCO:
+		case WHITE:
 			return enroque[0][1];
-		case NEGRO:
+		case BLACK:
 			return enroque[1][1];
 		}
 		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
@@ -461,7 +451,7 @@
 	 * 
 	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
 	 */
-	public Bando getTurno() {
+	public Side getTurn() {
 		return turno;
 	}
 
@@ -469,11 +459,11 @@
 	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
 	 * viceversa.
 	 */
-	public void setTurno() {
-		if (turno == Bando.BLANCO) {
-			turno = Bando.NEGRO;
+	public void setTurn() {
+		if (turno == Side.WHITE) {
+			turno = Side.BLACK;
 		} else {
-			turno = Bando.BLANCO;
+			turno = Side.WHITE;
 		}
 	}
 
@@ -484,18 +474,18 @@
 	 *            BLANCO -> blancas <BR>
 	 *            NEGRO -> negras
 	 */
-	public void setTurno(Bando t) {
+	public void setTurn(Side t) {
 		turno = t;
 	}
 
-	public boolean setEnroqueCorto(Bando b, boolean c) {
+	public boolean setKingsideCastling(Side b, boolean c) {
 		if (!c) {
 			int x;
 			switch (b) {
-			case BLANCO:
+			case WHITE:
 				x = 0;
 				break;
-			case NEGRO:
+			case BLACK:
 				x = 1;
 				break;
 			default:
@@ -505,23 +495,23 @@
 			enroque[x][0] = c;
 			return true;
 		}
-		if (b == Bando.BLANCO) {
+		if (b == Side.WHITE) {
 			Piece p = getPieza('h', '1');
 			if (p != null
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getNumero() == '1'
-					&& p.getBando() == Bando.BLANCO
+					&& kingPosition[bandoToInt(Side.WHITE)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Side.WHITE)].getNumero() == '1'
+					&& p.getBando() == Side.WHITE
 					&& p.getTipo() == Tipo.TORRE) {
 				enroque[0][0] = c;
 				return true;
 			} else
 				return false;
-		} else if (b == Bando.NEGRO) {
+		} else if (b == Side.BLACK) {
 			Piece p = getPieza('h', '8');
 			if (p != null
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.BLACK)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Side.BLACK)].getNumero() == '8'
+					&& p.getBando() == Side.BLACK && p.getTipo() == Tipo.TORRE) {
 				enroque[1][0] = c;
 				return true;
 			} else
@@ -530,14 +520,14 @@
 		return false;
 	}
 
-	public boolean setEnroqueLargo(Bando b, boolean c) {
+	public boolean setQueensideCastling(Side b, boolean c) {
 		if (!c) {
 			int x;
 			switch (b) {
-			case BLANCO:
+			case WHITE:
 				x = 0;
 				break;
-			case NEGRO:
+			case BLACK:
 				x = 1;
 				break;
 			default:
@@ -547,23 +537,23 @@
 			enroque[x][1] = c;
 			return true;
 		}
-		if (b == Bando.BLANCO) {
+		if (b == Side.WHITE) {
 			Piece p = getPieza('a', '1');
 			if (p != null
-					&& kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Side.WHITE)].getLetra() == 'e'
 					&& kingPosition[0].getNumero() == '1'
-					&& p.getBando() == Bando.BLANCO
+					&& p.getBando() == Side.WHITE
 					&& p.getTipo() == Tipo.TORRE) {
 				enroque[0][1] = c;
 				return true;
 			} else
 				return false;
-		} else if (b == Bando.NEGRO) {
+		} else if (b == Side.BLACK) {
 			Piece p = getPieza('a', '8');
 			if (p != null
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&& p.getBando() == Bando.NEGRO && p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.BLACK)].getLetra() == 'e'
+					&& kingPosition[bandoToInt(Side.BLACK)].getNumero() == '8'
+					&& p.getBando() == Side.BLACK && p.getTipo() == Tipo.TORRE) {
 				enroque[1][1] = c;
 				return true;
 			} else
@@ -575,7 +565,7 @@
 	/**
 	 * @return Devuelve numeroMovimiento.
 	 */
-	public int getNumeroMovimiento() {
+	public int getFullmoveNumber() {
 		return numeroMovimiento;
 	}
 
@@ -591,7 +581,7 @@
 	 * @param num
 	 *            Es el numero de la casilla
 	 */
-	public void setPieza(Piece pieza, char letra, char num) {
+	public void setPiece(Piece pieza, char letra, char num) {
 		pieza.setLetra(letra);
 		pieza.setNum(num);
 		tabla[num - '1'][letra - 'a'] = pieza;
@@ -604,12 +594,12 @@
 		}
 	}
 	
-	public void setPieza(Piece pieza, Square casilla) {
-		setPieza(pieza, casilla.getLetra(), casilla.getNumero());
+	public void setPiece(Piece pieza, Square casilla) {
+		setPiece(pieza, casilla.getLetra(), casilla.getNumero());
 	}
 
-	public void borrarPieza(Square casilla) {
-		borrarPieza(casilla.getLetra(), casilla.getNumero());
+	public void removePiece(Square casilla) {
+		removePiece(casilla.getLetra(), casilla.getNumero());
 	}
 
 	/**
@@ -622,41 +612,41 @@
 	 * @param num
 	 *            Es el numero de la casilla
 	 */
-	public void borrarPieza(char letra, char num) {
+	public void removePiece(char letra, char num) {
 		int iNum = num - '1', iLetra = letra - 'a';
 		Piece p = tabla[iNum][iLetra];
 		// Se actualiza el estado de los enroques en caso de que se borre un rey
 		// o una torre
 		if (p != null) {
 			if (p.getTipo() == Tipo.REY) {
-				if (p.getBando() == Bando.BLANCO) {
+				if (p.getBando() == Side.WHITE) {
 					enroque[0][0] = false;
 					enroque[0][1] = false;
-					kingPosition[bandoToInt(Bando.BLANCO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.BLANCO)].setNumero('\0');
+					kingPosition[bandoToInt(Side.WHITE)].setLetra('\0');
+					kingPosition[bandoToInt(Side.WHITE)].setNumero('\0');
 				} else {
 					enroque[1][0] = false;
 					enroque[1][1] = false;
-					kingPosition[bandoToInt(Bando.NEGRO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.NEGRO)].setNumero('\0');
+					kingPosition[bandoToInt(Side.BLACK)].setLetra('\0');
+					kingPosition[bandoToInt(Side.BLACK)].setNumero('\0');
 				}
 			} else if (p.getTipo() == Tipo.TORRE) {
 				if (p.getLetra() == 'a' && p.getNum() == '1'
-						&& p.getBando() == Bando.BLANCO)
+						&& p.getBando() == Side.WHITE)
 					enroque[0][1] = false;
 				else if (p.getLetra() == 'h' && p.getNum() == '1'
-						&& p.getBando() == Bando.BLANCO)
+						&& p.getBando() == Side.WHITE)
 					enroque[0][0] = false;
 				else if (p.getLetra() == 'a' && p.getNum() == '8'
-						&& p.getBando() == Bando.NEGRO)
+						&& p.getBando() == Side.BLACK)
 					enroque[1][1] = false;
 				else if (p.getLetra() == 'h' && p.getNum() == '8'
-						&& p.getBando() == Bando.NEGRO)
+						&& p.getBando() == Side.BLACK)
 					enroque[1][0] = false;
 			} else if (p.getTipo() == Tipo.PEON) {
 				if (letra == alPaso
-						&& (p.getBando() == Bando.BLANCO && num == '4')
-						|| (p.getBando() == Bando.NEGRO && num == '5'))
+						&& (p.getBando() == Side.WHITE && num == '4')
+						|| (p.getBando() == Side.BLACK && num == '5'))
 					alPaso = 0;
 			}
 			clavePosicion = clavePosicion
@@ -665,8 +655,8 @@
 		}
 	}
 	
-	public boolean esVacia(Square c) {
-		return esVacia(c.getLetra(), c.getNumero());
+	public boolean isEmpty(Square c) {
+		return isEmpty(c.getLetra(), c.getNumero());
 	}
 
 	/**
@@ -675,7 +665,7 @@
 	 * @return Devuelve true si la casilla esta vacia (contiene null), false en
 	 *         caso contrario.
 	 */
-	public boolean esVacia(char let, char num) {
+	public boolean isEmpty(char let, char num) {
 		return (getPieza(let, num) == null);
 	}
 
@@ -684,14 +674,14 @@
 	 * 
 	 * @return Un entero, la clave en cuestion.
 	 */
-	public int getClavePosicion() {
+	public int getPositionKey() {
 		return clavePosicion;
 	}
 
 	/**
 	 * @return Returns the alPaso.
 	 */
-	public char getAlPaso() {
+	public char getEnPassant() {
 		return alPaso;
 	}
 
@@ -705,20 +695,20 @@
 	 *            La columna en la qeu se puede comer al paso. Se indica con la
 	 *            letra de la columna.
 	 */
-	public void setAlPaso(char alPaso) {
+	public void setEnPassant(char alPaso) {
 		if (alPaso == '\0') {
 			this.alPaso = alPaso;
 			return;
 		}
 		boolean encontrado = false;
 		Piece p;
-		if (this.turno == Bando.NEGRO) {
+		if (this.turno == Side.BLACK) {
 			p = getPieza(alPaso, '4');
-			encontrado = p != null && p.getBando() == Bando.BLANCO
+			encontrado = p != null && p.getBando() == Side.WHITE
 					&& p.getTipo() == Tipo.PEON;
 		} else {
 			p = getPieza(alPaso, '5');
-			encontrado = p != null && p.getBando() == Bando.NEGRO
+			encontrado = p != null && p.getBando() == Side.BLACK
 					&& p.getTipo() == Tipo.PEON;
 		}
 		if (encontrado)
@@ -728,7 +718,7 @@
 	/**
 	 * @return Returns the contadorTablas.
 	 */
-	public int getContadorTablas() {
+	public int getHalfmoveClock() {
 		return contadorTablas;
 	}
 
@@ -736,11 +726,11 @@
 	 * @param contadorTablas
 	 *            The contadorTablas to set.
 	 */
-	public void setContadorTablas(int contadorTablas) {
+	public void setHalfmoveClock(int contadorTablas) {
 		this.contadorTablas = contadorTablas;
 	}
 
-	public void addContadorTablas() {
+	public void addHalfmoveClock() {
 		this.contadorTablas++;
 	}
 
@@ -748,18 +738,18 @@
 	 * @param numeroMovimiento
 	 *            The numeroMovimiento to set.
 	 */
-	public void setNumeroMovimiento(int numeroMovimiento) {
+	public void setFullmoveNumber(int numeroMovimiento) {
 		this.numeroMovimiento = numeroMovimiento;
 	}
 
-	public void addNumeroMovimiento() {
+	public void addFullmoveNumber() {
 		this.numeroMovimiento++;
 	}
 
 	/**
 	 * @return Returns the kingPosition.
 	 */
-	public Square getKingPosition(Bando color) {
+	public Square getKingPosition(Side color) {
 		return kingPosition[bandoToInt(color)];
 	}
 	
@@ -846,8 +836,8 @@
 			temp.append ("=" + tipoToEnglish (mov.getCoronacion()));
 
 		if (mov.isJaque())
-			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
-					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
+			if (mov.getFinPartida() == Result.WHITE_CHECKMATE
+					|| mov.getFinPartida() == Result.BLACK_CHECKMATE)
 				temp.append ("#");
 			else
 				temp.append ("+");

Modified: trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 12:37:18 UTC (rev 34)
+++ trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 13:12:03 UTC (rev 35)
@@ -4,7 +4,7 @@
 import java.util.ArrayList;
 import java.util.List;
 
-import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Board.Side;
 
 /**
  * @author Wotan
@@ -64,7 +64,7 @@
 	 *            Numero del movimiento
 	 * @return Devuelve el movimiento correspondiente a color y numero
 	 */
-	public Movement getMovimiento(Bando color, int numero) {
+	public Movement getMovimiento(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 		if (n != null)
 			return n.movimiento;
@@ -85,7 +85,7 @@
 	 * @return Un booleano que indica si para ese movimiento existen
 	 *         alternativas.
 	 */
-	public boolean existeVariante(Bando color, int numero) {
+	public boolean existeVariante(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n != null && n.variantes != null)
@@ -102,7 +102,7 @@
 	 *            Numero del movimiento.
 	 * @return El numero de alternativas a un movimiento.
 	 */
-	public int getNumVariantes(Bando color, int numero) {
+	public int getNumVariantes(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n != null) {
@@ -112,14 +112,14 @@
 		return 0;
 	}
 
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO)
+	private int bandoToInt(Side b) {
+		if (b == Side.WHITE)
 			return 0;
 		return 1;
 	}
 
 	// Funcion de utilidad.
-	private NodoArbol getNodo(Bando color, int numero) {
+	private NodoArbol getNodo(Side color, int numero) {
 		int indice = (numero - 1) * 2 + bandoToInt(color);
 		if (indice < arbol.size())
 			return arbol.get(indice);
@@ -136,14 +136,14 @@
 	 * @param numero
 	 *            Numero del movimiento.
 	 */
-	public void addVariante(Movement mov, Bando color, int numero) {
+	public void addVariante(Movement mov, Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n.variantes == null)
 			n.variantes = new ArrayList<VariationsTree>();
 
 		VariationsTree a = new VariationsTree(numero);
-		if (color == Bando.NEGRO) // Cada arbol de variantes debe empezar con un movimiento de blancas
+		if (color == Side.BLACK) // Cada arbol de variantes debe empezar con un movimiento de blancas
 			a.appendMovimiento(new Movement());
 		a.appendMovimiento(mov);
 
@@ -159,7 +159,7 @@
 	 *            Numero de variante que se quiere obtener.
 	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
 	 */
-	public VariationsTree getVariante(Bando color, int numero, int num) {
+	public VariationsTree getVariante(Side color, int numero, int num) {
 		NodoArbol n = getNodo(color, numero);
 		if (n != null)
 			return n.variantes.get(num);
@@ -204,7 +204,7 @@
 	 * @param num
 	 */
 	
-	public void promoteVariant(Bando color, int numero, int num) {
+	public void promoteVariant(Side color, int numero, int num) {
 		VariationsTree a = getVariante(color, numero, num);
 		int indice = (numero - 1) * 2 + bandoToInt(color);
 		NodoArbol n = getNodo(color, numero);



From gauleng at berlios.de  Sun Aug 14 15:30:00 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sun, 14 Aug 2005 15:30:00 +0200
Subject: [Mihailchess-svn] r36 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508141330.j7EDU0Bt003239@sheep.berlios.de>

Author: gauleng
Date: 2005-08-14 15:30:00 +0200 (Sun, 14 Aug 2005)
New Revision: 36

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Board2D.java
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/chess/DirectionVector.java
   trunk/MihailChessLib/com/mihail/chess/Movement.java
   trunk/MihailChessLib/com/mihail/chess/Piece.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
   trunk/MihailChessLib/com/mihail/chess/Square.java
   trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
Log:
More translations

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -2,7 +2,7 @@
 
 import java.util.ArrayList;
 
-import com.mihail.chess.Piece.Tipo;
+import com.mihail.chess.Piece.Type;
 
 public class Board {
 
@@ -40,7 +40,7 @@
 	/**
 	 * Este atributo se utiliza para las coronaciones.
 	 */
-	private Tipo coronar = Tipo.DAMA;
+	private Type coronar = Type.QUEEN;
 
 	/**
 	 * Tabla hash usada para comprobar posiciones repetidas.
@@ -80,7 +80,7 @@
 	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
 	 */
 
-	public void setPromotionPiece(Tipo c) {
+	public void setPromotionPiece(Type c) {
 		coronar = c;
 	}
 
@@ -91,7 +91,7 @@
 	 */
 
 	public int getTotalFullmoveNumber() {
-		return movimientos.getNumMovimientos();
+		return movimientos.getFullmoveNumber();
 	}
 
 	public Position getPosition() {
@@ -108,7 +108,7 @@
 	 *         '\0' -> Partida Inacabada o Resultado Desconocido
 	 */
 	public Result getResult() {
-		return movimientos.getLastMovimiento().getFinPartida();
+		return movimientos.getLastMove().getFinPartida();
 	}
 
 	/**
@@ -119,7 +119,7 @@
 			for (char j = '1'; j <= '8'; j++) {
 				Piece p = posicion.getPieza(i, j);
 				if (p != null) {
-					if (!Piece.esBandoContrario(posicion.getTurn(), p)) {
+					if (!Piece.isOppositeSide(posicion.getTurn(), p)) {
 						calcularMovimientos(p);
 					}
 				}
@@ -136,60 +136,60 @@
 	 */
 	private void calcularMovimientos(Piece pieza) {
 		pieza.getCasillasValidas().clear();
-		switch (pieza.getTipo()) {
-		case PEON:
+		switch (pieza.getType()) {
+		case PAWN:
 			// Peon
 			// Peon blanco
-			if (pieza.getBando() == Side.WHITE) {
+			if (pieza.getSide() == Side.WHITE) {
 				// Movimiento hacia delante
 				// Hacemos dos iteraciones, una para el caso de que avance
 				// una casilla, otra para el caso de que avance dos
-				if (posicion.isEmpty(pieza.getLetra(),
-						(char) (pieza.getNum() + 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() + 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() + 1));
-						if (pieza.getNum() == '2'
-								&& posicion.isEmpty(pieza.getLetra(),
-										(char) (pieza.getNum() + 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() + 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() + 2));
+				if (posicion.isEmpty(pieza.getFile(),
+						(char) (pieza.getRank() + 1))) {
+					if (esLegal(pieza.getFile(), pieza.getRank(), pieza
+							.getFile(), (char) (pieza.getRank() + 1))) {
+						pieza.addMove(pieza.getFile(), (char) (pieza
+								.getRank() + 1));
+						if (pieza.getRank() == '2'
+								&& posicion.isEmpty(pieza.getFile(),
+										(char) (pieza.getRank() + 2))) {
+							if (esLegal(pieza.getFile(), pieza.getRank(), pieza
+									.getFile(), (char) (pieza.getRank() + 2))) {
+								pieza.addMove(pieza.getFile(), (char) (pieza
+										.getRank() + 2));
 							}
 						}
 					}
 				}
 				if (posicion.getEnPassant() != '\0'
-						&& pieza.getNum() == '5'
-						&& Math.abs(pieza.getLetra() - posicion.getEnPassant()) == 1) {
-					pieza.anadirMov(posicion.getEnPassant(), (char) (pieza
-							.getNum() + 1));
+						&& pieza.getRank() == '5'
+						&& Math.abs(pieza.getFile() - posicion.getEnPassant()) == 1) {
+					pieza.addMove(posicion.getEnPassant(), (char) (pieza
+							.getRank() + 1));
 				}
 				// Movimientos para comer
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Side.BLACK) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() + 1));
+					Piece p = posicion.getPieza((char) (pieza.getFile() + 1),
+							(char) (pieza.getRank() + 1));
+					if (p != null && p.getSide() == Side.BLACK) {
+						if (esLegal(pieza.getFile(), pieza.getRank(),
+								(char) (pieza.getFile() + 1), (char) (pieza
+										.getRank() + 1))) {
+							pieza.addMove((char) (pieza.getFile() + 1),
+									(char) (pieza.getRank() + 1));
 						}
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Side.BLACK) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() + 1));
+					Piece p = posicion.getPieza((char) (pieza.getFile() + 1),
+							(char) (pieza.getRank() - 1));
+					if (p != null && p.getSide() == Side.BLACK) {
+						if (esLegal(pieza.getFile(), pieza.getRank(),
+								(char) (pieza.getFile() - 1), (char) (pieza
+										.getRank() + 1))) {
+							pieza.addMove((char) (pieza.getFile() - 1),
+									(char) (pieza.getRank() + 1));
 						}
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
@@ -197,92 +197,91 @@
 			}
 			// Peon negro
 			else {
-				if (posicion.isEmpty(pieza.getLetra(),
-						(char) (pieza.getNum() - 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() - 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() - 1));
-						if (pieza.getNum() == '7'
-								&& posicion.isEmpty(pieza.getLetra(),
-										(char) (pieza.getNum() - 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() - 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() - 2));
+				if (posicion.isEmpty(pieza.getFile(),
+						(char) (pieza.getRank() - 1))) {
+					if (esLegal(pieza.getFile(), pieza.getRank(), pieza
+							.getFile(), (char) (pieza.getRank() - 1))) {
+						pieza.addMove(pieza.getFile(), (char) (pieza
+								.getRank() - 1));
+						if (pieza.getRank() == '7'
+								&& posicion.isEmpty(pieza.getFile(),
+										(char) (pieza.getRank() - 2))) {
+							if (esLegal(pieza.getFile(), pieza.getRank(), pieza
+									.getFile(), (char) (pieza.getRank() - 2))) {
+								pieza.addMove(pieza.getFile(), (char) (pieza
+										.getRank() - 2));
 							}
 						}
 					}
 				}
 				if (posicion.getEnPassant() != '\0'
-						&& pieza.getNum() == '4'
-						&& Math.abs(pieza.getLetra() - posicion.getEnPassant()) == 1) {
-					pieza.anadirMov(posicion.getEnPassant(), (char) (pieza
-							.getNum() - 1));
+						&& pieza.getRank() == '4'
+						&& Math.abs(pieza.getFile() - posicion.getEnPassant()) == 1) {
+					pieza.addMove(posicion.getEnPassant(), (char) (pieza
+							.getRank() - 1));
 				}
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null && p.getBando() == Side.BLACK) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() - 1));
+					Piece p = posicion.getPieza((char) (pieza.getFile() - 1),
+							(char) (pieza.getRank() + 1));
+					if (p != null && p.getSide() == Side.BLACK) {
+						if (esLegal(pieza.getFile(), pieza.getRank(),
+								(char) (pieza.getFile() + 1), (char) (pieza
+										.getRank() - 1))) {
+							pieza.addMove((char) (pieza.getFile() + 1),
+									(char) (pieza.getRank() - 1));
 						}
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null && p.getBando() == Side.BLACK) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() - 1));
+					Piece p = posicion.getPieza((char) (pieza.getFile() - 1),
+							(char) (pieza.getRank() - 1));
+					if (p != null && p.getSide() == Side.BLACK) {
+						if (esLegal(pieza.getFile(), pieza.getRank(),
+								(char) (pieza.getFile() - 1), (char) (pieza
+										.getRank() - 1))) {
+							pieza.addMove((char) (pieza.getFile() - 1),
+									(char) (pieza.getRank() - 1));
 						}
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 			}
 			break;
-		case CABALLO:
-			for (DirectionVector v : pieza.getDirecciones()) {
-				Square destino = pieza.getCasilla().add(v);
+		case KNIGHT:
+			for (DirectionVector v : pieza.getDirections()) {
+				Square destino = pieza.getSquare().add(v);
 				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Piece p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
+					if (esLegal(pieza.getFile(), pieza.getRank(), destino
+							.getFile(), destino.getRank())) {
+						Piece p = posicion.getPieza(destino.getFile(), destino
+								.getRank());
 						if (p == null
-								|| (p != null && Piece.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
+								|| (p != null && p.isOppositeSide(pieza)))
+							pieza.addMove(destino);
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 			}
 
 			break;
-		case DAMA:
-		case ALFIL:
-		case TORRE:
-			for (DirectionVector v : pieza.getDirecciones()) {
+		case QUEEN:
+		case BISHOP:
+		case ROOK:
+			for (DirectionVector v : pieza.getDirections()) {
 				try {
-					Square destino = pieza.getCasilla().add(v);
-					Piece p = posicion.getPieza(destino.getLetra(), destino
-							.getNumero());
+					Square destino = pieza.getSquare().add(v);
+					Piece p = posicion.getPieza(destino.getFile(), destino
+							.getRank());
 					while (p == null) {
-						p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-								.getLetra(), destino.getNumero())) {
+						p = posicion.getPieza(destino.getFile(), destino
+								.getRank());
+						if (esLegal(pieza.getFile(), pieza.getRank(), destino
+								.getFile(), destino.getRank())) {
 							if (p == null
-									|| (p != null && Piece.esBandoContrario(
-											pieza, p))) {
-								pieza.anadirMov(destino);
+									|| (p != null && p.isOppositeSide(
+											pieza))) {
+								pieza.addMove(destino);
 							}
 						}
 						destino = destino.add(v);
@@ -292,18 +291,17 @@
 			}
 
 			break;
-		case REY:
-			for (DirectionVector v : pieza.getDirecciones()) {
-				Square destino = pieza.getCasilla().add(v);
+		case KING:
+			for (DirectionVector v : pieza.getDirections()) {
+				Square destino = pieza.getSquare().add(v);
 				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Piece p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
+					if (esLegal(pieza.getFile(), pieza.getRank(), destino
+							.getFile(), destino.getRank())) {
+						Piece p = posicion.getPieza(destino.getFile(), destino
+								.getRank());
 						if (p == null
-								|| (p != null && Piece.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
+								|| (p != null && p.isOppositeSide(pieza)))
+							pieza.addMove(destino);
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
@@ -312,28 +310,28 @@
 			if (posicion.getKingsideCastling(posicion.getTurn())
 					&& !isAttackedSquare(posicion.getKingPosition(posicion
 							.getTurn()))
-					&& posicion.isEmpty((char) (pieza.getLetra() + 1), pieza
-							.getNum())
-					&& !isAttackedSquare((char) (pieza.getLetra() + 1), (pieza
-							.getNum()))
-					&& posicion.isEmpty((char) (pieza.getLetra() + 2), pieza
-							.getNum())
-					&& !isAttackedSquare((char) (pieza.getLetra() + 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
+					&& posicion.isEmpty((char) (pieza.getFile() + 1), pieza
+							.getRank())
+					&& !isAttackedSquare((char) (pieza.getFile() + 1), (pieza
+							.getRank()))
+					&& posicion.isEmpty((char) (pieza.getFile() + 2), pieza
+							.getRank())
+					&& !isAttackedSquare((char) (pieza.getFile() + 2), (pieza
+							.getRank()))) {
+				pieza.addMove((char) (pieza.getFile() + 2), pieza.getRank());
 			}
 			if (posicion.getQueensideCastling(posicion.getTurn())
 					&& !isAttackedSquare(posicion.getKingPosition(posicion
 							.getTurn()))
-					&& posicion.isEmpty((char) (pieza.getLetra() - 1), pieza
-							.getNum())
-					&& !isAttackedSquare((char) (pieza.getLetra() - 1), (pieza
-							.getNum()))
-					&& posicion.isEmpty((char) (pieza.getLetra() - 2), pieza
-							.getNum())
-					&& !isAttackedSquare((char) (pieza.getLetra() - 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
+					&& posicion.isEmpty((char) (pieza.getFile() - 1), pieza
+							.getRank())
+					&& !isAttackedSquare((char) (pieza.getFile() - 1), (pieza
+							.getRank()))
+					&& posicion.isEmpty((char) (pieza.getFile() - 2), pieza
+							.getRank())
+					&& !isAttackedSquare((char) (pieza.getFile() - 2), (pieza
+							.getRank()))) {
+				pieza.addMove((char) (pieza.getFile() - 2), pieza.getRank());
 			}
 			break;
 		}
@@ -348,7 +346,7 @@
 	 * @return Devuelve un booleano indicando si es una casilla atacada o no
 	 */
 	public boolean isAttackedSquare(Square c) {
-		return isAttackedSquare(c.getLetra(), c.getNumero());
+		return isAttackedSquare(c.getFile(), c.getRank());
 	}
 
 	/**
@@ -389,8 +387,8 @@
 				Piece p = posicion.getPieza((char) (letra + v.getX()),
 						(char) (num + v.getY()));
 				if (p != null) {
-					if (Piece.esBandoContrario(posicion.getTurn(), p)
-							&& p.getTipo() == Tipo.CABALLO) {
+					if (Piece.isOppositeSide(posicion.getTurn(), p)
+							&& p.getType() == Type.KNIGHT) {
 						return true;
 					}
 				}
@@ -413,10 +411,10 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurn(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && p.getTipo() == Tipo.REY))) {
+				if (Piece.isOppositeSide(posicion.getTurn(), p)
+						&& (p.getType() == Type.QUEEN
+								|| p.getType() == Type.ROOK || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && p.getType() == Type.KING))) {
 					return true;
 				}
 			} catch (ArrayIndexOutOfBoundsException e) {
@@ -436,11 +434,11 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurn(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Side.BLACK))))) {
+				if (Piece.isOppositeSide(posicion.getTurn(), p)
+						&& (p.getType() == Type.QUEEN
+								|| p.getType() == Type.BISHOP || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && (p.getType() == Type.KING || (p
+								.getType() == Type.PAWN && p.getSide() == Side.BLACK))))) {
 					return true;
 				}
 			} catch (ArrayIndexOutOfBoundsException e) {
@@ -460,11 +458,11 @@
 					numDest = (char) (numDest + v.getY());
 					p = posicion.getPieza(letDest, numDest);
 				}
-				if (Piece.esBandoContrario(posicion.getTurn(), p)
-						&& (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&& letra + v.getX() == letDest && (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON && p.getBando() == Side.WHITE))))) {
+				if (Piece.isOppositeSide(posicion.getTurn(), p)
+						&& (p.getType() == Type.QUEEN
+								|| p.getType() == Type.BISHOP || (num + v.getY() == numDest
+								&& letra + v.getX() == letDest && (p.getType() == Type.KING || (p
+								.getType() == Type.PAWN && p.getSide() == Side.WHITE))))) {
 					return true;
 				}
 			} catch (ArrayIndexOutOfBoundsException e) {
@@ -530,10 +528,10 @@
 			return null;
 		}
 
-		if (Piece.esBandoContrario(posicion.getTurn(), piezaQueMueve)) {
+		if (Piece.isOppositeSide(posicion.getTurn(), piezaQueMueve)) {
 			return null;
 		}
-		if (indice != movimientos.getNumHalfPly())
+		if (indice != movimientos.getHalfmoveNumber())
 			return null;
 		// Buscamos la casilla de destino entre las casillas validas de la
 		// pieza.
@@ -542,7 +540,7 @@
 			// Buscamos la letra.
 			while ((i < piezaQueMueve.getCasillasValidas().size())
 					&& (destinoLetra != piezaQueMueve.getCasillasValidas().get(
-							i).getLetra())) {
+							i).getFile())) {
 				i++;
 				// Comprobamos si el numero de la letra encontrada coincide.
 			}
@@ -550,7 +548,7 @@
 				// Si se entra en el siguiente caso, es que el movimiento es
 				// valido
 				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
-						.getLetra()) {
+						.getFile()) {
 					mov = new Movement();
 					mov.setCasillaOrigen(new Square(origenLetra, origenNum));
 					mov
@@ -558,7 +556,7 @@
 									destinoNum));
 					mov.setNumeroMovimiento(posicion.getFullmoveNumber());
 					mov.setBando(posicion.getTurn());
-					mov.setTipoPieza(piezaQueMueve.getTipo());
+					mov.setTipoPieza(piezaQueMueve.getType());
 
 					// Si se come ponemos el contador a 0
 					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
@@ -567,17 +565,17 @@
 						mov.setCasillaComer(new Square(destinoLetra,
 								destinoNum));
 						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
-								destinoNum).getTipo());
+								destinoNum).getType());
 						posicion.removePiece(mov.getCasillaComer());
 					}
 
 					// Se hacen los calculos especiales si se trata de un peon
-					if (piezaQueMueve.getTipo() == Tipo.PEON) {
+					if (piezaQueMueve.getType() == Type.PAWN) {
 						// Se borra la pieza correspondiente si se come al paso
 						if (Math.abs(destinoLetra - origenLetra) == 1
 								&& posicion.isEmpty(destinoLetra, destinoNum)) {
 							mov.setTipoPiezaComida(posicion.getPieza(
-									destinoLetra, origenNum).getTipo());
+									destinoLetra, origenNum).getType());
 							mov.setCasillaComer(new Square(destinoLetra,
 									origenNum));
 							posicion.removePiece(mov.getCasillaComer());
@@ -595,7 +593,7 @@
 							// if (mostrarDialogoCoronacion) {
 							// mostrarDialogoCoronacion ();
 							// }
-							piezaQueMueve = new Piece(piezaQueMueve.getBando(),
+							piezaQueMueve = new Piece(piezaQueMueve.getSide(),
 									coronar);
 
 							mov.setCoronacion(coronar);
@@ -604,7 +602,7 @@
 						hash.borrarTabla();
 					}
 					// Se hacen los calculos especiales si se trata de un rey
-					if (piezaQueMueve.getTipo() == Tipo.REY) {
+					if (piezaQueMueve.getType() == Type.KING) {
 						// Movemos las torres en caso de enroque
 						if ((destinoLetra - origenLetra) == 2) {
 							Piece torre = posicion.getPieza('h', origenNum);
@@ -664,36 +662,36 @@
 	public Movement goBack() {
 		Movement mov;
 		Piece piezaQueMueve;
-		if (indice < movimientos.getNumHalfPly()) {
-			mov = movimientos.getMovimiento(indice);
+		if (indice < movimientos.getHalfmoveNumber()) {
+			mov = movimientos.getMove(indice);
 			piezaQueMueve = posicion.getPieza(mov.getCasillaOrigen());
 			// Si se come al paso
-			if (piezaQueMueve.getTipo() == Tipo.PEON
-					&& Math.abs(mov.getCasillaDestino().getLetra()
-							- mov.getCasillaOrigen().getLetra()) == 1
+			if (piezaQueMueve.getType() == Type.PAWN
+					&& Math.abs(mov.getCasillaDestino().getFile()
+							- mov.getCasillaOrigen().getFile()) == 1
 					&& posicion.isEmpty(mov.getCasillaDestino())) {
 				posicion.removePiece(mov.getCasillaComer());
 			}
 			// Si se corona
 			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+				piezaQueMueve = new Piece(piezaQueMueve.getSide(), mov
 						.getCoronacion());
 			}
 			// Se hacen los calculos especiales si se trata de un rey
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
+			if (piezaQueMueve.getType() == Type.KING) {
 				// Movemos las torres en caso de enroque
 				Square origen = mov.getCasillaOrigen();
 				Square destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Piece torre = posicion.getPieza('h', origen.getNumero());
-					posicion.removePiece('h', origen.getNumero());
-					posicion.setPiece(torre, 'f', origen.getNumero());
+				if ((destino.getFile() - origen.getFile()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getRank());
+					posicion.removePiece('h', origen.getRank());
+					posicion.setPiece(torre, 'f', origen.getRank());
 				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
+					if ((destino.getFile() - origen.getFile()) == -2) {
 						Piece torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.removePiece('a', origen.getNumero());
-						posicion.setPiece(torre, 'd', origen.getNumero());
+								.getPieza('a', origen.getRank());
+						posicion.removePiece('a', origen.getRank());
+						posicion.setPiece(torre, 'd', origen.getRank());
 					}
 				}
 			}
@@ -725,34 +723,34 @@
 		Piece piezaQueMueve;
 		if (indice > 0) {
 			indice--;
-			mov = movimientos.getMovimiento(indice);
+			mov = movimientos.getMove(indice);
 			posicion.setFullmoveNumber(mov.getNumeroMovimiento());
 			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
 			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+				piezaQueMueve = new Piece(piezaQueMueve.getSide(), mov
 						.getCoronacion());
 			}
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
+			if (piezaQueMueve.getType() == Type.KING) {
 				// Movemos las torres en caso de enroque
 				Square origen = mov.getCasillaOrigen();
 				Square destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Piece torre = posicion.getPieza('h', origen.getNumero());
-					posicion.removePiece('h', origen.getNumero());
-					posicion.setPiece(torre, 'f', origen.getNumero());
+				if ((destino.getFile() - origen.getFile()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getRank());
+					posicion.removePiece('h', origen.getRank());
+					posicion.setPiece(torre, 'f', origen.getRank());
 				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
+					if ((destino.getFile() - origen.getFile()) == -2) {
 						Piece torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.removePiece('a', origen.getNumero());
-						posicion.setPiece(torre, 'd', origen.getNumero());
+								.getPieza('a', origen.getRank());
+						posicion.removePiece('a', origen.getRank());
+						posicion.setPiece(torre, 'd', origen.getRank());
 					}
 				}
 			}
 			posicion.removePiece(mov.getCasillaDestino());
 			if (mov.getTipoPiezaComida() != null) {
 				posicion.setPiece(new Piece(
-						piezaQueMueve.getBando() == Side.WHITE ? Side.WHITE
+						piezaQueMueve.getSide() == Side.WHITE ? Side.WHITE
 								: Side.BLACK, mov.getTipoPieza()), mov
 						.getCasillaComer());
 			}
@@ -802,21 +800,21 @@
 				pieza = posicion.getPieza(i, j);
 				if (pieza != null) {
 					if (posibleMatInsuf) {
-						if (pieza.getTipo() != Tipo.REY) {
+						if (pieza.getType() != Type.KING) {
 							fin2 = true;
 						}
 					} else {
-						switch (pieza.getTipo()) {
-						case PEON:
-						case DAMA:
-						case TORRE:
+						switch (pieza.getType()) {
+						case PAWN:
+						case QUEEN:
+						case ROOK:
 							fin2 = true;
 							break;
-						case ALFIL:
-						case CABALLO:
+						case BISHOP:
+						case KNIGHT:
 							posibleMatInsuf = true;
 							break;
-						case REY:
+						case KING:
 							break;
 						}
 					}
@@ -837,7 +835,7 @@
 			while (j <= '8' && !fin) {
 				pieza = posicion.getPieza(i, j);
 				if ((pieza != null)
-						&& (!Piece.esBandoContrario(posicion.getTurn(), pieza))
+						&& (!Piece.isOppositeSide(posicion.getTurn(), pieza))
 						&& (!pieza.getCasillasValidas().isEmpty())) {
 					fin = true;
 				}
@@ -883,7 +881,7 @@
 	public Movement moveALG(String mov) {
 		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
 		char tipoPieza = 'P';
-		Tipo piezaCoronacion = null;
+		Type piezaCoronacion = null;
 		int contadorOesEnroque = 0, i;
 		boolean finDestino = false;
 
@@ -920,7 +918,7 @@
 				break;
 			case 'B':
 				if (i != 0) {
-					piezaCoronacion = Tipo.ALFIL;
+					piezaCoronacion = Type.BISHOP;
 				} else {
 					tipoPieza = 'A';
 				}
@@ -930,21 +928,21 @@
 				break;
 			case 'N':
 				if (i != 0) {
-					piezaCoronacion = Tipo.CABALLO;
+					piezaCoronacion = Type.KNIGHT;
 				} else {
 					tipoPieza = 'C';
 				}
 				break;
 			case 'Q':
 				if (i != 0) {
-					piezaCoronacion = Tipo.DAMA;
+					piezaCoronacion = Type.QUEEN;
 				} else {
 					tipoPieza = 'D';
 				}
 				break;
 			case 'R':
 				if (i != 0) {
-					piezaCoronacion = Tipo.TORRE;
+					piezaCoronacion = Type.ROOK;
 				} else {
 					tipoPieza = 'T';
 				}

Modified: trunk/MihailChessLib/com/mihail/chess/Board2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -17,7 +17,7 @@
 import javax.swing.JPanel;
 
 import com.mihail.chess.Board.Side;
-import com.mihail.chess.Piece.Tipo;
+import com.mihail.chess.Piece.Type;
 
 /**
  * Esta clase se encarga de proporcionar una vista b?sica de la l?gica, usada
@@ -242,7 +242,7 @@
 					}
 
 					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
-					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
+					g.drawImage(piezas[bandoToInt(temp.getSide())][tipoToInt(temp.getType())], i * TAM, j * TAM, TAM, TAM, null);
 				}
 			}
 
@@ -415,12 +415,12 @@
 	
 	public void setPieza(Piece pieza, Square casilla) {
 		tablero.setPiece(pieza, casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+		repintarCasilla(casilla.getFile() - 'a', casilla.getRank()-'1');
 	}
 	
 	public void borrarPieza(Square casilla) {
 		tablero.removePiece(casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+		repintarCasilla(casilla.getFile() - 'a', casilla.getRank()-'1');
 	}
 	
 	public void setFEN(String pos) {
@@ -508,38 +508,38 @@
 		return 1;
 	}
 	
-	private int tipoToInt(Tipo tipo) {
+	private int tipoToInt(Type tipo) {
 		switch(tipo) {
-		case PEON:
+		case PAWN:
 			return 0;
-		case CABALLO:
+		case KNIGHT:
 			return 1;
-		case ALFIL:
+		case BISHOP:
 			return 2;
-		case TORRE:
+		case ROOK:
 			return 3;
-		case DAMA:
+		case QUEEN:
 			return 4;
-		case REY:
+		case KING:
 			return 5;
 		}
 		return -1;
 	}
 	
-	private Tipo intToTipo(int i) {
+	private Type intToTipo(int i) {
 		switch(i) {
 		case 0:
-			return Tipo.PEON;
+			return Type.PAWN;
 		case 1:
-			return Tipo.CABALLO;
+			return Type.KNIGHT;
 		case 2:
-			return Tipo.ALFIL;
+			return Type.BISHOP;
 		case 3:
-			return Tipo.TORRE;
+			return Type.ROOK;
 		case 4:
-			return Tipo.DAMA;
+			return Type.QUEEN;
 		case 5:
-			return Tipo.REY;
+			return Type.KING;
 		}
 		return null;
 	}

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -14,7 +14,7 @@
 import javax.swing.ImageIcon;
 
 import com.mihail.chess.Board.Side;
-import com.mihail.chess.Piece.Tipo;
+import com.mihail.chess.Piece.Type;
 
 /**
  * Representa el tema de imagenes de piezas, texturas de las casillas, textura
@@ -94,7 +94,7 @@
 		}
 	}
 	
-	public Image getImagePiece(Side bando, Tipo tipo) {
+	public Image getImagePiece(Side bando, Type tipo) {
 		return pieceImages[bandoToInt(bando)][tipoToInt(tipo)];
 	}
 	
@@ -114,19 +114,19 @@
 		return bando == Side.WHITE? 0:1;
 	}
 	
-	private int tipoToInt(Tipo tipo) {
+	private int tipoToInt(Type tipo) {
 		switch(tipo) {
-		case PEON:
+		case PAWN:
 			return 0;
-		case CABALLO:
+		case KNIGHT:
 			return 1;
-		case ALFIL:
+		case BISHOP:
 			return 2;
-		case TORRE:
+		case ROOK:
 			return 3;
-		case DAMA:
+		case QUEEN:
 			return 4;
-		case REY:
+		case KING:
 			return 5;
 		}
 		return -1;

Modified: trunk/MihailChessLib/com/mihail/chess/DirectionVector.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/DirectionVector.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/DirectionVector.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -42,7 +42,7 @@
 	 * @return Un booleano si este vector y el recibido siguen la misma
 	 *         direccion.
 	 */
-	public boolean esMismaDireccion(DirectionVector v) {
+	public boolean isSameDirection(DirectionVector v) {
 		int difX, difY;
 
 		if ((x == 0 && v.getX() != 0) || (y == 0 && v.getY() != 0))

Modified: trunk/MihailChessLib/com/mihail/chess/Movement.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -3,7 +3,7 @@
 import static com.mihail.chess.Board.Side;
 
 import com.mihail.chess.Board.Result;
-import com.mihail.chess.Piece.Tipo;
+import com.mihail.chess.Piece.Type;
 
 /**
  * Esta clase define un objeto Movimiento, que guarda informacion sobre el
@@ -52,7 +52,7 @@
 	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
 	 * 
 	 */
-	private Tipo tipoPieza;
+	private Type tipoPieza;
 
 	/**
 	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
@@ -90,7 +90,7 @@
 	 * 'D' -> Dama <BR>
 	 * 0 -> No hay coronacion
 	 */
-	private Tipo coronacion;
+	private Type coronacion;
 
 	/**
 	 * Este atributo indica el valor de contadorTablas en el momento que se
@@ -119,7 +119,7 @@
 	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
 	 * producido una captura contiene un 0.
 	 */
-	private Tipo tipoPiezaComida;
+	private Type tipoPiezaComida;
 
 	/**
 	 * Este atributo guarda la representacion del movimiento en notacion
@@ -159,11 +159,11 @@
 		this.numeroMovimiento = numeroMovimiento;
 	}
 
-	public Tipo getTipoPieza() {
+	public Type getTipoPieza() {
 		return tipoPieza;
 	}
 
-	public void setTipoPieza(Tipo tipoPieza) {
+	public void setTipoPieza(Type tipoPieza) {
 		this.tipoPieza = tipoPieza;
 	}
 
@@ -183,11 +183,11 @@
 		this.contadorTablas = contadorTablas;
 	}
 
-	public Tipo getCoronacion() {
+	public Type getCoronacion() {
 		return coronacion;
 	}
 
-	public void setCoronacion(Tipo coronacion) {
+	public void setCoronacion(Type coronacion) {
 		this.coronacion = coronacion;
 	}
 
@@ -231,11 +231,11 @@
 		this.notacion = notacion;
 	}
 
-	public Tipo getTipoPiezaComida() {
+	public Type getTipoPiezaComida() {
 		return tipoPiezaComida;
 	}
 
-	public void setTipoPiezaComida(Tipo tipoPiezaComida) {
+	public void setTipoPiezaComida(Type tipoPiezaComida) {
 		this.tipoPiezaComida = tipoPiezaComida;
 	}
 }
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/Piece.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -16,8 +16,8 @@
 
 public final class Piece {
 
-	public static enum Tipo {
-		PEON, CABALLO, ALFIL, TORRE, DAMA, REY
+	public static enum Type {
+		PAWN, KNIGHT, BISHOP, ROOK, QUEEN, KING
 	}
 
 	// Atributos
@@ -37,7 +37,7 @@
 	 * 'D' -> dama <BR>
 	 * 'R' -> rey
 	 */
-	private Tipo tipo;
+	private Type tipo;
 
 	private Square casilla;
 
@@ -63,12 +63,12 @@
 	 *            Es el tipo de la pieza {P,C,A,T,D,R}
 	 * @see #tipo
 	 */
-	public Piece(Side ban, Tipo claseDePieza) {
+	public Piece(Side ban, Type claseDePieza) {
 		bando = ban;
 		tipo = claseDePieza;
 		casilla = new Square();
 		switch (tipo) {
-		case PEON:
+		case PAWN:
 			direcciones = new DirectionVector[1];
 			if (bando == Side.WHITE)
 				direcciones[0] = new DirectionVector(0, 1);
@@ -76,7 +76,7 @@
 				direcciones[0] = new DirectionVector(0, -1);
 			casillasValidas = new ArrayList<Square>(4);
 			break;
-		case TORRE:
+		case ROOK:
 			direcciones = new DirectionVector[4];
 			direcciones[0] = new DirectionVector(1, 0);
 			direcciones[1] = new DirectionVector(-1, 0);
@@ -84,7 +84,7 @@
 			direcciones[3] = new DirectionVector(0, -1);
 			casillasValidas = new ArrayList<Square>(13);
 			break;
-		case ALFIL:
+		case BISHOP:
 			direcciones = new DirectionVector[4];
 			direcciones[0] = new DirectionVector(1, 1);
 			direcciones[1] = new DirectionVector(-1, 1);
@@ -92,7 +92,7 @@
 			direcciones[3] = new DirectionVector(-1, -1);
 			casillasValidas = new ArrayList<Square>(13);
 			break;
-		case CABALLO:
+		case KNIGHT:
 			direcciones = new DirectionVector[8];
 			direcciones[0] = new DirectionVector(1, 2);
 			direcciones[1] = new DirectionVector(-1, 2);
@@ -105,7 +105,7 @@
 			direcciones[7] = new DirectionVector(-2, -1);
 			casillasValidas = new ArrayList<Square>(8);
 			break;
-		case REY:
+		case KING:
 			direcciones = new DirectionVector[8];
 			direcciones[0] = new DirectionVector(1, 0);
 			direcciones[1] = new DirectionVector(-1, 0);
@@ -117,7 +117,7 @@
 			direcciones[7] = new DirectionVector(-1, -1);
 			casillasValidas = new ArrayList<Square>(8);
 			break;
-		case DAMA:
+		case QUEEN:
 			direcciones = new DirectionVector[8];
 			direcciones[0] = new DirectionVector(1, 0);
 			direcciones[1] = new DirectionVector(-1, 0);
@@ -137,13 +137,11 @@
 	 * 
 	 * @param pieza1
 	 *            Pieza para saber si es de bando contrario a pieza2.
-	 * @param pieza2
-	 *            La otra pieza.
 	 * @return Devuelve true cuando pieza1 y pieza2 sean de bandos contrarios,
 	 *         false cuando sean del mismo bando.
 	 */
-	public final static boolean esBandoContrario(Piece pieza1, Piece pieza2) {
-		return pieza1.bando != pieza2.bando;
+	public final boolean isOppositeSide(Piece pieza1) {
+		return pieza1.bando != this.bando;
 	}
 
 	/**
@@ -157,7 +155,7 @@
 	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
 	 *         mover, false si es del mismo bando
 	 */
-	public final static boolean esBandoContrario(Side turno, Piece pieza) {
+	public final static boolean isOppositeSide(Side turno, Piece pieza) {
 		return turno != pieza.bando;
 	}
 
@@ -169,15 +167,15 @@
 	 * @param n
 	 *            Es el numero de destino que queremos a?adir
 	 */
-	public void anadirMov(char let, char n) {
+	public void addMove(char let, char n) {
 		this.casillasValidas.add(new Square(let, n));
 	}
 
-	public void anadirMov(Square c) {
+	public void addMove(Square c) {
 		this.casillasValidas.add(c);
 	}
 
-	public Side getBando() {
+	public Side getSide() {
 		return bando;
 	}
 
@@ -185,35 +183,35 @@
 		return casillasValidas;
 	}
 
-	public DirectionVector[] getDirecciones() {
+	public DirectionVector[] getDirections() {
 		return direcciones;
 	}
 
-	public Tipo getTipo() {
+	public Type getType() {
 		return tipo;
 	}
 
-	public char getLetra() {
-		return casilla.getLetra();
+	public char getFile() {
+		return casilla.getFile();
 	}
 
-	public void setLetra(char let) {
-		casilla.setLetra(let);
+	public void setFile(char let) {
+		casilla.setFile(let);
 	}
 
-	public char getNum() {
-		return casilla.getNumero();
+	public char getRank() {
+		return casilla.getRank();
 	}
 
-	public void setNum(char num) {
-		casilla.setNumero(num);
+	public void setRank(char num) {
+		casilla.setRank(num);
 	}
 
-	public Square getCasilla() {
+	public Square getSquare() {
 		return casilla;
 	}
 
-	public void setCasilla(Square casilla) {
+	public void setSquare(Square casilla) {
 		this.casilla = casilla;
 	}
 	

Modified: trunk/MihailChessLib/com/mihail/chess/Position.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -1,10 +1,10 @@
 package com.mihail.chess;
 
 import static com.mihail.chess.Board.Side;
-import static com.mihail.chess.Piece.Tipo;
+import static com.mihail.chess.Piece.Type;
 
 import com.mihail.chess.Board.Result;
-import com.mihail.chess.Piece.Tipo;
+import com.mihail.chess.Piece.Type;
 
 public class Position {
 
@@ -137,19 +137,19 @@
 	 *         R -> K <BR>
 	 *         Otro caso -> \0
 	 */
-	private final static char tipoToEnglish(Tipo t) {
+	private final static char tipoToEnglish(Type t) {
 		switch (t) {
-		case ALFIL:
+		case BISHOP:
 			return 'B';
-		case CABALLO:
+		case KNIGHT:
 			return 'N';
-		case DAMA:
+		case QUEEN:
 			return 'Q';
-		case PEON:
+		case PAWN:
 			return 'P';
-		case REY:
+		case KING:
 			return 'K';
-		case TORRE:
+		case ROOK:
 			return 'R';
 		default:
 			return '\0';
@@ -185,19 +185,19 @@
 	 *         R -> 5 <BR>
 	 *         Otro caso -> -1
 	 */
-	private final static int tipoToInt(Tipo c) {
+	private final static int tipoToInt(Type c) {
 		switch (c) {
-		case PEON:
+		case PAWN:
 			return 0;
-		case CABALLO:
+		case KNIGHT:
 			return 1;
-		case ALFIL:
+		case BISHOP:
 			return 2;
-		case TORRE:
+		case ROOK:
 			return 3;
-		case DAMA:
+		case QUEEN:
 			return 4;
-		case REY:
+		case KING:
 			return 5;
 		default:
 			return -1;
@@ -220,11 +220,11 @@
 				else {
 					if (cont > 0)
 						cad += cont;
-					if (p.getBando() == Side.WHITE)
-						cad += tipoToEnglish(p.getTipo());
+					if (p.getSide() == Side.WHITE)
+						cad += tipoToEnglish(p.getType());
 					else
 						cad += (Character
-								.toLowerCase(tipoToEnglish(p.getTipo())));
+								.toLowerCase(tipoToEnglish(p.getType())));
 					cont = 0;
 				}
 			}
@@ -287,51 +287,51 @@
 		for (int i = 0; i < FEN[0].length(); i++) {
 			switch (FEN[0].charAt(i)) {
 			case 'P':
-				setPiece(new Piece(Side.WHITE, Tipo.PEON), let, num);
+				setPiece(new Piece(Side.WHITE, Type.PAWN), let, num);
 				let++;
 				break;
 			case 'p':
-				setPiece(new Piece(Side.BLACK, Tipo.PEON), let, num);
+				setPiece(new Piece(Side.BLACK, Type.PAWN), let, num);
 				let++;
 				break;
 			case 'N':
-				setPiece(new Piece(Side.WHITE, Tipo.CABALLO), let, num);
+				setPiece(new Piece(Side.WHITE, Type.KNIGHT), let, num);
 				let++;
 				break;
 			case 'n':
-				setPiece(new Piece(Side.BLACK, Tipo.CABALLO), let, num);
+				setPiece(new Piece(Side.BLACK, Type.KNIGHT), let, num);
 				let++;
 				break;
 			case 'B':
-				setPiece(new Piece(Side.WHITE, Tipo.ALFIL), let, num);
+				setPiece(new Piece(Side.WHITE, Type.BISHOP), let, num);
 				let++;
 				break;
 			case 'b':
-				setPiece(new Piece(Side.BLACK, Tipo.ALFIL), let, num);
+				setPiece(new Piece(Side.BLACK, Type.BISHOP), let, num);
 				let++;
 				break;
 			case 'R':
-				setPiece(new Piece(Side.WHITE, Tipo.TORRE), let, num);
+				setPiece(new Piece(Side.WHITE, Type.ROOK), let, num);
 				let++;
 				break;
 			case 'r':
-				setPiece(new Piece(Side.BLACK, Tipo.TORRE), let, num);
+				setPiece(new Piece(Side.BLACK, Type.ROOK), let, num);
 				let++;
 				break;
 			case 'Q':
-				setPiece(new Piece(Side.WHITE, Tipo.DAMA), let, num);
+				setPiece(new Piece(Side.WHITE, Type.QUEEN), let, num);
 				let++;
 				break;
 			case 'q':
-				setPiece(new Piece(Side.BLACK, Tipo.DAMA), let, num);
+				setPiece(new Piece(Side.BLACK, Type.QUEEN), let, num);
 				let++;
 				break;
 			case 'K':
-				setPiece(new Piece(Side.WHITE, Tipo.REY), let, num);
+				setPiece(new Piece(Side.WHITE, Type.KING), let, num);
 				let++;
 				break;
 			case 'k':
-				setPiece(new Piece(Side.BLACK, Tipo.REY), let, num);
+				setPiece(new Piece(Side.BLACK, Type.KING), let, num);
 				let++;
 				break;
 			case '/':
@@ -443,7 +443,7 @@
 	}
 	
 	public Piece getPieza(Square c) {
-		return getPieza(c.getLetra(), c.getNumero());
+		return getPieza(c.getFile(), c.getRank());
 	}
 
 	/**
@@ -498,10 +498,10 @@
 		if (b == Side.WHITE) {
 			Piece p = getPieza('h', '1');
 			if (p != null
-					&& kingPosition[bandoToInt(Side.WHITE)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Side.WHITE)].getNumero() == '1'
-					&& p.getBando() == Side.WHITE
-					&& p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.WHITE)].getFile() == 'e'
+					&& kingPosition[bandoToInt(Side.WHITE)].getRank() == '1'
+					&& p.getSide() == Side.WHITE
+					&& p.getType() == Type.ROOK) {
 				enroque[0][0] = c;
 				return true;
 			} else
@@ -509,9 +509,9 @@
 		} else if (b == Side.BLACK) {
 			Piece p = getPieza('h', '8');
 			if (p != null
-					&& kingPosition[bandoToInt(Side.BLACK)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Side.BLACK)].getNumero() == '8'
-					&& p.getBando() == Side.BLACK && p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.BLACK)].getFile() == 'e'
+					&& kingPosition[bandoToInt(Side.BLACK)].getRank() == '8'
+					&& p.getSide() == Side.BLACK && p.getType() == Type.ROOK) {
 				enroque[1][0] = c;
 				return true;
 			} else
@@ -540,10 +540,10 @@
 		if (b == Side.WHITE) {
 			Piece p = getPieza('a', '1');
 			if (p != null
-					&& kingPosition[bandoToInt(Side.WHITE)].getLetra() == 'e'
-					&& kingPosition[0].getNumero() == '1'
-					&& p.getBando() == Side.WHITE
-					&& p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.WHITE)].getFile() == 'e'
+					&& kingPosition[0].getRank() == '1'
+					&& p.getSide() == Side.WHITE
+					&& p.getType() == Type.ROOK) {
 				enroque[0][1] = c;
 				return true;
 			} else
@@ -551,9 +551,9 @@
 		} else if (b == Side.BLACK) {
 			Piece p = getPieza('a', '8');
 			if (p != null
-					&& kingPosition[bandoToInt(Side.BLACK)].getLetra() == 'e'
-					&& kingPosition[bandoToInt(Side.BLACK)].getNumero() == '8'
-					&& p.getBando() == Side.BLACK && p.getTipo() == Tipo.TORRE) {
+					&& kingPosition[bandoToInt(Side.BLACK)].getFile() == 'e'
+					&& kingPosition[bandoToInt(Side.BLACK)].getRank() == '8'
+					&& p.getSide() == Side.BLACK && p.getType() == Type.ROOK) {
 				enroque[1][1] = c;
 				return true;
 			} else
@@ -582,24 +582,24 @@
 	 *            Es el numero de la casilla
 	 */
 	public void setPiece(Piece pieza, char letra, char num) {
-		pieza.setLetra(letra);
-		pieza.setNum(num);
+		pieza.setFile(letra);
+		pieza.setRank(num);
 		tabla[num - '1'][letra - 'a'] = pieza;
 		clavePosicion = clavePosicion
-				^ indices[bandoToInt(pieza.getBando())][tipoToInt(pieza
-						.getTipo())][num - '1'][letra - 'a'];
+				^ indices[bandoToInt(pieza.getSide())][tipoToInt(pieza
+						.getType())][num - '1'][letra - 'a'];
 
-		if (pieza.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(pieza.getBando())] = pieza.getCasilla();
+		if (pieza.getType() == Type.KING) {
+			kingPosition[bandoToInt(pieza.getSide())] = pieza.getSquare();
 		}
 	}
 	
 	public void setPiece(Piece pieza, Square casilla) {
-		setPiece(pieza, casilla.getLetra(), casilla.getNumero());
+		setPiece(pieza, casilla.getFile(), casilla.getRank());
 	}
 
 	public void removePiece(Square casilla) {
-		removePiece(casilla.getLetra(), casilla.getNumero());
+		removePiece(casilla.getFile(), casilla.getRank());
 	}
 
 	/**
@@ -618,45 +618,45 @@
 		// Se actualiza el estado de los enroques en caso de que se borre un rey
 		// o una torre
 		if (p != null) {
-			if (p.getTipo() == Tipo.REY) {
-				if (p.getBando() == Side.WHITE) {
+			if (p.getType() == Type.KING) {
+				if (p.getSide() == Side.WHITE) {
 					enroque[0][0] = false;
 					enroque[0][1] = false;
-					kingPosition[bandoToInt(Side.WHITE)].setLetra('\0');
-					kingPosition[bandoToInt(Side.WHITE)].setNumero('\0');
+					kingPosition[bandoToInt(Side.WHITE)].setFile('\0');
+					kingPosition[bandoToInt(Side.WHITE)].setRank('\0');
 				} else {
 					enroque[1][0] = false;
 					enroque[1][1] = false;
-					kingPosition[bandoToInt(Side.BLACK)].setLetra('\0');
-					kingPosition[bandoToInt(Side.BLACK)].setNumero('\0');
+					kingPosition[bandoToInt(Side.BLACK)].setFile('\0');
+					kingPosition[bandoToInt(Side.BLACK)].setRank('\0');
 				}
-			} else if (p.getTipo() == Tipo.TORRE) {
-				if (p.getLetra() == 'a' && p.getNum() == '1'
-						&& p.getBando() == Side.WHITE)
+			} else if (p.getType() == Type.ROOK) {
+				if (p.getFile() == 'a' && p.getRank() == '1'
+						&& p.getSide() == Side.WHITE)
 					enroque[0][1] = false;
-				else if (p.getLetra() == 'h' && p.getNum() == '1'
-						&& p.getBando() == Side.WHITE)
+				else if (p.getFile() == 'h' && p.getRank() == '1'
+						&& p.getSide() == Side.WHITE)
 					enroque[0][0] = false;
-				else if (p.getLetra() == 'a' && p.getNum() == '8'
-						&& p.getBando() == Side.BLACK)
+				else if (p.getFile() == 'a' && p.getRank() == '8'
+						&& p.getSide() == Side.BLACK)
 					enroque[1][1] = false;
-				else if (p.getLetra() == 'h' && p.getNum() == '8'
-						&& p.getBando() == Side.BLACK)
+				else if (p.getFile() == 'h' && p.getRank() == '8'
+						&& p.getSide() == Side.BLACK)
 					enroque[1][0] = false;
-			} else if (p.getTipo() == Tipo.PEON) {
+			} else if (p.getType() == Type.PAWN) {
 				if (letra == alPaso
-						&& (p.getBando() == Side.WHITE && num == '4')
-						|| (p.getBando() == Side.BLACK && num == '5'))
+						&& (p.getSide() == Side.WHITE && num == '4')
+						|| (p.getSide() == Side.BLACK && num == '5'))
 					alPaso = 0;
 			}
 			clavePosicion = clavePosicion
-					^ indices[bandoToInt(p.getBando())][tipoToInt(p.getTipo())][iNum][iLetra];
+					^ indices[bandoToInt(p.getSide())][tipoToInt(p.getType())][iNum][iLetra];
 			tabla[num - '1'][letra - 'a'] = null;
 		}
 	}
 	
 	public boolean isEmpty(Square c) {
-		return isEmpty(c.getLetra(), c.getNumero());
+		return isEmpty(c.getFile(), c.getRank());
 	}
 
 	/**
@@ -704,12 +704,12 @@
 		Piece p;
 		if (this.turno == Side.BLACK) {
 			p = getPieza(alPaso, '4');
-			encontrado = p != null && p.getBando() == Side.WHITE
-					&& p.getTipo() == Tipo.PEON;
+			encontrado = p != null && p.getSide() == Side.WHITE
+					&& p.getType() == Type.PAWN;
 		} else {
 			p = getPieza(alPaso, '5');
-			encontrado = p != null && p.getBando() == Side.BLACK
-					&& p.getTipo() == Tipo.PEON;
+			encontrado = p != null && p.getSide() == Side.BLACK
+					&& p.getType() == Type.PAWN;
 		}
 		if (encontrado)
 			this.alPaso = alPaso;
@@ -766,9 +766,9 @@
 	private String generarNotacionALG (Movement mov) {
 		StringBuffer temp = new StringBuffer ();
 
-		if (mov.getTipoPieza() == Tipo.REY) {
-			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
-				if (mov.getCasillaDestino().getLetra() == 'g') {
+		if (mov.getTipoPieza() == Type.KING) {
+			if (Math.abs (mov.getCasillaOrigen().getFile() - mov.getCasillaDestino().getFile() ) == 2) {
+				if (mov.getCasillaDestino().getFile() == 'g') {
 					temp.append ("O-O");
 				}
 				else { // mov.destinoLetra == 'c'
@@ -777,25 +777,25 @@
 				return temp.toString ();
 			}
 		}
-		if (mov.getTipoPieza() != Tipo.PEON) {
+		if (mov.getTipoPieza() != Type.PAWN) {
 			temp.append (tipoToEnglish (mov.getTipoPieza()));
 		}
 		Piece pieza = getPieza (mov.getCasillaDestino());
 		switch (mov.getTipoPieza()) {
-			case PEON:
+			case PAWN:
 				if (mov.getCasillaComer() != null)
-					temp.append (mov.getCasillaOrigen().getLetra());
+					temp.append (mov.getCasillaOrigen().getFile());
 				break;
-			case CABALLO:
-				for(DirectionVector v: pieza.getDirecciones()) {
+			case KNIGHT:
+				for(DirectionVector v: pieza.getDirections()) {
 					try {
 						Piece p = getPieza(mov.getCasillaDestino().add(v));
-						if(p!=null && p.getTipo() == Tipo.CABALLO && p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
+						if(p!=null && p.getType() == Type.KNIGHT && p.getSide() == pieza.getSide()) {
+							if(mov.getCasillaOrigen().getFile() != p.getSquare().getFile()) {
+								temp.append(mov.getCasillaOrigen().getFile());
 								break;
 							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
+								temp.append (mov.getCasillaOrigen().getRank());
 								break;
 							}
 						}
@@ -803,22 +803,22 @@
 				}
 				break;
 
-			case ALFIL:
-			case TORRE:
-			case DAMA:
-				for(DirectionVector v: pieza.getDirecciones()) {
+			case BISHOP:
+			case ROOK:
+			case QUEEN:
+				for(DirectionVector v: pieza.getDirections()) {
 					try {
 						Square destino = mov.getCasillaDestino().add(v);
 						Piece p;
 						while((p=getPieza(destino))==null) {
 							destino.add(v);
 						}
-						if(p!=null && p.getTipo() == pieza.getTipo() && p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
+						if(p!=null && p.getType() == pieza.getType() && p.getSide() == pieza.getSide()) {
+							if(mov.getCasillaOrigen().getFile() != p.getSquare().getFile()) {
+								temp.append(mov.getCasillaOrigen().getFile());
 								break;
 							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
+								temp.append (mov.getCasillaOrigen().getRank());
 								break;
 							}
 						}
@@ -856,9 +856,9 @@
 
 	void setPiezaInternal(Piece p, char letra, char num) {
 		tabla[num - '1'][letra - 'a'] = p;
-		if (p.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(p.getBando())].setLetra(letra);
-			kingPosition[bandoToInt(p.getBando())].setNumero(num);
+		if (p.getType() == Type.KING) {
+			kingPosition[bandoToInt(p.getSide())].setFile(letra);
+			kingPosition[bandoToInt(p.getSide())].setRank(num);
 		}
 	}
 }

Modified: trunk/MihailChessLib/com/mihail/chess/Square.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Square.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/Square.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -71,7 +71,7 @@
 	 * @return La letra de la casilla
 	 */
 
-	public char getLetra() {
+	public char getFile() {
 		return letra;
 	}
 	
@@ -81,7 +81,7 @@
 	 * @param letra La letra de la casilla
 	 */
 
-	public void setLetra(char letra) {
+	public void setFile(char letra) {
 		this.letra = letra;
 	}
 	
@@ -91,7 +91,7 @@
 	 * @return El numero de la casilla
 	 */
 
-	public char getNumero() {
+	public char getRank() {
 		return numero;
 	}
 	
@@ -101,7 +101,7 @@
 	 * @param numero El numero de la casilla
 	 */
 
-	public void setNumero(char numero) {
+	public void setRank(char numero) {
 		this.numero = numero;
 	}
 

Modified: trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 13:12:03 UTC (rev 35)
+++ trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 13:30:00 UTC (rev 36)
@@ -64,14 +64,14 @@
 	 *            Numero del movimiento
 	 * @return Devuelve el movimiento correspondiente a color y numero
 	 */
-	public Movement getMovimiento(Side color, int numero) {
+	public Movement getMove(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 		if (n != null)
 			return n.movimiento;
 		return null;
 	}
 	
-	public Movement getMovimiento(int halfPly) {
+	public Movement getMove(int halfPly) {
 		return arbol.get(halfPly).movimiento;
 	}
 
@@ -85,7 +85,7 @@
 	 * @return Un booleano que indica si para ese movimiento existen
 	 *         alternativas.
 	 */
-	public boolean existeVariante(Side color, int numero) {
+	public boolean existsVariation(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n != null && n.variantes != null)
@@ -102,7 +102,7 @@
 	 *            Numero del movimiento.
 	 * @return El numero de alternativas a un movimiento.
 	 */
-	public int getNumVariantes(Side color, int numero) {
+	public int getVariationsNumber(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n != null) {
@@ -136,7 +136,7 @@
 	 * @param numero
 	 *            Numero del movimiento.
 	 */
-	public void addVariante(Movement mov, Side color, int numero) {
+	public void addVariation(Movement mov, Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n.variantes == null)
@@ -159,7 +159,7 @@
 	 *            Numero de variante que se quiere obtener.
 	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
 	 */
-	public VariationsTree getVariante(Side color, int numero, int num) {
+	public VariationsTree getVariation(Side color, int numero, int num) {
 		NodoArbol n = getNodo(color, numero);
 		if (n != null)
 			return n.variantes.get(num);
@@ -171,7 +171,7 @@
 	 *         partida. Solo cuenta los turnos jugados, no cuenta un movimiento
 	 *         por negras y otro por blancas.
 	 */
-	public int getNumMovimientos() {
+	public int getFullmoveNumber() {
 		return desplazamiento + ((arbol.size() + 1) / 2);
 	}
 
@@ -182,7 +182,7 @@
 	 * @return Los medios movimientos desde el comienzo de la partida.
 	 */
 
-	public int getNumHalfPly() {
+	public int getHalfmoveNumber() {
 		return arbol.size();
 	}
 
@@ -192,7 +192,7 @@
 	 * @return
 	 */
 
-	public Movement getLastMovimiento() {
+	public Movement getLastMove() {
 		return arbol.get(arbol.size() - 1).movimiento;
 	}
 	
@@ -204,8 +204,8 @@
 	 * @param num
 	 */
 	
-	public void promoteVariant(Side color, int numero, int num) {
-		VariationsTree a = getVariante(color, numero, num);
+	public void promoteVariation(Side color, int numero, int num) {
+		VariationsTree a = getVariation(color, numero, num);
 		int indice = (numero - 1) * 2 + bandoToInt(color);
 		NodoArbol n = getNodo(color, numero);
 		



From gauleng at berlios.de  Thu Aug 18 12:52:40 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Thu, 18 Aug 2005 12:52:40 +0200
Subject: [Mihailchess-svn] r40 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508181052.j7IAqeLW027123@sheep.berlios.de>

Author: gauleng
Date: 2005-08-18 12:52:36 +0200 (Thu, 18 Aug 2005)
New Revision: 40

Added:
   trunk/MihailChessLib/com/mihail/chess/Move.java
Removed:
   trunk/MihailChessLib/com/mihail/chess/Movement.java
Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
   trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
Log:
Mejor Move

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 13:44:19 UTC (rev 39)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 10:52:36 UTC (rev 40)
@@ -516,11 +516,11 @@
 	 *            Es el numero de la casilla de destino
 	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
 	 */
-	public Movement move(char origenLetra, char origenNum,
+	public Move move(char origenLetra, char origenNum,
 			char destinoLetra, char destinoNum) {
 		Piece piezaQueMueve;
 		int i;
-		Movement mov;
+		Move mov;
 		piezaQueMueve = posicion.getPieza(origenLetra, origenNum);
 
 		// Comprobamos que en la casilla de origen hay una pieza
@@ -549,7 +549,7 @@
 				// valido
 				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
 						.getFile()) {
-					mov = new Movement();
+					mov = new Move();
 					mov.setCasillaOrigen(new Square(origenLetra, origenNum));
 					mov
 							.setCasillaDestino(new Square(destinoLetra,
@@ -659,8 +659,8 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Movement goBack() {
-		Movement mov;
+	public Move goBack() {
+		Move mov;
 		Piece piezaQueMueve;
 		if (indice < movimientos.getHalfmoveNumber()) {
 			mov = movimientos.getMove(indice);
@@ -718,8 +718,8 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Movement goForward() {
-		Movement mov;
+	public Move goForward() {
+		Move mov;
 		Piece piezaQueMueve;
 		if (indice > 0) {
 			indice--;
@@ -878,7 +878,7 @@
 	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
 	 *       tenerlo en cuenta.
 	 */
-	public Movement moveALG(String mov) {
+	public Move moveALG(String mov) {
 		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
 		char tipoPieza = 'P';
 		Type piezaCoronacion = null;

Copied: trunk/MihailChessLib/com/mihail/chess/Move.java (from rev 36, trunk/MihailChessLib/com/mihail/chess/Movement.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 13:30:00 UTC (rev 36)
+++ trunk/MihailChessLib/com/mihail/chess/Move.java	2005-08-18 10:52:36 UTC (rev 40)
@@ -0,0 +1,241 @@
+package com.mihail.chess;
+
+import static com.mihail.chess.Board.Side;
+
+import com.mihail.chess.Board.Result;
+import com.mihail.chess.Piece.Type;
+
+/**
+ * Esta clase define un objeto Movimiento, que guarda informacion sobre el
+ * movimiento que se realiza y sobre el estado de la partida en ese momento (qu?
+ * enroques son posibles, es jaque, etc).
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Move {
+
+	/**
+	 * Este atributo indica la letra de la casilla origen.
+	 */
+	// public char origenLetra;
+	/**
+	 * Este atributo indica el numero de la casilla origen.
+	 */
+	// public char origenNum;
+	private Square casillaOrigen;
+
+	/**
+	 * Este atributo indica la letra de la casilla destino.
+	 */
+	// public char destinoLetra;
+	/**
+	 * Este atributo indica el numero de la casilla destino.
+	 */
+	// public char destinoNum;
+	private Square casillaDestino;
+
+	/**
+	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
+	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
+	 * 1 como numero de movimiento.
+	 */
+	private int numeroMovimiento;
+
+	/**
+	 * Bando que mueve.
+	 */
+	private Side bando;
+
+	/**
+	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
+	 * 
+	 */
+	private Type tipoPieza;
+
+	/**
+	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerLetra;
+	/**
+	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerNum;
+	private Square casillaComer;
+
+	/**
+	 * Este atributo indica si el movimiento produce un jaque.
+	 */
+	private boolean jaque;
+
+	/**
+	 * Este atributo indica si el movimiento termina la partida y quien es el
+	 * ganador o bien tablas. <BR>
+	 * 'B' -> Ganan blancas <BR>
+	 * 'N' -> Ganan negras <BR>
+	 * 'T' -> Tablas <BR>
+	 * 0 -> No ha terminado la partida
+	 */
+	private Result finPartida;
+
+	/**
+	 * Este atributo indica si se ha producido una coronacion y a que pieza se
+	 * promociona. <BR>
+	 * 'C' -> Caballo <BR>
+	 * 'A' -> Alfil <BR>
+	 * 'T' -> Torre <BR>
+	 * 'D' -> Dama <BR>
+	 * 0 -> No hay coronacion
+	 */
+	private Type coronacion;
+
+	/**
+	 * Este atributo indica el valor de contadorTablas en el momento que se
+	 * produce el movimiento.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos en el
+	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
+	 * enroque[0][0] -> Blancas, enroque corto <BR>
+	 * enroque[0][1] -> Blancas, enroque largo <BR>
+	 * enroque[1][0] -> Negras, enroque corto <BR>
+	 * enroque[1][1] -> Negras, enroque largo <BR>
+	 */
+	private boolean[][] enroque;
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+
+	/**
+	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	private Type tipoPiezaComida;
+
+	/**
+	 * Este atributo guarda la representacion del movimiento en notacion
+	 * algebraica.
+	 */
+	private String notacion;
+
+	public Square getCasillaDestino() {
+		return casillaDestino;
+	}
+
+	public void setCasillaDestino(Square casillaDestino) {
+		this.casillaDestino = casillaDestino;
+	}
+
+	public Square getCasillaOrigen() {
+		return casillaOrigen;
+	}
+
+	public void setCasillaOrigen(Square casillaOrigen) {
+		this.casillaOrigen = casillaOrigen;
+	}
+
+	public Side getBando() {
+		return bando;
+	}
+
+	public void setBando(Side bando) {
+		this.bando = bando;
+	}
+
+	public int getNumeroMovimiento() {
+		return numeroMovimiento;
+	}
+
+	public void setNumeroMovimiento(int numeroMovimiento) {
+		this.numeroMovimiento = numeroMovimiento;
+	}
+
+	public Type getTipoPieza() {
+		return tipoPieza;
+	}
+
+	public void setTipoPieza(Type tipoPieza) {
+		this.tipoPieza = tipoPieza;
+	}
+
+	public Square getCasillaComer() {
+		return casillaComer;
+	}
+
+	public void setCasillaComer(Square casillaComer) {
+		this.casillaComer = casillaComer;
+	}
+
+	public int getContadorTablas() {
+		return contadorTablas;
+	}
+
+	public void setContadorTablas(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+
+	public Type getCoronacion() {
+		return coronacion;
+	}
+
+	public void setCoronacion(Type coronacion) {
+		this.coronacion = coronacion;
+	}
+
+	public boolean[][] getEnroque() {
+		return enroque;
+	}
+
+	public void setEnroque(boolean[][] enroque) {
+		this.enroque = enroque;
+	}
+
+	public Result getFinPartida() {
+		return finPartida;
+	}
+
+	public void setFinPartida(Result finPartida) {
+		this.finPartida = finPartida;
+	}
+
+	public boolean isJaque() {
+		return jaque;
+	}
+
+	public void setJaque(boolean jaque) {
+		this.jaque = jaque;
+	}
+
+	public char getAlPaso() {
+		return alPaso;
+	}
+
+	public void setAlPaso(char alPaso) {
+		this.alPaso = alPaso;
+	}
+
+	public String getNotacion() {
+		return notacion;
+	}
+
+	public void setNotacion(String notacion) {
+		this.notacion = notacion;
+	}
+
+	public Type getTipoPiezaComida() {
+		return tipoPiezaComida;
+	}
+
+	public void setTipoPiezaComida(Type tipoPiezaComida) {
+		this.tipoPiezaComida = tipoPiezaComida;
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Movement.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 13:44:19 UTC (rev 39)
+++ trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-18 10:52:36 UTC (rev 40)
@@ -1,241 +0,0 @@
-package com.mihail.chess;
-
-import static com.mihail.chess.Board.Side;
-
-import com.mihail.chess.Board.Result;
-import com.mihail.chess.Piece.Type;
-
-/**
- * Esta clase define un objeto Movimiento, que guarda informacion sobre el
- * movimiento que se realiza y sobre el estado de la partida en ese momento (qu?
- * enroques son posibles, es jaque, etc).
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Movement {
-
-	/**
-	 * Este atributo indica la letra de la casilla origen.
-	 */
-	// public char origenLetra;
-	/**
-	 * Este atributo indica el numero de la casilla origen.
-	 */
-	// public char origenNum;
-	private Square casillaOrigen;
-
-	/**
-	 * Este atributo indica la letra de la casilla destino.
-	 */
-	// public char destinoLetra;
-	/**
-	 * Este atributo indica el numero de la casilla destino.
-	 */
-	// public char destinoNum;
-	private Square casillaDestino;
-
-	/**
-	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
-	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
-	 * 1 como numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Bando que mueve.
-	 */
-	private Side bando;
-
-	/**
-	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
-	 * 
-	 */
-	private Type tipoPieza;
-
-	/**
-	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerLetra;
-	/**
-	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerNum;
-	private Square casillaComer;
-
-	/**
-	 * Este atributo indica si el movimiento produce un jaque.
-	 */
-	private boolean jaque;
-
-	/**
-	 * Este atributo indica si el movimiento termina la partida y quien es el
-	 * ganador o bien tablas. <BR>
-	 * 'B' -> Ganan blancas <BR>
-	 * 'N' -> Ganan negras <BR>
-	 * 'T' -> Tablas <BR>
-	 * 0 -> No ha terminado la partida
-	 */
-	private Result finPartida;
-
-	/**
-	 * Este atributo indica si se ha producido una coronacion y a que pieza se
-	 * promociona. <BR>
-	 * 'C' -> Caballo <BR>
-	 * 'A' -> Alfil <BR>
-	 * 'T' -> Torre <BR>
-	 * 'D' -> Dama <BR>
-	 * 0 -> No hay coronacion
-	 */
-	private Type coronacion;
-
-	/**
-	 * Este atributo indica el valor de contadorTablas en el momento que se
-	 * produce el movimiento.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos en el
-	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
-	 * enroque[0][0] -> Blancas, enroque corto <BR>
-	 * enroque[0][1] -> Blancas, enroque largo <BR>
-	 * enroque[1][0] -> Negras, enroque corto <BR>
-	 * enroque[1][1] -> Negras, enroque largo <BR>
-	 */
-	private boolean[][] enroque;
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	private Type tipoPiezaComida;
-
-	/**
-	 * Este atributo guarda la representacion del movimiento en notacion
-	 * algebraica.
-	 */
-	private String notacion;
-
-	public Square getCasillaDestino() {
-		return casillaDestino;
-	}
-
-	public void setCasillaDestino(Square casillaDestino) {
-		this.casillaDestino = casillaDestino;
-	}
-
-	public Square getCasillaOrigen() {
-		return casillaOrigen;
-	}
-
-	public void setCasillaOrigen(Square casillaOrigen) {
-		this.casillaOrigen = casillaOrigen;
-	}
-
-	public Side getBando() {
-		return bando;
-	}
-
-	public void setBando(Side bando) {
-		this.bando = bando;
-	}
-
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public Type getTipoPieza() {
-		return tipoPieza;
-	}
-
-	public void setTipoPieza(Type tipoPieza) {
-		this.tipoPieza = tipoPieza;
-	}
-
-	public Square getCasillaComer() {
-		return casillaComer;
-	}
-
-	public void setCasillaComer(Square casillaComer) {
-		this.casillaComer = casillaComer;
-	}
-
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
-	public Type getCoronacion() {
-		return coronacion;
-	}
-
-	public void setCoronacion(Type coronacion) {
-		this.coronacion = coronacion;
-	}
-
-	public boolean[][] getEnroque() {
-		return enroque;
-	}
-
-	public void setEnroque(boolean[][] enroque) {
-		this.enroque = enroque;
-	}
-
-	public Result getFinPartida() {
-		return finPartida;
-	}
-
-	public void setFinPartida(Result finPartida) {
-		this.finPartida = finPartida;
-	}
-
-	public boolean isJaque() {
-		return jaque;
-	}
-
-	public void setJaque(boolean jaque) {
-		this.jaque = jaque;
-	}
-
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	public void setAlPaso(char alPaso) {
-		this.alPaso = alPaso;
-	}
-
-	public String getNotacion() {
-		return notacion;
-	}
-
-	public void setNotacion(String notacion) {
-		this.notacion = notacion;
-	}
-
-	public Type getTipoPiezaComida() {
-		return tipoPiezaComida;
-	}
-
-	public void setTipoPiezaComida(Type tipoPiezaComida) {
-		this.tipoPiezaComida = tipoPiezaComida;
-	}
-}
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/Position.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 13:44:19 UTC (rev 39)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-18 10:52:36 UTC (rev 40)
@@ -763,7 +763,7 @@
 	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
 	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
 	 */
-	private String generarNotacionALG (Movement mov) {
+	private String generarNotacionALG (Move mov) {
 		StringBuffer temp = new StringBuffer ();
 
 		if (mov.getTipoPieza() == Type.KING) {

Modified: trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 13:44:19 UTC (rev 39)
+++ trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-18 10:52:36 UTC (rev 40)
@@ -14,11 +14,11 @@
  */
 public class VariationsTree {
 	private class NodoArbol {
-		public Movement movimiento;
+		public Move movimiento;
 
 		public ArrayList<VariationsTree> variantes;
 
-		public NodoArbol(Movement mov) {
+		public NodoArbol(Move mov) {
 			movimiento = mov;
 		}
 	}
@@ -50,7 +50,7 @@
 	 * @param mov
 	 *            Movimiento que se a?ade.
 	 */
-	public void appendMovimiento(Movement mov) {
+	public void appendMovimiento(Move mov) {
 		arbol.add(new NodoArbol(mov));
 	}
 
@@ -64,14 +64,14 @@
 	 *            Numero del movimiento
 	 * @return Devuelve el movimiento correspondiente a color y numero
 	 */
-	public Movement getMove(Side color, int numero) {
+	public Move getMove(Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 		if (n != null)
 			return n.movimiento;
 		return null;
 	}
 	
-	public Movement getMove(int halfPly) {
+	public Move getMove(int halfPly) {
 		return arbol.get(halfPly).movimiento;
 	}
 
@@ -136,7 +136,7 @@
 	 * @param numero
 	 *            Numero del movimiento.
 	 */
-	public void addVariation(Movement mov, Side color, int numero) {
+	public void addVariation(Move mov, Side color, int numero) {
 		NodoArbol n = getNodo(color, numero);
 
 		if (n.variantes == null)
@@ -144,7 +144,7 @@
 
 		VariationsTree a = new VariationsTree(numero);
 		if (color == Side.BLACK) // Cada arbol de variantes debe empezar con un movimiento de blancas
-			a.appendMovimiento(new Movement());
+			a.appendMovimiento(new Move());
 		a.appendMovimiento(mov);
 
 		n.variantes.add(a);
@@ -192,7 +192,7 @@
 	 * @return
 	 */
 
-	public Movement getLastMove() {
+	public Move getLastMove() {
 		return arbol.get(arbol.size() - 1).movimiento;
 	}
 	



From gauleng at berlios.de  Thu Aug 18 12:53:00 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Thu, 18 Aug 2005 12:53:00 +0200
Subject: [Mihailchess-svn] r41 - trunk/MihailChessLib/com/mihail/pgn
Message-ID: <200508181053.j7IAr0iU027437@sheep.berlios.de>

Author: gauleng
Date: 2005-08-18 12:52:52 +0200 (Thu, 18 Aug 2005)
New Revision: 41

Modified:
   trunk/MihailChessLib/com/mihail/pgn/Game.java
Log:
Mejor Move

Modified: trunk/MihailChessLib/com/mihail/pgn/Game.java
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/Game.java	2005-08-18 10:52:36 UTC (rev 40)
+++ trunk/MihailChessLib/com/mihail/pgn/Game.java	2005-08-18 10:52:52 UTC (rev 41)
@@ -2,7 +2,7 @@
 
 import java.util.ArrayList;
 
-import com.mihail.chess.Movement;
+import com.mihail.chess.Move;
 
 /**
  * Esta clase define un objeto partida y sus caracteristicas: evento, sitio,
@@ -56,13 +56,13 @@
 	 * 
 	 * @return La lista de movimientos de la partida
 	 */
-	public Movement[] getListaMovimientos() {
+	public Move[] getListaMovimientos() {
 		return null;
 	}
 
 	/**
 	 * 
 	 */
-	public void setListaMovimientos(Movement[] listaMovs) {
+	public void setListaMovimientos(Move[] listaMovs) {
 	}
 }



From gauleng at berlios.de  Thu Aug 18 13:39:59 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Thu, 18 Aug 2005 13:39:59 +0200
Subject: [Mihailchess-svn] r42 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508181139.j7IBdxgd023911@sheep.berlios.de>

Author: gauleng
Date: 2005-08-18 13:39:56 +0200 (Thu, 18 Aug 2005)
New Revision: 42

Added:
   trunk/MihailChessLib/com/mihail/chess/BoardStatus.java
Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Move.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
Log:
Anadido BoardStatus

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 10:52:52 UTC (rev 41)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 11:39:56 UTC (rev 42)
@@ -554,8 +554,6 @@
 					mov
 							.setCasillaDestino(new Square(destinoLetra,
 									destinoNum));
-					mov.setNumeroMovimiento(posicion.getFullmoveNumber());
-					mov.setBando(posicion.getTurn());
 					mov.setTipoPieza(piezaQueMueve.getType());
 
 					// Si se come ponemos el contador a 0
@@ -584,7 +582,7 @@
 						// correspondiente
 						if (Math.abs(destinoNum - origenNum) == 2) {
 							posicion.setEnPassant(origenLetra);
-							mov.setAlPaso(posicion.getEnPassant());
+							mov.getFinalBoardStatus().setEnPassant(posicion.getEnPassant());
 						} else {
 							posicion.setEnPassant('\0');
 						}
@@ -617,13 +615,7 @@
 						}
 					}
 
-					mov.setContadorTablas(posicion.getHalfmoveClock());
-					boolean[][] enroque = new boolean[2][2];
-					enroque[0][0] = posicion.getKingsideCastling(Side.WHITE);
-					enroque[0][1] = posicion.getQueensideCastling(Side.WHITE);
-					enroque[1][0] = posicion.getKingsideCastling(Side.BLACK);
-					enroque[1][1] = posicion.getQueensideCastling(Side.BLACK);
-					mov.setEnroque(enroque);
+					mov.getFinalBoardStatus().setStatus(posicion.status);
 					if (posicion.getTurn() == Side.BLACK)
 						posicion.addFullmoveNumber();
 					posicion.setTurn();
@@ -697,16 +689,11 @@
 			}
 			posicion.removePiece(mov.getCasillaOrigen());
 			posicion.setPiece(piezaQueMueve, mov.getCasillaDestino());
-			posicion.setHalfmoveClock(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setKingsideCastling(Side.WHITE, enroques[0][0]);
-			posicion.setQueensideCastling(Side.WHITE, enroques[0][1]);
-			posicion.setKingsideCastling(Side.BLACK, enroques[1][0]);
-			posicion.setQueensideCastling(Side.BLACK, enroques[1][1]);
-			posicion.setEnPassant(mov.getAlPaso());
+
+			posicion.status.setStatus(mov.getFinalBoardStatus());
+
 			posicion.setTurn();
 			indice++;
-			posicion.setFullmoveNumber(mov.getNumeroMovimiento());
 			return mov;
 		} else {
 			return null;
@@ -724,7 +711,6 @@
 		if (indice > 0) {
 			indice--;
 			mov = movimientos.getMove(indice);
-			posicion.setFullmoveNumber(mov.getNumeroMovimiento());
 			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
 			if (mov.getCoronacion() != null) {
 				piezaQueMueve = new Piece(piezaQueMueve.getSide(), mov
@@ -755,13 +741,9 @@
 						.getCasillaComer());
 			}
 			posicion.setPiece(piezaQueMueve, mov.getCasillaOrigen());
-			posicion.setHalfmoveClock(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setKingsideCastling(Side.WHITE, enroques[0][0]);
-			posicion.setQueensideCastling(Side.WHITE, enroques[0][1]);
-			posicion.setKingsideCastling(Side.BLACK, enroques[1][0]);
-			posicion.setQueensideCastling(Side.BLACK, enroques[1][1]);
-			posicion.setEnPassant(mov.getAlPaso());
+			
+			posicion.status.setStatus(mov.getFinalBoardStatus());
+			
 			posicion.setTurn();
 			return mov;
 		} else {

Added: trunk/MihailChessLib/com/mihail/chess/BoardStatus.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardStatus.java	2005-08-18 10:52:52 UTC (rev 41)
+++ trunk/MihailChessLib/com/mihail/chess/BoardStatus.java	2005-08-18 11:39:56 UTC (rev 42)
@@ -0,0 +1,179 @@
+package com.mihail.chess;
+
+import com.mihail.chess.Board.Side;
+
+public class BoardStatus {
+	/**
+	 * Este atributo indica el valor de contadorTablas en el momento que se
+	 * produce el movimiento.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos en el
+	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
+	 * enroque[0][0] -> Blancas, enroque corto <BR>
+	 * enroque[0][1] -> Blancas, enroque largo <BR>
+	 * enroque[1][0] -> Negras, enroque corto <BR>
+	 * enroque[1][1] -> Negras, enroque largo <BR>
+	 */
+	private boolean[][] enroque;
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+	
+	/**
+	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
+	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
+	 * 1 como numero de movimiento.
+	 */
+	private int numeroMovimiento;
+	
+
+	/**
+	 * Bando que mueve.
+	 */
+	private Side bando;
+	
+	public BoardStatus() {
+		enroque = new boolean[2][2];
+		enroque[0][0] = false;
+		enroque[0][1] = false;
+		enroque[1][0] = false;
+		enroque[1][1] = false;
+	}
+	
+	public BoardStatus(BoardStatus original) {
+		this.setStatus(original);
+	}
+	
+	/**
+	 * Permite saber si el enroque corto esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque corto puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getKingsideCastling(Side c) {
+		switch (c) {
+		case WHITE:
+			return enroque[0][0];
+		case BLACK:
+			return enroque[1][0];
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+	
+	public void setKingsideCastling(Side c, boolean b) {
+		switch (c) {
+		case WHITE:
+			enroque[0][0] = b;
+		case BLACK:
+			enroque[1][0] = b;
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+
+	/**
+	 * Permite saber si el enroque largo esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque largo puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getQueensideCastling(Side c) {
+		switch (c) {
+		case WHITE:
+			return enroque[0][1];
+		case BLACK:
+			return enroque[1][1];
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+	
+	public void setQueensideCastling(Side c, boolean b) {
+		switch (c) {
+		case WHITE:
+			enroque[0][1] = b;
+		case BLACK:
+			enroque[1][1] = b;
+		}
+		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
+				+ this);
+	}
+	
+	/**
+	 * Este metodo nos permite consultar el valor del turno.
+	 * 
+	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
+	 */
+	public Side getTurn() {
+		return bando;
+	}
+	
+
+	/**
+	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
+	 * 
+	 * @param t
+	 *            BLANCO -> blancas <BR>
+	 *            NEGRO -> negras
+	 */
+	public void setTurn(Side t) {
+		bando = t;
+	}
+	
+	/**
+	 * @return Devuelve numeroMovimiento.
+	 */
+	public int getFullmoveNumber() {
+		return numeroMovimiento;
+	}
+	
+	public void setFullmoveNumber(int num) {
+		this.numeroMovimiento = num;
+	}
+	
+	/**
+	 * @return Returns the alPaso.
+	 */
+	public char getEnPassant() {
+		return alPaso;
+	}
+	
+	public void setEnPassant(char columna) {
+		this.alPaso = columna;
+	}
+	
+	/**
+	 * @return Returns the contadorTablas.
+	 */
+	public int getHalfmoveClock() {
+		return contadorTablas;
+	}
+
+	/**
+	 * @param contadorTablas
+	 *            The contadorTablas to set.
+	 */
+	public void setHalfmoveClock(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+	
+	public void setStatus(BoardStatus original) {
+		this.alPaso = original.alPaso;
+		this.bando = original.bando;
+		this.contadorTablas = original.contadorTablas;
+		this.enroque  = original.enroque;
+		this.numeroMovimiento = original.numeroMovimiento;
+	}
+}

Modified: trunk/MihailChessLib/com/mihail/chess/Move.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Move.java	2005-08-18 10:52:52 UTC (rev 41)
+++ trunk/MihailChessLib/com/mihail/chess/Move.java	2005-08-18 11:39:56 UTC (rev 42)
@@ -37,18 +37,6 @@
 	private Square casillaDestino;
 
 	/**
-	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
-	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
-	 * 1 como numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Bando que mueve.
-	 */
-	private Side bando;
-
-	/**
 	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
 	 * 
 	 */
@@ -67,11 +55,6 @@
 	private Square casillaComer;
 
 	/**
-	 * Este atributo indica si el movimiento produce un jaque.
-	 */
-	private boolean jaque;
-
-	/**
 	 * Este atributo indica si el movimiento termina la partida y quien es el
 	 * ganador o bien tablas. <BR>
 	 * 'B' -> Ganan blancas <BR>
@@ -93,29 +76,6 @@
 	private Type coronacion;
 
 	/**
-	 * Este atributo indica el valor de contadorTablas en el momento que se
-	 * produce el movimiento.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos en el
-	 * momento en que se produce el movimiento. Es un array 2x2, en donde: <BR>
-	 * enroque[0][0] -> Blancas, enroque corto <BR>
-	 * enroque[0][1] -> Blancas, enroque largo <BR>
-	 * enroque[1][0] -> Negras, enroque corto <BR>
-	 * enroque[1][1] -> Negras, enroque largo <BR>
-	 */
-	private boolean[][] enroque;
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
 	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
 	 * producido una captura contiene un 0.
 	 */
@@ -126,6 +86,13 @@
 	 * algebraica.
 	 */
 	private String notacion;
+	
+	/**
+	 * Este atributo indica si el movimiento produce un jaque.
+	 */
+	private boolean jaque;
+	
+	private BoardStatus status = new BoardStatus();
 
 	public Square getCasillaDestino() {
 		return casillaDestino;
@@ -142,23 +109,7 @@
 	public void setCasillaOrigen(Square casillaOrigen) {
 		this.casillaOrigen = casillaOrigen;
 	}
-
-	public Side getBando() {
-		return bando;
-	}
-
-	public void setBando(Side bando) {
-		this.bando = bando;
-	}
-
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
+	
 	public Type getTipoPieza() {
 		return tipoPieza;
 	}
@@ -175,14 +126,6 @@
 		this.casillaComer = casillaComer;
 	}
 
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
 	public Type getCoronacion() {
 		return coronacion;
 	}
@@ -191,14 +134,6 @@
 		this.coronacion = coronacion;
 	}
 
-	public boolean[][] getEnroque() {
-		return enroque;
-	}
-
-	public void setEnroque(boolean[][] enroque) {
-		this.enroque = enroque;
-	}
-
 	public Result getFinPartida() {
 		return finPartida;
 	}
@@ -214,15 +149,7 @@
 	public void setJaque(boolean jaque) {
 		this.jaque = jaque;
 	}
-
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	public void setAlPaso(char alPaso) {
-		this.alPaso = alPaso;
-	}
-
+	
 	public String getNotacion() {
 		return notacion;
 	}
@@ -238,4 +165,8 @@
 	public void setTipoPiezaComida(Type tipoPiezaComida) {
 		this.tipoPiezaComida = tipoPiezaComida;
 	}
+	
+	public BoardStatus getFinalBoardStatus() {
+		return status;
+	}
 }
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/Position.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-18 10:52:52 UTC (rev 41)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-18 11:39:56 UTC (rev 42)
@@ -4,6 +4,7 @@
 import static com.mihail.chess.Piece.Type;
 
 import com.mihail.chess.Board.Result;
+import com.mihail.chess.Board.Side;
 import com.mihail.chess.Piece.Type;
 
 public class Position {
@@ -31,42 +32,6 @@
 	private Piece[][] tabla = new Piece[8][8];
 
 	/**
-	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
-	 * blancas y NEGRO cuando mueven negras.
-	 */
-	private Side turno;
-
-	/**
-	 * Este atributo indica el numero de movimiento por el que va la partida.
-	 * Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el 1 como
-	 * numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos. Es
-	 * un array 2x2, en donde: <BR>
-	 * enroque[0][0] -> Blancas, enroque corto <BR>
-	 * enroque[0][1] -> Blancas, enroque largo <BR>
-	 * enroque[1][0] -> Negras, enroque corto <BR>
-	 * enroque[1][1] -> Negras, enroque largo
-	 */
-	private boolean[][] enroque = new boolean[2][2];
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo sirve para contar movimientos a la hora de declarar las
-	 * tablas por la regla de los 50 movimientos.
-	 */
-	private int contadorTablas;
-
-	/**
 	 * Vamos almacenando la clave resultante para calcular la siguiente posicion
 	 * a partir de ella.
 	 */
@@ -86,6 +51,8 @@
 	 */
 
 	private Square[] kingPosition = new Square[2];
+	
+	BoardStatus status;
 
 	public Position() {
 		for (int i = 0; i < 2; i++) {
@@ -104,17 +71,14 @@
 				}
 			}
 		}
-		turno = Side.WHITE;
+		status = new BoardStatus();
+		status.setTurn(Side.WHITE);
 		kingPosition[0] = new Square();
 		kingPosition[1] = new Square();
-		enroque[0][0] = false;
-		enroque[0][1] = false;
-		enroque[1][0] = false;
-		enroque[1][1] = false;
-		alPaso = 0;
+		status.setEnPassant('\0');
 		clavePosicion = 0;
-		contadorTablas = 0;
-		numeroMovimiento = 1;
+		status.setHalfmoveClock(0);
+		status.setFullmoveNumber(1);
 	}
 
 	public Position(String posicion) {
@@ -235,31 +199,33 @@
 			cont = 0;
 		}
 
-		if (turno == Side.WHITE)
+		if (status.getTurn() == Side.WHITE)
 			cad += " w";
 		else
 			cad += " b";
 
 		cad += " ";
-		if (!enroque[0][0] && !enroque[0][1] && !enroque[1][0]
-				&& !enroque[1][1])
+		if (!status.getKingsideCastling(Side.WHITE) &&
+			!status.getQueensideCastling(Side.WHITE) &&
+			!status.getKingsideCastling(Side.BLACK) &&
+			!status.getQueensideCastling(Side.BLACK))
 			cad += "-";
 		else {
-			if (enroque[0][0])
+			if (status.getKingsideCastling(Side.WHITE))
 				cad += "K";
-			if (enroque[0][1])
+			if (status.getQueensideCastling(Side.WHITE))
 				cad += "Q";
-			if (enroque[1][0])
+			if (status.getKingsideCastling(Side.BLACK))
 				cad += "k";
-			if (enroque[1][1])
+			if (status.getQueensideCastling(Side.BLACK))
 				cad += "q";
 		}
-		if (alPaso != '\0')
-			cad += (" " + alPaso);
+		if (status.getEnPassant() != '\0')
+			cad += (" " + status.getEnPassant());
 		else
 			cad += (" -");
-		cad += (" " + contadorTablas);
-		cad += (" " + numeroMovimiento);
+		cad += (" " + status.getFullmoveNumber());
+		cad += (" " + status.getHalfmoveClock());
 		return cad;
 	}
 
@@ -279,6 +245,7 @@
 				tabla[i][j] = null;
 			}
 		}
+		status = new BoardStatus();
 		/*
 		 * hash.borrarTabla (); movimientos.clear (); indice = 0;
 		 */
@@ -352,15 +319,11 @@
 			}
 		}
 		if (FEN[1].charAt(0) == 'w') {
-			setTurn(Side.WHITE);
+			status.setTurn(Side.WHITE);
 		} else {
-			setTurn(Side.BLACK);
+			status.setTurn(Side.BLACK);
 		}
-		for (int i = 0; i <= 1; i++) {
-			for (int j = 0; j <= 1; j++) {
-				enroque[i][j] = false;
-			}
-		}
+
 		if (FEN[2].charAt(0) != '-') {
 			for (int i = 0; i < FEN[2].length(); i++) {
 				switch (FEN[2].charAt(i)) {
@@ -385,49 +348,11 @@
 		} else {
 			setEnPassant(FEN[3].charAt(0));
 		}
-		setHalfmoveClock((new Integer(FEN[4])).intValue());
-		setFullmoveNumber((new Integer(FEN[5])).intValue());
+		status.setHalfmoveClock((new Integer(FEN[4])).intValue());
+		status.setFullmoveNumber((new Integer(FEN[5])).intValue());
 	}
 
 	/**
-	 * Permite saber si el enroque corto esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque corto puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getKingsideCastling(Side c) {
-		switch (c) {
-		case WHITE:
-			return enroque[0][0];
-		case BLACK:
-			return enroque[1][0];
-		}
-		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
-				+ this);
-	}
-
-	/**
-	 * Permite saber si el enroque largo esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque largo puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getQueensideCastling(Side c) {
-		switch (c) {
-		case WHITE:
-			return enroque[0][1];
-		case BLACK:
-			return enroque[1][1];
-		}
-		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
-				+ this);
-	}
-
-	/**
 	 * Este metodo devuelve la pieza que se encuentra en una determinada
 	 * casilla. Si no hay ninguna pieza, devuelve null.
 	 * 
@@ -447,52 +372,20 @@
 	}
 
 	/**
-	 * Este metodo nos permite consultar el valor del turno.
-	 * 
-	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
-	 */
-	public Side getTurn() {
-		return turno;
-	}
-
-	/**
 	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
 	 * viceversa.
 	 */
 	public void setTurn() {
-		if (turno == Side.WHITE) {
-			turno = Side.BLACK;
+		if (status.getTurn() == Side.WHITE) {
+			status.setTurn(Side.BLACK);
 		} else {
-			turno = Side.WHITE;
+			status.setTurn(Side.WHITE);
 		}
 	}
-
-	/**
-	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
-	 * 
-	 * @param t
-	 *            BLANCO -> blancas <BR>
-	 *            NEGRO -> negras
-	 */
-	public void setTurn(Side t) {
-		turno = t;
-	}
-
+	
 	public boolean setKingsideCastling(Side b, boolean c) {
 		if (!c) {
-			int x;
-			switch (b) {
-			case WHITE:
-				x = 0;
-				break;
-			case BLACK:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						"El Bando solo puede ser BLANCO o NEGRO: " + this);
-			}
-			enroque[x][0] = c;
+			status.setKingsideCastling(b, false);
 			return true;
 		}
 		if (b == Side.WHITE) {
@@ -502,7 +395,7 @@
 					&& kingPosition[bandoToInt(Side.WHITE)].getRank() == '1'
 					&& p.getSide() == Side.WHITE
 					&& p.getType() == Type.ROOK) {
-				enroque[0][0] = c;
+				status.setKingsideCastling(Side.WHITE, c);
 				return true;
 			} else
 				return false;
@@ -512,29 +405,29 @@
 					&& kingPosition[bandoToInt(Side.BLACK)].getFile() == 'e'
 					&& kingPosition[bandoToInt(Side.BLACK)].getRank() == '8'
 					&& p.getSide() == Side.BLACK && p.getType() == Type.ROOK) {
-				enroque[1][0] = c;
+				status.setKingsideCastling(Side.BLACK, c);
 				return true;
 			} else
 				return false;
 		}
 		return false;
 	}
+	
+	/**
+	 * Permite saber si el enroque corto esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque corto puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getKingsideCastling(Side c) {
+		return status.getKingsideCastling(c);
+	}
 
 	public boolean setQueensideCastling(Side b, boolean c) {
 		if (!c) {
-			int x;
-			switch (b) {
-			case WHITE:
-				x = 0;
-				break;
-			case BLACK:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						"El Bando solo puede ser BLANCO o NEGRO: " + this);
-			}
-			enroque[x][1] = c;
+			status.setQueensideCastling(b, false);
 			return true;
 		}
 		if (b == Side.WHITE) {
@@ -544,7 +437,7 @@
 					&& kingPosition[0].getRank() == '1'
 					&& p.getSide() == Side.WHITE
 					&& p.getType() == Type.ROOK) {
-				enroque[0][1] = c;
+				status.setQueensideCastling(Side.WHITE, c);
 				return true;
 			} else
 				return false;
@@ -554,19 +447,24 @@
 					&& kingPosition[bandoToInt(Side.BLACK)].getFile() == 'e'
 					&& kingPosition[bandoToInt(Side.BLACK)].getRank() == '8'
 					&& p.getSide() == Side.BLACK && p.getType() == Type.ROOK) {
-				enroque[1][1] = c;
+				status.setQueensideCastling(Side.BLACK, c);
 				return true;
 			} else
 				return false;
 		}
 		return false;
 	}
-
+	
 	/**
-	 * @return Devuelve numeroMovimiento.
+	 * Permite saber si el enroque largo esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque largo puede realizarse, false en caso
+	 *         contrario.
 	 */
-	public int getFullmoveNumber() {
-		return numeroMovimiento;
+	public boolean getQueensideCastling(Side c) {
+		return status.getQueensideCastling(c);
 	}
 
 	/**
@@ -620,34 +518,34 @@
 		if (p != null) {
 			if (p.getType() == Type.KING) {
 				if (p.getSide() == Side.WHITE) {
-					enroque[0][0] = false;
-					enroque[0][1] = false;
+					status.setKingsideCastling(Side.WHITE, false);
+					status.setQueensideCastling(Side.WHITE, false);
 					kingPosition[bandoToInt(Side.WHITE)].setFile('\0');
 					kingPosition[bandoToInt(Side.WHITE)].setRank('\0');
 				} else {
-					enroque[1][0] = false;
-					enroque[1][1] = false;
+					status.setKingsideCastling(Side.BLACK, false);
+					status.setQueensideCastling(Side.BLACK, false);
 					kingPosition[bandoToInt(Side.BLACK)].setFile('\0');
 					kingPosition[bandoToInt(Side.BLACK)].setRank('\0');
 				}
 			} else if (p.getType() == Type.ROOK) {
 				if (p.getFile() == 'a' && p.getRank() == '1'
 						&& p.getSide() == Side.WHITE)
-					enroque[0][1] = false;
+					status.setQueensideCastling(Side.WHITE, false);
 				else if (p.getFile() == 'h' && p.getRank() == '1'
 						&& p.getSide() == Side.WHITE)
-					enroque[0][0] = false;
+					status.setKingsideCastling(Side.WHITE, false);
 				else if (p.getFile() == 'a' && p.getRank() == '8'
 						&& p.getSide() == Side.BLACK)
-					enroque[1][1] = false;
+					status.setQueensideCastling(Side.BLACK, false);
 				else if (p.getFile() == 'h' && p.getRank() == '8'
 						&& p.getSide() == Side.BLACK)
-					enroque[1][0] = false;
+					status.setKingsideCastling(Side.BLACK, false);
 			} else if (p.getType() == Type.PAWN) {
-				if (letra == alPaso
+				if (letra == status.getEnPassant()
 						&& (p.getSide() == Side.WHITE && num == '4')
 						|| (p.getSide() == Side.BLACK && num == '5'))
-					alPaso = 0;
+					status.setEnPassant('\0');
 			}
 			clavePosicion = clavePosicion
 					^ indices[bandoToInt(p.getSide())][tipoToInt(p.getType())][iNum][iLetra];
@@ -677,15 +575,8 @@
 	public int getPositionKey() {
 		return clavePosicion;
 	}
-
+	
 	/**
-	 * @return Returns the alPaso.
-	 */
-	public char getEnPassant() {
-		return alPaso;
-	}
-
-	/**
 	 * Establece la columna en la que un peon puede ser comido al paso. Es
 	 * decir, si un peon avanza dos casillas, entonces esa es la columna alPaso.
 	 * Es condicicion necesaria que en esa columna haya un peon que haya
@@ -697,12 +588,12 @@
 	 */
 	public void setEnPassant(char alPaso) {
 		if (alPaso == '\0') {
-			this.alPaso = alPaso;
+			this.status.setEnPassant(alPaso);
 			return;
 		}
 		boolean encontrado = false;
 		Piece p;
-		if (this.turno == Side.BLACK) {
+		if (this.status.getTurn() == Side.BLACK) {
 			p = getPieza(alPaso, '4');
 			encontrado = p != null && p.getSide() == Side.WHITE
 					&& p.getType() == Type.PAWN;
@@ -712,41 +603,18 @@
 					&& p.getType() == Type.PAWN;
 		}
 		if (encontrado)
-			this.alPaso = alPaso;
+			this.status.setEnPassant(alPaso);
 	}
 
-	/**
-	 * @return Returns the contadorTablas.
-	 */
-	public int getHalfmoveClock() {
-		return contadorTablas;
+	public void addFullmoveNumber() {
+		this.status.setFullmoveNumber(this.status.getFullmoveNumber()+1);
 	}
-
-	/**
-	 * @param contadorTablas
-	 *            The contadorTablas to set.
-	 */
-	public void setHalfmoveClock(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
+	
 	public void addHalfmoveClock() {
-		this.contadorTablas++;
+		this.status.setHalfmoveClock(this.status.getHalfmoveClock()+1);
 	}
 
 	/**
-	 * @param numeroMovimiento
-	 *            The numeroMovimiento to set.
-	 */
-	public void setFullmoveNumber(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public void addFullmoveNumber() {
-		this.numeroMovimiento++;
-	}
-
-	/**
 	 * @return Returns the kingPosition.
 	 */
 	public Square getKingPosition(Side color) {
@@ -843,8 +711,62 @@
 				temp.append ("+");
 		return temp.toString ();
 	}
+	
+	/**
+	 * Este metodo nos permite consultar el valor del turno.
+	 * 
+	 * @return Devuelve el valor del turno (0 -> blancas, 1 -> negras)
+	 */
+	public Side getTurn() {
+		return status.getTurn();
+	}
+	
 
 	/**
+	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
+	 * 
+	 * @param t
+	 *            BLANCO -> blancas <BR>
+	 *            NEGRO -> negras
+	 */
+	public void setTurn(Side t) {
+		status.setTurn(t);
+	}
+	
+	/**
+	 * @return Devuelve numeroMovimiento.
+	 */
+	public int getFullmoveNumber() {
+		return status.getFullmoveNumber();
+	}
+	
+	public void setFullmoveNumber(int num) {
+		status.setFullmoveNumber(num);
+	}
+	
+	/**
+	 * @return Returns the alPaso.
+	 */
+	public char getEnPassant() {
+		return status.getEnPassant();
+	}
+	
+	/**
+	 * @return Returns the contadorTablas.
+	 */
+	public int getHalfmoveClock() {
+		return status.getHalfmoveClock();
+	}
+
+	/**
+	 * @param contadorTablas
+	 *            The contadorTablas to set.
+	 */
+	public void setHalfmoveClock(int contadorTablas) {
+		status.setHalfmoveClock(contadorTablas);
+	}
+
+	/**
 	 * Funciones de uso interno. No usar directamente
 	 * 
 	 * @param letra



From gauleng at berlios.de  Thu Aug 18 15:15:24 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Thu, 18 Aug 2005 15:15:24 +0200
Subject: [Mihailchess-svn] r43 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508181315.j7IDFOga014929@sheep.berlios.de>

Author: gauleng
Date: 2005-08-18 15:15:23 +0200 (Thu, 18 Aug 2005)
New Revision: 43

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/BoardStatus.java
Log:
Corregidos errores en el calculo de movimientos

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 11:39:56 UTC (rev 42)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 13:15:23 UTC (rev 43)
@@ -64,6 +64,7 @@
 		movimientos = new VariationsTree();
 		posicion = posInicial;
 		hash.insert(posicion.getPositionKey());
+		this.calculateMoves();
 	}
 
 	/**
@@ -148,8 +149,8 @@
 						(char) (pieza.getRank() + 1))) {
 					if (esLegal(pieza.getFile(), pieza.getRank(), pieza
 							.getFile(), (char) (pieza.getRank() + 1))) {
-						pieza.addMove(pieza.getFile(), (char) (pieza
-								.getRank() + 1));
+						pieza.addMove(pieza.getFile(),
+								(char) (pieza.getRank() + 1));
 						if (pieza.getRank() == '2'
 								&& posicion.isEmpty(pieza.getFile(),
 										(char) (pieza.getRank() + 2))) {
@@ -182,8 +183,8 @@
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getFile() + 1),
-							(char) (pieza.getRank() - 1));
+					Piece p = posicion.getPieza((char) (pieza.getFile() - 1),
+							(char) (pieza.getRank() + 1));
 					if (p != null && p.getSide() == Side.BLACK) {
 						if (esLegal(pieza.getFile(), pieza.getRank(),
 								(char) (pieza.getFile() - 1), (char) (pieza
@@ -201,8 +202,8 @@
 						(char) (pieza.getRank() - 1))) {
 					if (esLegal(pieza.getFile(), pieza.getRank(), pieza
 							.getFile(), (char) (pieza.getRank() - 1))) {
-						pieza.addMove(pieza.getFile(), (char) (pieza
-								.getRank() - 1));
+						pieza.addMove(pieza.getFile(),
+								(char) (pieza.getRank() - 1));
 						if (pieza.getRank() == '7'
 								&& posicion.isEmpty(pieza.getFile(),
 										(char) (pieza.getRank() - 2))) {
@@ -221,9 +222,9 @@
 							.getRank() - 1));
 				}
 				try {
-					Piece p = posicion.getPieza((char) (pieza.getFile() - 1),
-							(char) (pieza.getRank() + 1));
-					if (p != null && p.getSide() == Side.BLACK) {
+					Piece p = posicion.getPieza((char) (pieza.getFile() + 1),
+							(char) (pieza.getRank() - 1));
+					if (p != null && p.getSide() == Side.WHITE) {
 						if (esLegal(pieza.getFile(), pieza.getRank(),
 								(char) (pieza.getFile() + 1), (char) (pieza
 										.getRank() - 1))) {
@@ -236,7 +237,7 @@
 				try {
 					Piece p = posicion.getPieza((char) (pieza.getFile() - 1),
 							(char) (pieza.getRank() - 1));
-					if (p != null && p.getSide() == Side.BLACK) {
+					if (p != null && p.getSide() == Side.WHITE) {
 						if (esLegal(pieza.getFile(), pieza.getRank(),
 								(char) (pieza.getFile() - 1), (char) (pieza
 										.getRank() - 1))) {
@@ -256,8 +257,7 @@
 							.getFile(), destino.getRank())) {
 						Piece p = posicion.getPieza(destino.getFile(), destino
 								.getRank());
-						if (p == null
-								|| (p != null && p.isOppositeSide(pieza)))
+						if (p == null || (p != null && p.isOppositeSide(pieza)))
 							pieza.addMove(destino);
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
@@ -279,8 +279,7 @@
 						if (esLegal(pieza.getFile(), pieza.getRank(), destino
 								.getFile(), destino.getRank())) {
 							if (p == null
-									|| (p != null && p.isOppositeSide(
-											pieza))) {
+									|| (p != null && p.isOppositeSide(pieza))) {
 								pieza.addMove(destino);
 							}
 						}
@@ -299,8 +298,7 @@
 							.getFile(), destino.getRank())) {
 						Piece p = posicion.getPieza(destino.getFile(), destino
 								.getRank());
-						if (p == null
-								|| (p != null && p.isOppositeSide(pieza)))
+						if (p == null || (p != null && p.isOppositeSide(pieza)))
 							pieza.addMove(destino);
 					}
 				} catch (ArrayIndexOutOfBoundsException e) {
@@ -436,7 +434,8 @@
 				}
 				if (Piece.isOppositeSide(posicion.getTurn(), p)
 						&& (p.getType() == Type.QUEEN
-								|| p.getType() == Type.BISHOP || (num + v.getY() == numDest
+								|| p.getType() == Type.BISHOP || (num
+								+ v.getY() == numDest
 								&& letra + v.getX() == letDest && (p.getType() == Type.KING || (p
 								.getType() == Type.PAWN && p.getSide() == Side.BLACK))))) {
 					return true;
@@ -460,7 +459,8 @@
 				}
 				if (Piece.isOppositeSide(posicion.getTurn(), p)
 						&& (p.getType() == Type.QUEEN
-								|| p.getType() == Type.BISHOP || (num + v.getY() == numDest
+								|| p.getType() == Type.BISHOP || (num
+								+ v.getY() == numDest
 								&& letra + v.getX() == letDest && (p.getType() == Type.KING || (p
 								.getType() == Type.PAWN && p.getSide() == Side.WHITE))))) {
 					return true;
@@ -516,8 +516,8 @@
 	 *            Es el numero de la casilla de destino
 	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
 	 */
-	public Move move(char origenLetra, char origenNum,
-			char destinoLetra, char destinoNum) {
+	public Move move(char origenLetra, char origenNum, char destinoLetra,
+			char destinoNum) {
 		Piece piezaQueMueve;
 		int i;
 		Move mov;
@@ -548,20 +548,19 @@
 				// Si se entra en el siguiente caso, es que el movimiento es
 				// valido
 				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
-						.getFile()) {
+						.getRank()) {
 					mov = new Move();
 					mov.setCasillaOrigen(new Square(origenLetra, origenNum));
-					mov
-							.setCasillaDestino(new Square(destinoLetra,
-									destinoNum));
+					mov.setCasillaDestino(new Square(destinoLetra, destinoNum));
 					mov.setTipoPieza(piezaQueMueve.getType());
 
 					// Si se come ponemos el contador a 0
 					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
 						posicion.setHalfmoveClock(0);
 						hash.clearDictionary();
-						mov.setCasillaComer(new Square(destinoLetra,
-								destinoNum));
+						mov
+								.setCasillaComer(new Square(destinoLetra,
+										destinoNum));
 						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
 								destinoNum).getType());
 						posicion.removePiece(mov.getCasillaComer());
@@ -582,7 +581,8 @@
 						// correspondiente
 						if (Math.abs(destinoNum - origenNum) == 2) {
 							posicion.setEnPassant(origenLetra);
-							mov.getFinalBoardStatus().setEnPassant(posicion.getEnPassant());
+							mov.getFinalBoardStatus().setEnPassant(
+									posicion.getEnPassant());
 						} else {
 							posicion.setEnPassant('\0');
 						}
@@ -680,8 +680,7 @@
 					posicion.setPiece(torre, 'f', origen.getRank());
 				} else {
 					if ((destino.getFile() - origen.getFile()) == -2) {
-						Piece torre = posicion
-								.getPieza('a', origen.getRank());
+						Piece torre = posicion.getPieza('a', origen.getRank());
 						posicion.removePiece('a', origen.getRank());
 						posicion.setPiece(torre, 'd', origen.getRank());
 					}
@@ -726,8 +725,7 @@
 					posicion.setPiece(torre, 'f', origen.getRank());
 				} else {
 					if ((destino.getFile() - origen.getFile()) == -2) {
-						Piece torre = posicion
-								.getPieza('a', origen.getRank());
+						Piece torre = posicion.getPieza('a', origen.getRank());
 						posicion.removePiece('a', origen.getRank());
 						posicion.setPiece(torre, 'd', origen.getRank());
 					}
@@ -741,9 +739,9 @@
 						.getCasillaComer());
 			}
 			posicion.setPiece(piezaQueMueve, mov.getCasillaOrigen());
-			
+
 			posicion.status.setStatus(mov.getFinalBoardStatus());
-			
+
 			posicion.setTurn();
 			return mov;
 		} else {
@@ -946,7 +944,7 @@
 				break;
 			}
 		}
-		if(piezaCoronacion!=null) {
+		if (piezaCoronacion != null) {
 			// TODO hacer el mostrarDialogoCoronacion;
 			coronar = piezaCoronacion;
 		}
@@ -973,31 +971,33 @@
 			}
 		} else {
 			Square c = new Square(destinoLetra, destinoNum);
-			if (origenLetra == '\0' && origenNum != '\0') {
-				for (char ii = 'a'; ii <= 'h'; ii++) {
-					Piece p = posicion.getPieza(ii, origenNum);
-					if (p.canMove(c)) {
-						origenLetra = ii;
-						break;
+			if (origenLetra == '\0' || origenNum == '\0') {
+				if (origenLetra == '\0' && origenNum != '\0') {
+					for (char ii = 'a'; ii <= 'h'; ii++) {
+						Piece p = posicion.getPieza(ii, origenNum);
+						if (p.canMove(c)) {
+							origenLetra = ii;
+							break;
+						}
 					}
-				}
-			} else if (origenLetra != '\0' && origenNum == '\0') {
-				for (char ii = '1'; ii <= '8'; ii++) {
-					Piece p = posicion.getPieza(origenLetra, ii);
-					if (p.canMove(c)) {
-						origenNum = ii;
-						break;
-					}
-				}
-			} else {
-				for (char ii = '1'; ii <= '8'; ii++) {
-					for (char jj = 'a'; jj <= 'h'; jj++) {
-						Piece p = posicion.getPieza(jj, ii);
+				} else if (origenLetra != '\0' && origenNum == '\0') {
+					for (char ii = '1'; ii <= '8'; ii++) {
+						Piece p = posicion.getPieza(origenLetra, ii);
 						if (p.canMove(c)) {
 							origenNum = ii;
 							break;
 						}
 					}
+				} else {
+					for (char ii = '1'; ii <= '8'; ii++) {
+						for (char jj = 'a'; jj <= 'h'; jj++) {
+							Piece p = posicion.getPieza(jj, ii);
+							if (p.canMove(c)) {
+								origenNum = ii;
+								break;
+							}
+						}
+					}
 				}
 			}
 		}

Modified: trunk/MihailChessLib/com/mihail/chess/BoardStatus.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardStatus.java	2005-08-18 11:39:56 UTC (rev 42)
+++ trunk/MihailChessLib/com/mihail/chess/BoardStatus.java	2005-08-18 13:15:23 UTC (rev 43)
@@ -74,8 +74,10 @@
 		switch (c) {
 		case WHITE:
 			enroque[0][0] = b;
+			return;
 		case BLACK:
 			enroque[1][0] = b;
+			return;
 		}
 		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
 				+ this);
@@ -104,8 +106,10 @@
 		switch (c) {
 		case WHITE:
 			enroque[0][1] = b;
+			return;
 		case BLACK:
 			enroque[1][1] = b;
+			return;
 		}
 		throw new AssertionError("El Bando solo puede ser BLANCO o NEGRO: "
 				+ this);



From gauleng at berlios.de  Thu Aug 18 15:25:12 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Thu, 18 Aug 2005 15:25:12 +0200
Subject: [Mihailchess-svn] r44 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508181325.j7IDPCCd015915@sheep.berlios.de>

Author: gauleng
Date: 2005-08-18 15:25:11 +0200 (Thu, 18 Aug 2005)
New Revision: 44

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
Log:
Corregidos errores en el calculo de movimientos

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 13:15:23 UTC (rev 43)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 13:25:11 UTC (rev 44)
@@ -554,19 +554,7 @@
 					mov.setCasillaDestino(new Square(destinoLetra, destinoNum));
 					mov.setTipoPieza(piezaQueMueve.getType());
 
-					// Si se come ponemos el contador a 0
-					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
-						posicion.setHalfmoveClock(0);
-						hash.clearDictionary();
-						mov
-								.setCasillaComer(new Square(destinoLetra,
-										destinoNum));
-						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
-								destinoNum).getType());
-						posicion.removePiece(mov.getCasillaComer());
-					}
-
-					// Se hacen los calculos especiales si se trata de un peon
+//					 Se hacen los calculos especiales si se trata de un peon
 					if (piezaQueMueve.getType() == Type.PAWN) {
 						// Se borra la pieza correspondiente si se come al paso
 						if (Math.abs(destinoLetra - origenLetra) == 1
@@ -614,6 +602,18 @@
 							}
 						}
 					}
+					
+					// Si se come ponemos el contador a 0
+					if (!posicion.isEmpty(destinoLetra, destinoNum)) {
+						posicion.setHalfmoveClock(0);
+						hash.clearDictionary();
+						mov
+								.setCasillaComer(new Square(destinoLetra,
+										destinoNum));
+						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
+								destinoNum).getType());
+						posicion.removePiece(mov.getCasillaComer());
+					}
 
 					mov.getFinalBoardStatus().setStatus(posicion.status);
 					if (posicion.getTurn() == Side.BLACK)



From gauleng at berlios.de  Fri Aug 19 01:49:41 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Fri, 19 Aug 2005 01:49:41 +0200
Subject: [Mihailchess-svn] r45 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508182349.j7INnfqF003548@sheep.berlios.de>

Author: gauleng
Date: 2005-08-19 01:49:38 +0200 (Fri, 19 Aug 2005)
New Revision: 45

Modified:
   trunk/MihailChessLib/com/mihail/chess/Board.java
Log:
Al fin, el visor funciona :)

Modified: trunk/MihailChessLib/com/mihail/chess/Board.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 13:25:11 UTC (rev 44)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-18 23:49:38 UTC (rev 45)
@@ -274,17 +274,18 @@
 					Piece p = posicion.getPieza(destino.getFile(), destino
 							.getRank());
 					while (p == null) {
-						p = posicion.getPieza(destino.getFile(), destino
-								.getRank());
 						if (esLegal(pieza.getFile(), pieza.getRank(), destino
 								.getFile(), destino.getRank())) {
-							if (p == null
-									|| (p != null && p.isOppositeSide(pieza))) {
 								pieza.addMove(destino);
-							}
+
 						}
 						destino = destino.add(v);
+						p = posicion.getPieza(destino.getFile(), destino
+								.getRank());
 					}
+					if (p != null && p.isOppositeSide(pieza)) {
+						pieza.addMove(destino);
+					}
 				} catch (ArrayIndexOutOfBoundsException e) {
 				}
 			}
@@ -651,7 +652,7 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Move goBack() {
+	public Move goForward() {
 		Move mov;
 		Piece piezaQueMueve;
 		if (indice < movimientos.getHalfmoveNumber()) {
@@ -704,7 +705,7 @@
 	 * 
 	 * @return El movimiento al que lleguemos en la lista de movimientos.
 	 */
-	public Move goForward() {
+	public Move goBack() {
 		Move mov;
 		Piece piezaQueMueve;
 		if (indice > 0) {
@@ -720,22 +721,22 @@
 				Square origen = mov.getCasillaOrigen();
 				Square destino = mov.getCasillaDestino();
 				if ((destino.getFile() - origen.getFile()) == 2) {
-					Piece torre = posicion.getPieza('h', origen.getRank());
-					posicion.removePiece('h', origen.getRank());
-					posicion.setPiece(torre, 'f', origen.getRank());
+					Piece torre = posicion.getPieza('f', origen.getRank());
+					posicion.removePiece('f', origen.getRank());
+					posicion.setPiece(torre, 'h', origen.getRank());
 				} else {
 					if ((destino.getFile() - origen.getFile()) == -2) {
-						Piece torre = posicion.getPieza('a', origen.getRank());
-						posicion.removePiece('a', origen.getRank());
-						posicion.setPiece(torre, 'd', origen.getRank());
+						Piece torre = posicion.getPieza('d', origen.getRank());
+						posicion.removePiece('d', origen.getRank());
+						posicion.setPiece(torre, 'a', origen.getRank());
 					}
 				}
 			}
 			posicion.removePiece(mov.getCasillaDestino());
 			if (mov.getTipoPiezaComida() != null) {
 				posicion.setPiece(new Piece(
-						piezaQueMueve.getSide() == Side.WHITE ? Side.WHITE
-								: Side.BLACK, mov.getTipoPieza()), mov
+						piezaQueMueve.getSide() == Side.WHITE ? Side.BLACK
+								: Side.WHITE, mov.getTipoPiezaComida()), mov
 						.getCasillaComer());
 			}
 			posicion.setPiece(piezaQueMueve, mov.getCasillaOrigen());
@@ -860,7 +861,7 @@
 	 */
 	public Move moveALG(String mov) {
 		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
-		char tipoPieza = 'P';
+		Type tipoPieza = Type.PAWN;
 		Type piezaCoronacion = null;
 		int contadorOesEnroque = 0, i;
 		boolean finDestino = false;
@@ -900,31 +901,31 @@
 				if (i != 0) {
 					piezaCoronacion = Type.BISHOP;
 				} else {
-					tipoPieza = 'A';
+					tipoPieza = Type.BISHOP;
 				}
 				break;
 			case 'K':
-				tipoPieza = 'R';
+				tipoPieza = Type.KING;
 				break;
 			case 'N':
 				if (i != 0) {
 					piezaCoronacion = Type.KNIGHT;
 				} else {
-					tipoPieza = 'C';
+					tipoPieza = Type.KNIGHT;
 				}
 				break;
 			case 'Q':
 				if (i != 0) {
 					piezaCoronacion = Type.QUEEN;
 				} else {
-					tipoPieza = 'D';
+					tipoPieza = Type.QUEEN;
 				}
 				break;
 			case 'R':
 				if (i != 0) {
 					piezaCoronacion = Type.ROOK;
 				} else {
-					tipoPieza = 'T';
+					tipoPieza = Type.ROOK;
 				}
 				break;
 			case '0':
@@ -975,7 +976,7 @@
 				if (origenLetra == '\0' && origenNum != '\0') {
 					for (char ii = 'a'; ii <= 'h'; ii++) {
 						Piece p = posicion.getPieza(ii, origenNum);
-						if (p.canMove(c)) {
+						if (p!=null && p.getType() == tipoPieza  && !Piece.isOppositeSide(posicion.getTurn(), p) && p.canMove(c)) {
 							origenLetra = ii;
 							break;
 						}
@@ -983,17 +984,20 @@
 				} else if (origenLetra != '\0' && origenNum == '\0') {
 					for (char ii = '1'; ii <= '8'; ii++) {
 						Piece p = posicion.getPieza(origenLetra, ii);
-						if (p.canMove(c)) {
+						if (p!=null && p.getType() == tipoPieza  && !Piece.isOppositeSide(posicion.getTurn(), p) && p.canMove(c)) {
 							origenNum = ii;
 							break;
 						}
 					}
 				} else {
-					for (char ii = '1'; ii <= '8'; ii++) {
+					boolean finished = false;
+					for (char ii = '1'; ii <= '8' && !finished; ii++) {
 						for (char jj = 'a'; jj <= 'h'; jj++) {
 							Piece p = posicion.getPieza(jj, ii);
-							if (p.canMove(c)) {
+							if (p!=null && p.getType() == tipoPieza  && !Piece.isOppositeSide(posicion.getTurn(), p) && p.canMove(c)) {
 								origenNum = ii;
+								origenLetra  = jj;
+								finished = true;
 								break;
 							}
 						}



From gauleng at berlios.de  Sat Aug 20 17:48:24 2005
From: gauleng at berlios.de (Pedro Suarez at BerliOS)
Date: Sat, 20 Aug 2005 17:48:24 +0200
Subject: [Mihailchess-svn] r46 - trunk/MihailChessLib/com/mihail/chess
Message-ID: <200508201548.j7KFmON0008753@sheep.berlios.de>

Author: gauleng
Date: 2005-08-20 17:48:24 +0200 (Sat, 20 Aug 2005)
New Revision: 46

Modified:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
Log:
El BoardTheme no debe mirar la extension al leer las imagenes

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-18 23:49:38 UTC (rev 45)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-20 15:48:24 UTC (rev 46)
@@ -3,13 +3,15 @@
 import java.awt.Image;
 import java.io.BufferedInputStream;
 import java.io.File;
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
 import java.io.IOException;
-import java.net.URISyntaxException;
+import java.io.InputStream;
 import java.net.URL;
 import java.util.Enumeration;
 import java.util.zip.ZipEntry;
 import java.util.zip.ZipException;
-import java.util.zip.ZipFile;
+import java.util.zip.ZipInputStream;
 
 import javax.swing.ImageIcon;
 
@@ -70,7 +72,11 @@
 	
 	public BoardTheme(String path) {
 		File file = new File(path);
-		loadZip(file);
+		try {
+			loadZip(new FileInputStream(file));
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+		}
 	}
 	
 	/**
@@ -86,9 +92,8 @@
 	
 	public BoardTheme(URL path) {
 		try {
-			File file = new File(path.toURI());
-			loadZip(file);
-		} catch (URISyntaxException e) {
+			loadZip(path.openStream());
+		} catch (IOException e) {
 			// TODO Auto-generated catch block
 			e.printStackTrace();
 		}
@@ -132,49 +137,58 @@
 		return -1;
 	}
 	
-	private void loadZip(File file) {
+	private void readData(ZipInputStream zis, byte[] data, int size) {
 		try {
-			ZipFile zipFile = new ZipFile(file);
-			for(Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {
-				ZipEntry entry = e.nextElement();
-				
-				BufferedInputStream is = new BufferedInputStream(zipFile.getInputStream(entry));
+			int readed = 0;
+			while(readed<size) {
+				readed += zis.read(data, readed, size-readed);
+			}
+		} catch (IOException e) {
+			e.printStackTrace();
+		}
+	}
+	
+	private void loadZip(InputStream file) {
+		try {
+			ZipInputStream zipFile = new ZipInputStream(file);
+			ZipEntry entry;
+			while((entry=zipFile.getNextEntry())!=null) {
 				String entryName = entry.getName();
 				int size = new Long(entry.getSize()).intValue();
 				byte [] data = new byte[size];
 				System.out.println(entryName + " Size: " + size);
-				System.out.println("Readed data: " + is.read(data, 0, size));
+				readData(zipFile, data, size);
 				if(entryName.equals("reyB.png")) { // Cargar todas las imagenes en funcion de los nombres
 					pieceImages[0][5] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("reyN.png")) {
+				} else if (entryName.startsWith("reyN")) {
 					pieceImages[1][5] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("damaB.png")) {
+				} else if (entryName.startsWith("damaB")) {
 					pieceImages[0][4] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("damaN.png")) {
+				} else if (entryName.startsWith("damaN")) {
 					pieceImages[1][4] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("torreB.png")) {
+				} else if (entryName.startsWith("torreB")) {
 					pieceImages[0][3] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("torreN.png")) {
+				} else if (entryName.startsWith("torreN")) {
 					pieceImages[1][3]= new ImageIcon(data).getImage();
-				} else if (entryName.equals("caballoB.png")) {
+				} else if (entryName.startsWith("caballoB")) {
 					pieceImages[0][1] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("caballoN.png")) {
+				} else if (entryName.startsWith("caballoN")) {
 					pieceImages[1][1] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("alfilB.png")) {
+				} else if (entryName.startsWith("alfilB")) {
 					pieceImages[0][2] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("alfilN.png")) {
+				} else if (entryName.startsWith("alfilN")) {
 					pieceImages[1][2] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("peonB.png")) {
+				} else if (entryName.startsWith("peonB")) {
 					pieceImages[0][0] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("peonN.png")) {
+				} else if (entryName.startsWith("peonN")) {
 					pieceImages[1][0] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("casillaB.png")) {
+				} else if (entryName.startsWith("casillaB")) {
 					casillasImages[0] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("casillaN.png")) {
+				} else if (entryName.startsWith("casillaN")) {
 					casillasImages[1] = new ImageIcon(data).getImage();
-				} else if (entryName.equals("marco.png")) {
+				} else if (entryName.startsWith("marco")) {
 					marco = new ImageIcon(data).getImage();
-				} else if (entryName.equals("fondo.png")) {
+				} else if (entryName.startsWith("fondo")) {
 					background = new ImageIcon(data).getImage();
 				}
 			}



