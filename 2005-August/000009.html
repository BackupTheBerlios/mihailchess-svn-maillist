<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Mihailchess-svn] r33 - in trunk/MihailChessLib/com/mihail: chess clock openings pgn test
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/mihailchess-svn/2005-August/index.html" >
   <LINK REL="made" HREF="mailto:mihailchess-svn%40lists.berlios.de?Subject=Re%3A%20%5BMihailchess-svn%5D%20r33%20-%20in%20trunk/MihailChessLib/com/mihail%3A%20chess%20clock%20openings%20pgn%20test&In-Reply-To=%3C200508141221.j7ECLwR4001095%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000004.html">
   <LINK REL="Next"  HREF="000005.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Mihailchess-svn] r33 - in trunk/MihailChessLib/com/mihail: chess clock openings pgn test</H1>
    <B>Pedro Suarez at BerliOS</B> 
    <A HREF="mailto:mihailchess-svn%40lists.berlios.de?Subject=Re%3A%20%5BMihailchess-svn%5D%20r33%20-%20in%20trunk/MihailChessLib/com/mihail%3A%20chess%20clock%20openings%20pgn%20test&In-Reply-To=%3C200508141221.j7ECLwR4001095%40sheep.berlios.de%3E"
       TITLE="[Mihailchess-svn] r33 - in trunk/MihailChessLib/com/mihail: chess clock openings pgn test">gauleng at berlios.de
       </A><BR>
    <I>Sun Aug 14 14:21:58 CEST 2005</I>
    <P><UL>
        <LI>Previous message: <A HREF="000004.html">[Mihailchess-svn] r32 - trunk/MihailChessLib/com/mihail/chess
</A></li>
        <LI>Next message: <A HREF="000005.html">[Mihailchess-svn] r34 - trunk/MihailChessLib/com/mihail/pgn
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: gauleng
Date: 2005-08-14 14:21:56 +0200 (Sun, 14 Aug 2005)
New Revision: 33

Added:
   trunk/MihailChessLib/com/mihail/chess/Board.java
   trunk/MihailChessLib/com/mihail/chess/Board2D.java
   trunk/MihailChessLib/com/mihail/chess/DirectionVector.java
   trunk/MihailChessLib/com/mihail/chess/Movement.java
   trunk/MihailChessLib/com/mihail/chess/Piece.java
   trunk/MihailChessLib/com/mihail/chess/Position.java
   trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java
   trunk/MihailChessLib/com/mihail/chess/Square.java
   trunk/MihailChessLib/com/mihail/chess/VariationsTree.java
   trunk/MihailChessLib/com/mihail/clock/Clock.java
   trunk/MihailChessLib/com/mihail/clock/ClockException.java
   trunk/MihailChessLib/com/mihail/openings/Openings.java
   trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java
Removed:
   trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java
   trunk/MihailChessLib/com/mihail/chess/Casilla.java
   trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java
   trunk/MihailChessLib/com/mihail/chess/Logica.java
   trunk/MihailChessLib/com/mihail/chess/Movimiento.java
   trunk/MihailChessLib/com/mihail/chess/Pieza.java
   trunk/MihailChessLib/com/mihail/chess/Posicion.java
   trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
   trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java
   trunk/MihailChessLib/com/mihail/clock/Reloj.java
   trunk/MihailChessLib/com/mihail/clock/RelojException.java
   trunk/MihailChessLib/com/mihail/openings/Aperturas.java
   trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java
Modified:
   trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
   trunk/MihailChessLib/com/mihail/pgn/PGNParser.java
   trunk/MihailChessLib/com/mihail/test/PositionTest.java
   trunk/MihailChessLib/com/mihail/test/RelojTest.java
Log:
Primera translation

Deleted: trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,219 +0,0 @@
-package com.mihail.chess;
-
-import java.util.AbstractList;
-import java.util.ArrayList;
-import java.util.List;
-
-import com.mihail.chess.Logica.Bando;
-
-/**
- * @author Wotan
- * 
- * TODO To change the template for this generated type comment go to Window -
- * Preferences - Java - Code Style - Code Templates
- */
-public class ArbolVariantes {
-	private class NodoArbol {
-		public Movimiento movimiento;
-
-		public ArrayList&lt;ArbolVariantes&gt; variantes;
-
-		public NodoArbol(Movimiento mov) {
-			movimiento = mov;
-		}
-	}
-
-	/**
-	 * Desplazamiento con respecto al principio de la partida. En el caso de la
-	 * variante principal, el desplazamiento es 0, pero en otro caso el
-	 * desplazamiento es igual el numero de movimiento en el que se encuentra la
-	 * variante.
-	 */
-
-	private int desplazamiento = 0;
-
-	private AbstractList&lt;NodoArbol&gt; arbol = new ArrayList&lt;NodoArbol&gt;();
-
-	/**
-	 * 
-	 */
-	public ArbolVariantes() {
-	}
-
-	private ArbolVariantes(int desp) {
-		desplazamiento = desp;
-	}
-
-	/**
-	 * A&#241;ade el movimiento al final de la variante principal.
-	 * 
-	 * @param mov
-	 *            Movimiento que se a&#241;ade.
-	 */
-	public void appendMovimiento(Movimiento mov) {
-		arbol.add(new NodoArbol(mov));
-	}
-
-	/**
-	 * Obtiene un movimiento a partir del numero de movimiento y el turno de
-	 * juego.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento
-	 * @param numero
-	 *            Numero del movimiento
-	 * @return Devuelve el movimiento correspondiente a color y numero
-	 */
-	public Movimiento getMovimiento(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-		if (n != null)
-			return n.movimiento;
-		return null;
-	}
-	
-	public Movimiento getMovimiento(int halfPly) {
-		return arbol.get(halfPly).movimiento;
-	}
-
-	/**
-	 * Comprueba si dado un movimiento, existen alternativas.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 * @return Un booleano que indica si para ese movimiento existen
-	 *         alternativas.
-	 */
-	public boolean existeVariante(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n != null &amp;&amp; n.variantes != null)
-			return (!n.variantes.isEmpty());
-		return false;
-	}
-
-	/**
-	 * Devuelve el numero de variantes a un movimiento determinado.
-	 * 
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 * @return El numero de alternativas a un movimiento.
-	 */
-	public int getNumVariantes(Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n != null) {
-			if (n.variantes != null)
-				return n.variantes.size();
-		}
-		return 0;
-	}
-
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO)
-			return 0;
-		return 1;
-	}
-
-	// Funcion de utilidad.
-	private NodoArbol getNodo(Bando color, int numero) {
-		int indice = (numero - 1) * 2 + bandoToInt(color);
-		if (indice &lt; arbol.size())
-			return arbol.get(indice);
-		return null;
-	}
-
-	/**
-	 * A&#241;ade un movimiento como variante a otro movimiento.
-	 * 
-	 * @param mov
-	 *            Movimiento que se a&#241;ade como alternativa
-	 * @param color
-	 *            Turno del que es el movimiento.
-	 * @param numero
-	 *            Numero del movimiento.
-	 */
-	public void addVariante(Movimiento mov, Bando color, int numero) {
-		NodoArbol n = getNodo(color, numero);
-
-		if (n.variantes == null)
-			n.variantes = new ArrayList&lt;ArbolVariantes&gt;();
-
-		ArbolVariantes a = new ArbolVariantes(numero);
-		if (color == Bando.NEGRO) // Cada arbol de variantes debe empezar con un movimiento de blancas
-			a.appendMovimiento(new Movimiento());
-		a.appendMovimiento(mov);
-
-		n.variantes.add(a);
-	}
-
-	/**
-	 * Devuelve la variante numero num a un movimiento dado.
-	 * 
-	 * @param color
-	 * @param numero
-	 * @param num
-	 *            Numero de variante que se quiere obtener.
-	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
-	 */
-	public ArbolVariantes getVariante(Bando color, int numero, int num) {
-		NodoArbol n = getNodo(color, numero);
-		if (n != null)
-			return n.variantes.get(num);
-		return null;
-	}
-
-	/**
-	 * @return Devuelve el numero total de movimientos desde el comienzo de la
-	 *         partida. Solo cuenta los turnos jugados, no cuenta un movimiento
-	 *         por negras y otro por blancas.
-	 */
-	public int getNumMovimientos() {
-		return desplazamiento + ((arbol.size() + 1) / 2);
-	}
-
-	/**
-	 * Cuenta los medios movimientos, es decir, contando uno por cada movimiento
-	 * de negras y blancas.
-	 * 
-	 * @return Los medios movimientos desde el comienzo de la partida.
-	 */
-
-	public int getNumHalfPly() {
-		return arbol.size();
-	}
-
-	/**
-	 * Devuelve el &#250;ltimo movimiento de la variante actual.
-	 * 
-	 * @return
-	 */
-
-	public Movimiento getLastMovimiento() {
-		return arbol.get(arbol.size() - 1).movimiento;
-	}
-	
-	/**
-	 * Hace que una variante pase a ser la variante principal.
-	 * 
-	 * @param color
-	 * @param numero
-	 * @param num
-	 */
-	
-	public void promoteVariant(Bando color, int numero, int num) {
-		ArbolVariantes a = getVariante(color, numero, num);
-		int indice = (numero - 1) * 2 + bandoToInt(color);
-		NodoArbol n = getNodo(color, numero);
-		
-		ArbolVariantes newTree = new ArbolVariantes();
-		newTree.arbol  = (AbstractList&lt;ArbolVariantes.NodoArbol&gt;)arbol.subList(indice, arbol.size());
-		n.variantes.add(newTree);
-		
-		arbol.addAll(a.arbol);
-		n.variantes.remove(num);
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Board.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Logica.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Board.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,1033 @@
+package com.mihail.chess;
+
+import java.util.ArrayList;
+
+import com.mihail.chess.Piece.Tipo;
+
+public class Board {
+
+	public static enum Bando {
+		BLANCO, NEGRO;
+
+		public boolean equals(Bando b) {
+			return this == b;
+		}
+	}
+
+	public static enum Resultado {
+		JAQUE_MATE_BLANCO, JAQUE_MATE_NEGRO, TABLAS_REPETICION, TABLAS_50_MOV, TABLAS_INSUF_MATERIAL, TABLAS_AHOGADO
+	}
+
+	// public static final int JAQUE_MATE_BLANCO = 6;
+	// public static final int JAQUE_MATE_NEGRO = 1;
+	// public static final int TABLAS_REPETICION = 2;
+	// public static final int TABLAS_50_MOV = 3;
+	// public static final int TABLAS_INSUF_MATERIAL = 4;
+	// public static final int TABLAS_AHOGADO = 5;
+
+	/**
+	 * Este atributo sirve para guardar la lista de movimientos de una partida.
+	 */
+	private VariationsTree movimientos;
+
+	/**
+	 * Este atributo sirve para saber en que posicion de la lista de movimientos
+	 * nos encontramos, a la hora de avanzar y retroceder por una partida.
+	 * Siempre va una posici&#243;n por delante de la aut&#233;ntica posici&#243;n
+	 */
+	private int indice;
+
+	/**
+	 * Este atributo se utiliza para las coronaciones.
+	 */
+	private Tipo coronar = Tipo.DAMA;
+
+	/**
+	 * Tabla hash usada para comprobar posiciones repetidas.
+	 */
+	private PositionsDictionary hash = new PositionsDictionary(51);
+
+	/**
+	 * Posicion actual en juego
+	 */
+	private Position posicion;
+
+	/**
+	 * Crea una nueva instancia de la clase y crea las piezas, colocandolas en
+	 * la posicion que indica el String posInicial.
+	 * 
+	 * @param posInicial
+	 *            Es un String que indica una posicion de juego, siguiendo el
+	 *            estandar FEN.
+	 */
+	public Board(Position posInicial) {
+		movimientos = new VariationsTree();
+		posicion = posInicial;
+		hash.insertar(posicion.getClavePosicion());
+	}
+
+	/**
+	 * Reinicia la posicion del tablero a la posicion inicial.
+	 */
+	public void reiniciarTablero() {
+		posicion.setPosicion(Position.CAD_INICIAL);
+	}
+
+	/**
+	 * Indica a que pieza queremos coronar por defecto.
+	 * 
+	 * @param c
+	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
+	 */
+
+	public void setCoronacion(Tipo c) {
+		coronar = c;
+	}
+
+	/**
+	 * Permite saber el numero total de movimientos de la partida.
+	 * 
+	 * @return Un entero, el numero en cuestion.
+	 */
+
+	public int getNumTotalMovimientos() {
+		return movimientos.getNumMovimientos();
+	}
+
+	public Position getPosicion() {
+		return this.posicion;
+	}
+
+	/**
+	 * Obtiene el resultado de la partida.
+	 * 
+	 * @return Devuelve un caracter: &lt;BR&gt;
+	 *         'B' -&gt; Victoria Blanca &lt;BR&gt;
+	 *         'N' -&gt; Victoria Negra &lt;BR&gt;
+	 *         'T' -&gt; Tablas &lt;BR&gt;
+	 *         '\0' -&gt; Partida Inacabada o Resultado Desconocido
+	 */
+	public Resultado getResultado() {
+		return movimientos.getLastMovimiento().getFinPartida();
+	}
+
+	/**
+	 * Calcula los movimientos validos para todas las piezas del tablero.
+	 */
+	public void calcularMovimientos() {
+		for (char i = 'a'; i &lt;= 'h'; i++) {
+			for (char j = '1'; j &lt;= '8'; j++) {
+				Piece p = posicion.getPieza(i, j);
+				if (p != null) {
+					if (!Piece.esBandoContrario(posicion.getTurno(), p)) {
+						calcularMovimientos(p);
+					}
+				}
+			}
+		}
+	}
+
+	/**
+	 * Calcula los movimientos validos para una pieza en concreto, que se le
+	 * pasa como parametro.
+	 * 
+	 * @param pieza
+	 *            Pieza de la que queremos calcular sus movimientos legales
+	 */
+	private void calcularMovimientos(Piece pieza) {
+		pieza.getCasillasValidas().clear();
+		switch (pieza.getTipo()) {
+		case PEON:
+			// Peon
+			// Peon blanco
+			if (pieza.getBando() == Bando.BLANCO) {
+				// Movimiento hacia delante
+				// Hacemos dos iteraciones, una para el caso de que avance
+				// una casilla, otra para el caso de que avance dos
+				if (posicion.esVacia(pieza.getLetra(),
+						(char) (pieza.getNum() + 1))) {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+							.getLetra(), (char) (pieza.getNum() + 1))) {
+						pieza.anadirMov(pieza.getLetra(), (char) (pieza
+								.getNum() + 1));
+						if (pieza.getNum() == '2'
+								&amp;&amp; posicion.esVacia(pieza.getLetra(),
+										(char) (pieza.getNum() + 2))) {
+							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+									.getLetra(), (char) (pieza.getNum() + 2))) {
+								pieza.anadirMov(pieza.getLetra(), (char) (pieza
+										.getNum() + 2));
+							}
+						}
+					}
+				}
+				if (posicion.getAlPaso() != '\0'
+						&amp;&amp; pieza.getNum() == '5'
+						&amp;&amp; Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
+					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+							.getNum() + 1));
+				}
+				// Movimientos para comer
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
+							(char) (pieza.getNum() + 1));
+					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() + 1), (char) (pieza
+										.getNum() + 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() + 1),
+									(char) (pieza.getNum() + 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() + 1),
+							(char) (pieza.getNum() - 1));
+					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() - 1), (char) (pieza
+										.getNum() + 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() - 1),
+									(char) (pieza.getNum() + 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+			// Peon negro
+			else {
+				if (posicion.esVacia(pieza.getLetra(),
+						(char) (pieza.getNum() - 1))) {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+							.getLetra(), (char) (pieza.getNum() - 1))) {
+						pieza.anadirMov(pieza.getLetra(), (char) (pieza
+								.getNum() - 1));
+						if (pieza.getNum() == '7'
+								&amp;&amp; posicion.esVacia(pieza.getLetra(),
+										(char) (pieza.getNum() - 2))) {
+							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
+									.getLetra(), (char) (pieza.getNum() - 2))) {
+								pieza.anadirMov(pieza.getLetra(), (char) (pieza
+										.getNum() - 2));
+							}
+						}
+					}
+				}
+				if (posicion.getAlPaso() != '\0'
+						&amp;&amp; pieza.getNum() == '4'
+						&amp;&amp; Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
+					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
+							.getNum() - 1));
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
+							(char) (pieza.getNum() + 1));
+					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() + 1), (char) (pieza
+										.getNum() - 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() + 1),
+									(char) (pieza.getNum() - 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+				try {
+					Piece p = posicion.getPieza((char) (pieza.getLetra() - 1),
+							(char) (pieza.getNum() - 1));
+					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
+						if (esLegal(pieza.getLetra(), pieza.getNum(),
+								(char) (pieza.getLetra() - 1), (char) (pieza
+										.getNum() - 1))) {
+							pieza.anadirMov((char) (pieza.getLetra() - 1),
+									(char) (pieza.getNum() - 1));
+						}
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+			break;
+		case CABALLO:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				Square destino = pieza.getCasilla().add(v);
+				try {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+							.getLetra(), destino.getNumero())) {
+						Piece p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (p == null
+								|| (p != null &amp;&amp; Piece.esBandoContrario(pieza,
+										p)))
+							pieza.anadirMov(destino);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			break;
+		case DAMA:
+		case ALFIL:
+		case TORRE:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				try {
+					Square destino = pieza.getCasilla().add(v);
+					Piece p = posicion.getPieza(destino.getLetra(), destino
+							.getNumero());
+					while (p == null) {
+						p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+								.getLetra(), destino.getNumero())) {
+							if (p == null
+									|| (p != null &amp;&amp; Piece.esBandoContrario(
+											pieza, p))) {
+								pieza.anadirMov(destino);
+							}
+						}
+						destino = destino.add(v);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			break;
+		case REY:
+			for (DirectionVector v : pieza.getDirecciones()) {
+				Square destino = pieza.getCasilla().add(v);
+				try {
+					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
+							.getLetra(), destino.getNumero())) {
+						Piece p = posicion.getPieza(destino.getLetra(), destino
+								.getNumero());
+						if (p == null
+								|| (p != null &amp;&amp; Piece.esBandoContrario(pieza,
+										p)))
+							pieza.anadirMov(destino);
+					}
+				} catch (ArrayIndexOutOfBoundsException e) {
+				}
+			}
+
+			if (posicion.getEnroqueCorto(posicion.getTurno())
+					&amp;&amp; !esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))
+					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() + 1), pieza
+							.getNum())
+					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() + 1), (pieza
+							.getNum()))
+					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() + 2), pieza
+							.getNum())
+					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() + 2), (pieza
+							.getNum()))) {
+				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
+			}
+			if (posicion.getEnroqueLargo(posicion.getTurno())
+					&amp;&amp; !esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))
+					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() - 1), pieza
+							.getNum())
+					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() - 1), (pieza
+							.getNum()))
+					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() - 2), pieza
+							.getNum())
+					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() - 2), (pieza
+							.getNum()))) {
+				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
+			}
+			break;
+		}
+	}
+
+	/**
+	 * Metodo de utilidad que se comporta exactamente igual que
+	 * esCasillaAtacada(char, char)
+	 * 
+	 * @param c
+	 *            Casilla que queremos comprobar si esta siendo atacada
+	 * @return Devuelve un booleano indicando si es una casilla atacada o no
+	 */
+	public boolean esCasillaAtacada(Square c) {
+		return esCasillaAtacada(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * esCasillaAtacada determina si hay alguna pieza que ataque la casilla que
+	 * se le pasa como parametro. &lt;BR&gt;
+	 * NOTA sobre el codigo: se necesita comprobar el turno para: en el turno en
+	 * el que mueves necesitas saber que casillas estan atacadas por el bando
+	 * contrario, y solo por este bando. No interesan las casillas que ataca el
+	 * bando que mueve. Ademas se puede comprobar que una casillas es atacada
+	 * estando vacia lo cual implica que no hay colores contrarios y es
+	 * necesario conocer el turno para saber quien ataca
+	 * 
+	 * @param letra
+	 *            Letra de la casilla que queremos comprobar si esta siendo
+	 *            atacada
+	 * @param num
+	 *            N&#250;mero de la casilla que queremos comprobart si est&#225; siendo
+	 *            atacada
+	 * @return Devuelve un booleano indicando si es una casilla atacada o no
+	 */
+	public boolean esCasillaAtacada(char letra, char num) {
+		// Primero miro las casillas
+		// a salto de caballo. Despues, las verticales, horizontales y
+		// diagonales.
+
+		// Casillas a salto de caballo
+		ArrayList&lt;DirectionVector&gt; dir = new ArrayList&lt;DirectionVector&gt;();
+		dir.add(new DirectionVector(1, 2));
+		dir.add(new DirectionVector(-1, 2));
+		dir.add(new DirectionVector(2, 1));
+		dir.add(new DirectionVector(2, -1));
+		dir.add(new DirectionVector(1, -2));
+		dir.add(new DirectionVector(-1, -2));
+		dir.add(new DirectionVector(-2, 1));
+		dir.add(new DirectionVector(-2, -1));
+		for (DirectionVector v : dir) {
+			try {
+				Piece p = posicion.getPieza((char) (letra + v.getX()),
+						(char) (num + v.getY()));
+				if (p != null) {
+					if (Piece.esBandoContrario(posicion.getTurno(), p)
+							&amp;&amp; p.getTipo() == Tipo.CABALLO) {
+						return true;
+					}
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, 0));
+		dir.add(new DirectionVector(-1, 0));
+		dir.add(new DirectionVector(0, 1));
+		dir.add(new DirectionVector(0, -1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&amp;&amp; (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
+								&amp;&amp; letra + v.getX() == letDest &amp;&amp; p.getTipo() == Tipo.REY))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, 1));
+		dir.add(new DirectionVector(-1, 1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&amp;&amp; (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
+								&amp;&amp; letra + v.getX() == letDest &amp;&amp; (p.getTipo() == Tipo.REY || (p
+								.getTipo() == Tipo.PEON &amp;&amp; p.getBando() == Bando.NEGRO))))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+		dir.clear();
+		dir.add(new DirectionVector(1, -1));
+		dir.add(new DirectionVector(-1, -1));
+
+		for (DirectionVector v : dir) {
+			try {
+				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
+						.getY());
+				Piece p = posicion.getPieza(letDest, numDest);
+				while (p == null) {
+					letDest = (char) (letDest + v.getX());
+					numDest = (char) (numDest + v.getY());
+					p = posicion.getPieza(letDest, numDest);
+				}
+				if (Piece.esBandoContrario(posicion.getTurno(), p)
+						&amp;&amp; (p.getTipo() == Tipo.DAMA
+								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
+								&amp;&amp; letra + v.getX() == letDest &amp;&amp; (p.getTipo() == Tipo.REY || (p
+								.getTipo() == Tipo.PEON &amp;&amp; p.getBando() == Bando.BLANCO))))) {
+					return true;
+				}
+			} catch (ArrayIndexOutOfBoundsException e) {
+			}
+		}
+
+		return false;
+	}
+
+	/**
+	 * Determina si un movimiento es legal, analizando la situacion en la
+	 * partida.
+	 * 
+	 * @param letOrig
+	 *            Letra de la casilla de origen.
+	 * @param numOrig
+	 *            Numero de la casilla de origen.
+	 * @param letDest
+	 *            Letra de la casilla de destino.
+	 * @param numDest
+	 *            Numero de la casilla de destino.
+	 * @return True si el movimiento es legal, false en caso contrario.
+	 */
+	private boolean esLegal(char letOrig, char numOrig, char letDest,
+			char numDest) {
+		boolean resultado;
+		Piece movida = posicion.getPieza(letOrig, numOrig);
+		Piece temp = posicion.getPieza(letDest, numDest);
+		posicion.borrarPiezaInternal(letOrig, numOrig);
+		posicion.setPiezaInternal(movida, letDest, numDest);
+		resultado = esCasillaAtacada(posicion.getKingPosition(posicion
+				.getTurno()));
+		posicion.borrarPiezaInternal(letDest, numDest);
+		posicion.setPiezaInternal(movida, letOrig, numOrig);
+		if (temp != null)
+			posicion.setPiezaInternal(temp, letDest, numDest);
+		return !resultado;
+	}
+
+	/**
+	 * Este metodo mueve una pieza en el tablero, comprobando que este
+	 * movimiento sea permitido.
+	 * 
+	 * @param origenLetra
+	 *            Es la letra de la casilla de origen
+	 * @param origenNum
+	 *            Es el numero de la casilla de origen
+	 * @param destinoLetra
+	 *            Es la letra de la casilla de destino
+	 * @param destinoNum
+	 *            Es el numero de la casilla de destino
+	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
+	 */
+	public Movement mover(char origenLetra, char origenNum,
+			char destinoLetra, char destinoNum) {
+		Piece piezaQueMueve;
+		int i;
+		Movement mov;
+		piezaQueMueve = posicion.getPieza(origenLetra, origenNum);
+
+		// Comprobamos que en la casilla de origen hay una pieza
+		if (piezaQueMueve == null) {
+			return null;
+		}
+
+		if (Piece.esBandoContrario(posicion.getTurno(), piezaQueMueve)) {
+			return null;
+		}
+		if (indice != movimientos.getNumHalfPly())
+			return null;
+		// Buscamos la casilla de destino entre las casillas validas de la
+		// pieza.
+		i = 0;
+		do {
+			// Buscamos la letra.
+			while ((i &lt; piezaQueMueve.getCasillasValidas().size())
+					&amp;&amp; (destinoLetra != piezaQueMueve.getCasillasValidas().get(
+							i).getLetra())) {
+				i++;
+				// Comprobamos si el numero de la letra encontrada coincide.
+			}
+			if (i &lt; piezaQueMueve.getCasillasValidas().size()) {
+				// Si se entra en el siguiente caso, es que el movimiento es
+				// valido
+				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
+						.getLetra()) {
+					mov = new Movement();
+					mov.setCasillaOrigen(new Square(origenLetra, origenNum));
+					mov
+							.setCasillaDestino(new Square(destinoLetra,
+									destinoNum));
+					mov.setNumeroMovimiento(posicion.getNumeroMovimiento());
+					mov.setBando(posicion.getTurno());
+					mov.setTipoPieza(piezaQueMueve.getTipo());
+
+					// Si se come ponemos el contador a 0
+					if (!posicion.esVacia(destinoLetra, destinoNum)) {
+						posicion.setContadorTablas(0);
+						hash.borrarTabla();
+						mov.setCasillaComer(new Square(destinoLetra,
+								destinoNum));
+						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
+								destinoNum).getTipo());
+						posicion.borrarPieza(mov.getCasillaComer());
+					}
+
+					// Se hacen los calculos especiales si se trata de un peon
+					if (piezaQueMueve.getTipo() == Tipo.PEON) {
+						// Se borra la pieza correspondiente si se come al paso
+						if (Math.abs(destinoLetra - origenLetra) == 1
+								&amp;&amp; posicion.esVacia(destinoLetra, destinoNum)) {
+							mov.setTipoPiezaComida(posicion.getPieza(
+									destinoLetra, origenNum).getTipo());
+							mov.setCasillaComer(new Square(destinoLetra,
+									origenNum));
+							posicion.borrarPieza(mov.getCasillaComer());
+						}
+						// Se establece la variable alPaso a su valor
+						// correspondiente
+						if (Math.abs(destinoNum - origenNum) == 2) {
+							posicion.setAlPaso(origenLetra);
+							mov.setAlPaso(posicion.getAlPaso());
+						} else {
+							posicion.setAlPaso('\0');
+						}
+						// Coronacion
+						if (destinoNum == '1' || destinoNum == '8') {
+							// if (mostrarDialogoCoronacion) {
+							// mostrarDialogoCoronacion ();
+							// }
+							piezaQueMueve = new Piece(piezaQueMueve.getBando(),
+									coronar);
+
+							mov.setCoronacion(coronar);
+						}
+						posicion.setContadorTablas(0);
+						hash.borrarTabla();
+					}
+					// Se hacen los calculos especiales si se trata de un rey
+					if (piezaQueMueve.getTipo() == Tipo.REY) {
+						// Movemos las torres en caso de enroque
+						if ((destinoLetra - origenLetra) == 2) {
+							Piece torre = posicion.getPieza('h', origenNum);
+							posicion.borrarPieza('h', origenNum);
+							posicion.setPieza(torre, 'f', origenNum);
+						} else {
+							if ((destinoLetra - origenLetra) == -2) {
+								Piece torre = posicion.getPieza('a', origenNum);
+								posicion.borrarPieza('a', origenNum);
+								posicion.setPieza(torre, 'd', origenNum);
+							}
+						}
+					}
+
+					mov.setContadorTablas(posicion.getContadorTablas());
+					boolean[][] enroque = new boolean[2][2];
+					enroque[0][0] = posicion.getEnroqueCorto(Bando.BLANCO);
+					enroque[0][1] = posicion.getEnroqueLargo(Bando.BLANCO);
+					enroque[1][0] = posicion.getEnroqueCorto(Bando.NEGRO);
+					enroque[1][1] = posicion.getEnroqueLargo(Bando.NEGRO);
+					mov.setEnroque(enroque);
+					if (posicion.getTurno() == Bando.NEGRO)
+						posicion.addNumeroMovimiento();
+					posicion.setTurno();
+
+					posicion.borrarPieza(origenLetra, origenNum);
+					posicion.setPieza(piezaQueMueve, destinoLetra, destinoNum);
+					posicion.addContadorTablas();
+					calcularMovimientos();
+
+					if (esCasillaAtacada(posicion.getKingPosition(posicion
+							.getTurno()))) {
+						mov.setJaque(true);
+					} else {
+						mov.setJaque(false);
+					}
+					mov.setFinPartida(esFinPartida());
+
+					hash.insertar(posicion.getClavePosicion());
+					movimientos.appendMovimiento(mov);
+					indice++;
+					return mov;
+				} else {
+					i++;
+				}
+			} else {
+				return null;
+			}
+		} while (true);
+	}
+
+	/**
+	 * Avanza por la lista de movimientos de la partida.
+	 * 
+	 * @return El movimiento al que lleguemos en la lista de movimientos.
+	 */
+	public Movement avanzar() {
+		Movement mov;
+		Piece piezaQueMueve;
+		if (indice &lt; movimientos.getNumHalfPly()) {
+			mov = movimientos.getMovimiento(indice);
+			piezaQueMueve = posicion.getPieza(mov.getCasillaOrigen());
+			// Si se come al paso
+			if (piezaQueMueve.getTipo() == Tipo.PEON
+					&amp;&amp; Math.abs(mov.getCasillaDestino().getLetra()
+							- mov.getCasillaOrigen().getLetra()) == 1
+					&amp;&amp; posicion.esVacia(mov.getCasillaDestino())) {
+				posicion.borrarPieza(mov.getCasillaComer());
+			}
+			// Si se corona
+			if (mov.getCoronacion() != null) {
+				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+						.getCoronacion());
+			}
+			// Se hacen los calculos especiales si se trata de un rey
+			if (piezaQueMueve.getTipo() == Tipo.REY) {
+				// Movemos las torres en caso de enroque
+				Square origen = mov.getCasillaOrigen();
+				Square destino = mov.getCasillaDestino();
+				if ((destino.getLetra() - origen.getLetra()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getNumero());
+					posicion.borrarPieza('h', origen.getNumero());
+					posicion.setPieza(torre, 'f', origen.getNumero());
+				} else {
+					if ((destino.getLetra() - origen.getLetra()) == -2) {
+						Piece torre = posicion
+								.getPieza('a', origen.getNumero());
+						posicion.borrarPieza('a', origen.getNumero());
+						posicion.setPieza(torre, 'd', origen.getNumero());
+					}
+				}
+			}
+			posicion.borrarPieza(mov.getCasillaOrigen());
+			posicion.setPieza(piezaQueMueve, mov.getCasillaDestino());
+			posicion.setContadorTablas(mov.getContadorTablas());
+			boolean[][] enroques = mov.getEnroque();
+			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
+			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
+			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
+			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
+			posicion.setAlPaso(mov.getAlPaso());
+			posicion.setTurno();
+			indice++;
+			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			return mov;
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Retrocede por la lista de movimientos de la partida.
+	 * 
+	 * @return El movimiento al que lleguemos en la lista de movimientos.
+	 */
+	public Movement retroceder() {
+		Movement mov;
+		Piece piezaQueMueve;
+		if (indice &gt; 0) {
+			indice--;
+			mov = movimientos.getMovimiento(indice);
+			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
+			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
+			if (mov.getCoronacion() != null) {
+				piezaQueMueve = new Piece(piezaQueMueve.getBando(), mov
+						.getCoronacion());
+			}
+			if (piezaQueMueve.getTipo() == Tipo.REY) {
+				// Movemos las torres en caso de enroque
+				Square origen = mov.getCasillaOrigen();
+				Square destino = mov.getCasillaDestino();
+				if ((destino.getLetra() - origen.getLetra()) == 2) {
+					Piece torre = posicion.getPieza('h', origen.getNumero());
+					posicion.borrarPieza('h', origen.getNumero());
+					posicion.setPieza(torre, 'f', origen.getNumero());
+				} else {
+					if ((destino.getLetra() - origen.getLetra()) == -2) {
+						Piece torre = posicion
+								.getPieza('a', origen.getNumero());
+						posicion.borrarPieza('a', origen.getNumero());
+						posicion.setPieza(torre, 'd', origen.getNumero());
+					}
+				}
+			}
+			posicion.borrarPieza(mov.getCasillaDestino());
+			if (mov.getTipoPiezaComida() != null) {
+				posicion.setPieza(new Piece(
+						piezaQueMueve.getBando() == Bando.BLANCO ? Bando.BLANCO
+								: Bando.NEGRO, mov.getTipoPieza()), mov
+						.getCasillaComer());
+			}
+			posicion.setPieza(piezaQueMueve, mov.getCasillaOrigen());
+			posicion.setContadorTablas(mov.getContadorTablas());
+			boolean[][] enroques = mov.getEnroque();
+			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
+			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
+			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
+			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
+			posicion.setAlPaso(mov.getAlPaso());
+			posicion.setTurno();
+			return mov;
+		} else {
+			return null;
+		}
+	}
+
+	/**
+	 * Este metodo comprueba si se produce alguna situacion en la que termine
+	 * una partida.
+	 * 
+	 * @return Devuelve '\0' si la partida no se ha acabado, 'B' si las blancas
+	 *         han dado jaque mate, 'N' si las negras han dado jaque mate o 'T'
+	 *         si se produce una situacion de tablas.
+	 */
+	private Resultado esFinPartida() {
+		Piece pieza;
+		Resultado devolver = null;
+		boolean fin = false, fin2 = false, posibleMatInsuf = false;
+		char i, j;
+		// Tablas por 50 movimientos
+		if (posicion.getContadorTablas() == 50) {
+			fin = true;
+			devolver = Resultado.TABLAS_50_MOV;
+		}
+		// Tablas por repeticion de posiciones
+		if (hash.getRepeticiones(posicion.getClavePosicion()) == 3) {
+			fin = true;
+			devolver = Resultado.TABLAS_REPETICION;
+		}
+		// Tablas por material insuficiente
+		i = 'a';
+		j = '1';
+		while (i &lt;= 'h' &amp;&amp; !fin2) {
+			while (j &lt;= '8' &amp;&amp; !fin2) {
+				pieza = posicion.getPieza(i, j);
+				if (pieza != null) {
+					if (posibleMatInsuf) {
+						if (pieza.getTipo() != Tipo.REY) {
+							fin2 = true;
+						}
+					} else {
+						switch (pieza.getTipo()) {
+						case PEON:
+						case DAMA:
+						case TORRE:
+							fin2 = true;
+							break;
+						case ALFIL:
+						case CABALLO:
+							posibleMatInsuf = true;
+							break;
+						case REY:
+							break;
+						}
+					}
+				}
+				j++;
+			}
+			j = '1';
+			i++;
+		}
+		if (!fin2) {
+			fin = true;
+			devolver = Resultado.TABLAS_INSUF_MATERIAL;
+		}
+		// Miramos si hay movimientos posibles
+		i = 'a';
+		j = '1';
+		while (i &lt;= 'h' &amp;&amp; !fin) {
+			while (j &lt;= '8' &amp;&amp; !fin) {
+				pieza = posicion.getPieza(i, j);
+				if ((pieza != null)
+						&amp;&amp; (!Piece.esBandoContrario(posicion.getTurno(), pieza))
+						&amp;&amp; (!pieza.getCasillasValidas().isEmpty())) {
+					fin = true;
+				}
+				j++;
+			}
+			j = '1';
+			i++;
+		}
+		if (!fin) {
+			// Negras dan jaque mate
+			if (posicion.getTurno() == Bando.BLANCO)
+				if (esCasillaAtacada(posicion.getKingPosition(Bando.BLANCO))) {
+					devolver = Resultado.JAQUE_MATE_NEGRO;
+				} else {
+					devolver = Resultado.TABLAS_AHOGADO;
+				}
+			else
+			// Blancas dan jaque mate
+			if (esCasillaAtacada(posicion.getKingPosition(Bando.NEGRO))) {
+				devolver = Resultado.JAQUE_MATE_BLANCO;
+			}
+			// Tablas por ahogado
+			else {
+				devolver = Resultado.TABLAS_AHOGADO;
+			}
+		}
+		return devolver;
+	}
+
+	/**
+	 * Interpreta un movimiento en notacion algebraica y lo realiza en la
+	 * Logica. NOTA: Partimos de la base de que el turno corresponde con el
+	 * movimiento que se recibe: no se puede dar el caso de que se reciba un
+	 * movimiento de negras y que el turno pertenezca a blancas o viceversa.
+	 * 
+	 * @param mov
+	 *            String que contiene el movimiento en notacion algebraica.
+	 * @todo Poner las ambig&#252;edades de la dama
+	 * @todo Puede ser que tengamos un problema: cuando una pieza esta clavada
+	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
+	 *       tenerlo en cuenta.
+	 */
+	public Movement moverALG(String mov) {
+		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
+		char tipoPieza = 'P';
+		Tipo piezaCoronacion = null;
+		int contadorOesEnroque = 0, i;
+		boolean finDestino = false;
+
+		for (i = mov.length() - 1; i &gt;= 0; i--) {
+			switch (mov.charAt(i)) {
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+				if (!finDestino) {
+					destinoNum = mov.charAt(i);
+				} else {
+					origenNum = mov.charAt(i);
+				}
+				break;
+			case 'a':
+			case 'b':
+			case 'c':
+			case 'd':
+			case 'e':
+			case 'f':
+			case 'g':
+			case 'h':
+				if (!finDestino) {
+					destinoLetra = mov.charAt(i);
+				} else {
+					origenLetra = mov.charAt(i);
+				}
+				finDestino = true;
+				break;
+			case 'B':
+				if (i != 0) {
+					piezaCoronacion = Tipo.ALFIL;
+				} else {
+					tipoPieza = 'A';
+				}
+				break;
+			case 'K':
+				tipoPieza = 'R';
+				break;
+			case 'N':
+				if (i != 0) {
+					piezaCoronacion = Tipo.CABALLO;
+				} else {
+					tipoPieza = 'C';
+				}
+				break;
+			case 'Q':
+				if (i != 0) {
+					piezaCoronacion = Tipo.DAMA;
+				} else {
+					tipoPieza = 'D';
+				}
+				break;
+			case 'R':
+				if (i != 0) {
+					piezaCoronacion = Tipo.TORRE;
+				} else {
+					tipoPieza = 'T';
+				}
+				break;
+			case '0':
+			case 'o':
+			case 'O':
+				contadorOesEnroque++;
+				break;
+			case 'x':
+			case '+':
+			case '!':
+			case '?':
+			case '-':
+			case '=':
+				break;
+			default:
+				System.out.print(&quot;Caracter desconocido: &quot; + mov.charAt(i));
+				break;
+			}
+		}
+		if(piezaCoronacion!=null) {
+			// TODO hacer el mostrarDialogoCoronacion;
+			coronar = piezaCoronacion;
+		}
+		// Enroque Corto
+		if (contadorOesEnroque == 2) {
+			origenLetra = 'e';
+			destinoLetra = 'g';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else if (contadorOesEnroque == 3) {
+			origenLetra = 'e';
+			destinoLetra = 'c';
+			if (posicion.getTurno() == Bando.BLANCO) {
+				origenNum = '1';
+				destinoNum = '1';
+			} else { // turno == NEGRO
+				origenNum = '8';
+				destinoNum = '8';
+			}
+		} else {
+			Square c = new Square(destinoLetra, destinoNum);
+			if (origenLetra == '\0' &amp;&amp; origenNum != '\0') {
+				for (char ii = 'a'; ii &lt;= 'h'; ii++) {
+					Piece p = posicion.getPieza(ii, origenNum);
+					if (p.canMove(c)) {
+						origenLetra = ii;
+						break;
+					}
+				}
+			} else if (origenLetra != '\0' &amp;&amp; origenNum == '\0') {
+				for (char ii = '1'; ii &lt;= '8'; ii++) {
+					Piece p = posicion.getPieza(origenLetra, ii);
+					if (p.canMove(c)) {
+						origenNum = ii;
+						break;
+					}
+				}
+			} else {
+				for (char ii = '1'; ii &lt;= '8'; ii++) {
+					for (char jj = 'a'; jj &lt;= 'h'; jj++) {
+						Piece p = posicion.getPieza(jj, ii);
+						if (p.canMove(c)) {
+							origenNum = ii;
+							break;
+						}
+					}
+				}
+			}
+		}
+		if (origenLetra == '\0' || origenNum == '\0' || destinoLetra == '\0'
+				|| destinoNum == '\0') {
+			System.out.println(tipoPieza + &quot; &quot; + origenLetra + &quot; &quot; + origenNum
+					+ &quot; &quot; + destinoLetra + &quot; &quot; + destinoNum);
+			return null;
+		} else {
+			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
+		}
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/chess/Board2D.java (from rev 32, trunk/MihailChessLib/com/mihail/chess/Tablero2D.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Board2D.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,569 @@
+package com.mihail.chess;
+
+import java.awt.BasicStroke;
+import java.awt.Color;
+import java.awt.Dimension;
+import java.awt.Font;
+import java.awt.GradientPaint;
+import java.awt.Graphics;
+import java.awt.Graphics2D;
+import java.awt.Image;
+import java.awt.MediaTracker;
+import java.awt.Point;
+import java.awt.geom.Rectangle2D;
+
+import javax.swing.ImageIcon;
+import javax.swing.JOptionPane;
+import javax.swing.JPanel;
+
+import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Piece.Tipo;
+
+/**
+ * Esta clase se encarga de proporcionar una vista b&#225;sica de la l&#243;gica, usada
+ * como modelo. No proporciona ningun metodo de manejo de eventos, y enmascara
+ * las funciones de la l&#243;gica interna.
+ * 
+ * @author Pedro Su&#225;rez Casal
+ * @author Iago Porto D&#237;az
+ */
+public class Board2D extends JPanel {
+
+	private static final long serialVersionUID = 1L;
+
+	/*
+	 * Tama&#241;o del borde del tablero.
+	 */
+	private int BORDE = 30;
+
+	/*
+	 * Tama&#241;o de la casilla.
+	 */
+	private int TAM;
+
+	/*
+	 * Tama&#241;o anterior, para comparar si es necesario redimensionar.
+	 * 
+	 * @TODO &#191;Es necesario este atributo? Queda chapucero.
+	 */
+	private int TAMant;
+
+	/*
+	 * Coordenada 'x' de la casilla pulsada por ultima vez [0, 8]. Sirve para
+	 * indicar al metodo de dibujo que la casilla indicada no se debe dibujar si
+	 * se esta arrastrando la pieza.
+	 */
+	protected int posX;
+
+	/*
+	 * Coordenada 'y' de la casilla pulsada por ultima vez [0, 8].
+	 */
+	protected int posY;
+
+	// Espacios que hay que dejar alrededor del tablero cuando se redimensiona
+	private int bordeSUP = 0;
+
+	private int bordeLAT = 0;
+
+	// Logica interna del tablero
+
+	protected Position tablero;
+
+	// Versiones ajustadas al tama&#241;o correcto de las imagenes
+	private Image[][] piezas = new Image[2][6];
+
+	// Indica el sentido en el que se esta dibujando el tablero
+	private boolean sentido = true;
+
+	// Matriz en la que se van marcando las casillas seleccionada
+	// 'S' -&gt; Casilla seleccionada (amarillo transparente)
+	// 'C' -&gt; Indica que se comio (cuadro rojo)
+	private char seleccion[][] = new char[8][8];
+
+	// Indica si se esta arrastrando una pieza
+	private boolean arrastrando = false;
+
+	/*
+	 * Posicion de la pieza que se esta arrastrando. Se usa en el metodo de
+	 * dibujo para dibujar la pieza piezaArrastrada en el lugar correcto. TODO
+	 * Remodelar para a&#241;adir objetos arbitrarios al tablero, entre ellos piezas
+	 * que estan siendo arrastradas.
+	 */
+	private int posPiezaX, posPiezaY;
+
+	/*
+	 * Imagen de la pieza qu esta siendo arrastrada.
+	 */
+	private Image piezaArrastrada;
+
+	/*
+	 * Colores que se dibujan las casillas en caso de que el tema no lo
+	 * establezca.
+	 */
+	private Color[] colorLiso = new Color[2];
+
+	/*
+	 * Tema que esta usando el tablero para dibujarse.
+	 */
+
+	private BoardTheme theme;
+
+	public Board2D(BoardTheme theme) {
+		this(theme, 60);
+	}
+
+	public Board2D(BoardTheme theme, int tam) {
+		super();
+		tablero = new Position();
+
+		TAM = tam;
+
+		// this.setAutoscrolls(true);
+		this.theme = theme;
+
+		redimensionar();
+	}
+
+	/**
+	 * Se encarga de cambiar el sentido del tablero.
+	 */
+
+	public void rotarTablero() {
+		sentido = !sentido;
+		repaint();
+	}
+
+	public Dimension getPreferredSize() {
+		return (new Dimension(8 * TAM + BORDE * 2, 8 * TAM + BORDE * 2));
+	}
+
+	public void paintComponent(Graphics g) {
+		Piece temp;
+		// Actualizamos el tama&#241;o de la casilla en caso de que redimensionen el
+		// tablero
+		int TAMtotal = Math.min(getWidth(), getHeight());
+		Graphics2D g2d = (Graphics2D) g;
+		TAMant = TAM;
+		TAM = (TAMtotal - BORDE * 2) / 8;
+		if (TAMant != TAM) {
+			redimensionar();
+		}
+
+		// Hints de renderizado
+		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
+		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
+
+		if(theme.getBackground()==null) {
+			g.setColor(Color.LIGHT_GRAY);
+			g.fillRect(0, 0, getWidth(), getHeight());
+		} else {
+			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
+		}
+
+		if (getWidth() &lt; getHeight()) {
+			bordeSUP = (getHeight() - getWidth()) / 2;
+			bordeLAT = 0;
+		} else {
+			bordeLAT = (getWidth() - getHeight()) / 2;
+			bordeSUP = 0;
+		}
+		g.setClip(bordeLAT, bordeSUP, TAMtotal, TAMtotal);
+		g.translate(bordeLAT, bordeSUP);
+
+		// Borde tablero
+		dibujarBorde(g);
+		// Bucle para dibujar el tablero
+
+		g.setClip(BORDE, BORDE, getWidth() - BORDE, getHeight() - BORDE);
+		g.translate(BORDE, BORDE);
+		for (int j = 0; j &lt; 8; j++) {
+			for (int i = 0; i &lt; 8; i++) {
+				// En funcion de nuestra posicion escogemos el color para
+				// casillas blancas o negras
+				// if (activado) {
+				int v = (i + j) % 2;
+				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
+						: Bando.NEGRO);
+				if (textura != null)
+
+					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
+
+				else {
+					g.setColor(colorLiso[v]);
+					g.fillRect(i * TAM, j * TAM, TAM, TAM);
+				}
+
+				// Dibujamos la casilla
+				//
+				// En caso de que la casilla que tratamos este seleccionada, la
+				// marcamos de color verde
+				int ii = i, jj = j;
+				if (!sentido) {
+					ii = 7 - i;
+					jj = 7 - j;
+				}
+
+				// En funcion del caracter de seleccion dibujamos una cosa u
+				// otra
+				switch (seleccion[ii][jj]) {
+				case 'S':
+					g.setColor(new Color(255, 255, 0, 50));
+					g.fill3DRect(i * TAM, j * TAM, TAM, TAM, true);
+					break;
+				case 'M':
+					g2d.setStroke(new BasicStroke(2.0F, BasicStroke.CAP_BUTT,
+							BasicStroke.JOIN_ROUND));
+					g.setColor(new Color(220, 0, 0));
+					g2d.draw(new Rectangle2D.Float(i * TAM, j * TAM, TAM - 1,
+							TAM - 1));
+
+					// g.drawRect(i * TAM, j * TAM, TAM-1, TAM-1);
+					break;
+				default:
+				}
+
+				// Comprobamos si existe pieza en esa casilla, y en ese caso la
+				// dibujamos
+				char letra, numero;
+				// Se comprueba el sentido en el que dibujamos
+				if (sentido) {
+					numero = (char) ((7 - j) + '1');
+					letra = (char) (i + 'a');
+				} else {
+					numero = (char) (j + '1');
+					letra = (char) ((7 - i) + 'a');
+				}
+
+				if ((temp = tablero.getPieza(letra, numero)) != null) {
+					if (arrastrando
+							&amp;&amp; ((sentido &amp;&amp; i == posX &amp;&amp; j == posY) || (!sentido
+									&amp;&amp; i == 7 - posX &amp;&amp; j == 7 - posY))) {
+						continue;
+					}
+
+					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
+					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
+				}
+			}
+
+		}
+
+		// Este es el caso de que haya que dibujar la pieza a arrastrar. Se
+		// dibuja por encima de todo el resto del tablero
+		if (piezaArrastrada != null) {
+			g.translate(-bordeLAT, -bordeSUP);
+			g.translate(-BORDE, -BORDE);
+			g.setClip(posPiezaX - TAM / 2, posPiezaY - TAM / 2, TAM, TAM);
+			if (arrastrando) {
+				g.drawImage(piezaArrastrada, posPiezaX - TAM / 2, posPiezaY
+						- TAM / 2, null);
+			}
+		}
+
+	}
+
+	/**
+	 * @return Devuelve el tama&#241;o del borde del tablero.
+	 */
+
+	public int getBorde() {
+		return BORDE;
+	}
+
+	/**
+	 * @return Devuelve el tama&#241;o de las casilla.
+	 */
+
+	public int getTamanhoCasilla() {
+		return TAM;
+	}
+
+	/**
+	 * @param tam
+	 *            Establece el tama&#241;o de las casilla.
+	 */
+
+	public void setTamanhoCasilla(int tam) {
+		TAM = tam;
+	}
+
+	/**
+	 * Establece que una pieza se esta arrastrando para que la dibuje en la
+	 * posicion correspondiente.
+	 * 
+	 * @param arrastrando
+	 *            El valor al que queremos establecer si se esta arrastrando o
+	 *            no.
+	 */
+	public void setArrastrando(boolean arrastrando) {
+		this.arrastrando = arrastrando;
+	}
+
+	/**
+	 * @param piezaArrastrada
+	 *            Establece al imagen a arrastrar.
+	 */
+	public void setPiezaArrastrada(Image piezaArrastrada) {
+		this.piezaArrastrada = piezaArrastrada;
+	}
+
+	/**
+	 * @return Devuelve si la casilla indicada por (i, j) tiene algun tipo de
+	 *         seleccion.
+	 */
+
+	public char getSeleccion(int i, int j) {
+		return seleccion[i][j];
+	}
+
+	/**
+	 * Establece la seleccion de una casilla.
+	 * 
+	 * @param s
+	 *            Seleccion a la que establecemos la casilla.
+	 */
+	public void setSeleccion(char s, int i, int j) {
+		this.seleccion[i][j] = s;
+	}
+
+	public Point getPosPiezaArrastrada() {
+		return new Point(posPiezaX, posPiezaY);
+	}
+
+	/**
+	 * @param posPiezaX
+	 *            The posPiezaX to set.
+	 */
+	public void setPosPiezaArrastrada(int posPiezaX, int posPiezaY) {
+		this.posPiezaX = posPiezaX;
+		this.posPiezaY = posPiezaY;
+	}
+
+	/**
+	 * @return Devuelve el borde lateral, el espacio que puede sobrar a los
+	 *         lados del tablero.
+	 */
+	public int getBordeLateral() {
+		return bordeLAT;
+	}
+
+	/**
+	 * @return Devuelve el borde superior, el espacio que puede sobrar arriba y
+	 *         abajo del tablero.
+	 */
+	public int getBordeSuperior() {
+		return bordeSUP;
+	}
+
+	/**
+	 * Indica el sentido en el que se esta dibujando el tablero
+	 * 
+	 * @return Devuelve true si las blancas estan abajo y false si las negras
+	 *         estan abajo.
+	 */
+
+	public boolean isSentido() {
+		return sentido;
+	}
+
+	/**
+	 * Establece el sentido del tablero.
+	 * 
+	 * @param sentido
+	 *            The sentido to set.
+	 */
+	public void setSentido(boolean sentido) {
+		this.sentido = sentido;
+	}
+
+	/**
+	 * Obtiene el color liso de las casillas de un color.
+	 * 
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
+	 * @return El color liso.
+	 */
+	public Color getColorLiso(Bando b) {
+		return colorLiso[bandoToInt(b)];
+	}
+
+	/**
+	 * Establece el color liso de las casillas de un color. Este color solo se
+	 * mostrara en caso de que el tema no establezca una textura para las
+	 * casillas.
+	 * 
+	 * @param b
+	 *            El tipo de las casillas, blancas o negras.
+	 * @param colorLiso
+	 *            El color liso.
+	 */
+
+	public void setColorLiso(Bando b, Color colorLiso) {
+		this.colorLiso[bandoToInt(b)] = colorLiso;
+	}
+
+	/**
+	 * Establece el tema que usa el tablero para dibujarse.
+	 * 
+	 * @param theme
+	 *            Tema a establecer.
+	 */
+
+	public void setTema(BoardTheme theme) {
+		this.theme = theme;
+	}
+	
+	public void setPieza(Piece pieza, Square casilla) {
+		tablero.setPieza(pieza, casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void borrarPieza(Square casilla) {
+		tablero.borrarPieza(casilla);
+		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
+	}
+	
+	public void setFEN(String pos) {
+		tablero.setPosicion(pos);
+		repaint();
+	}
+
+	/*
+	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
+	 * el centro de la casilla. TODO Modificar para que funcione con la esquina
+	 * superior izquierda?
+	 */
+
+	protected void repintarCasilla(int x, int y) {
+		repaint(x - TAM / 2, y - TAM / 2, TAM, TAM);
+	}
+
+	/**
+	 * Metodo de utilidad para obtener de forma sencilla la casilla
+	 * correspondiente a la que pertenece un pixel en la posicion (x, y).
+	 * 
+	 * @param x
+	 *            Coordenada x
+	 * @param y
+	 *            Coordenada y
+	 * @return Devuelve un punto con las coordenadas de la casilla
+	 *         correspondiente al punto x, y. El valor devuelto estar&#225; en el
+	 *         intervalo [0, 7].
+	 */
+	protected Point getCasilla(int x, int y) {
+		int posX = (x - BORDE - bordeLAT) / TAM, posY = (y - BORDE - bordeSUP)
+				/ TAM;
+		if (!isSentido()) {
+			posX = 7 - posX;
+			posY = 7 - posY;
+		}
+		return new Point(posX, posY);
+	}
+
+	private void dibujarBorde(Graphics g) {
+		Image borde = theme.getMarco();
+		if (borde != null) {
+			g.drawImage(borde, 0, 0, null);
+		} else { // Dibujamos a mano
+			g.setColor(Color.BLACK);
+
+			g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
+					getWidth(), getHeight()));
+			// char num = '8';
+			// char let = 'a';
+
+			g.setColor(new Color(209, 193, 134));
+			g.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));
+
+			int yF = 8 * TAM + BORDE * 3 / 2 + 6;
+			for (int i = 0; i &lt; 8; i++) {
+				int xF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
+					g.drawString(new Character((char) (i + 'A')).toString(),
+							xF, yF);
+				} else {
+					g.drawString(
+							new Character((char) (7 - i + 'A')).toString(), xF,
+							yF);
+				}
+			}
+			int xF = BORDE / 2 - 3;
+			for (int i = 0; i &lt; 8; i++) {
+				yF = i * TAM + BORDE + TAM / 2;
+				if (sentido) {
+
+					g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
+
+				} else {
+					g.drawString(new Integer(i + 1).toString(), xF, yF);
+				}
+			}
+		}
+	}
+
+	private int bandoToInt(Bando b) {
+		if (b == Bando.BLANCO) {
+			return 0;
+		}
+		return 1;
+	}
+	
+	private int tipoToInt(Tipo tipo) {
+		switch(tipo) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		}
+		return -1;
+	}
+	
+	private Tipo intToTipo(int i) {
+		switch(i) {
+		case 0:
+			return Tipo.PEON;
+		case 1:
+			return Tipo.CABALLO;
+		case 2:
+			return Tipo.ALFIL;
+		case 3:
+			return Tipo.TORRE;
+		case 4:
+			return Tipo.DAMA;
+		case 5:
+			return Tipo.REY;
+		}
+		return null;
+	}
+
+	/*
+	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
+	 * tama&#241;o adecuado del tablero
+	 */
+
+	private final void redimensionar() {
+		MediaTracker media = new MediaTracker(this);
+		for (int i = 0; i &lt; 2; i++) {
+			for (int j = 0; j &lt; 6; j++) {
+				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
+						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
+				media.addImage(piezas[i][j], 1);
+			}
+		}
+		try {
+			media.waitForID(1);
+		} catch (InterruptedException e) {
+			JOptionPane.showMessageDialog(this,
+					&quot;Redimensionado de Imagenes Interrumpido:\n&quot;
+							+ e.getMessage());
+		}
+	}
+}
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/chess/BoardTheme.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/BoardTheme.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -13,8 +13,8 @@
 
 import javax.swing.ImageIcon;
 
-import com.mihail.chess.Logica.Bando;
-import com.mihail.chess.Pieza.Tipo;
+import com.mihail.chess.Board.Bando;
+import com.mihail.chess.Piece.Tipo;
 
 /**
  * Representa el tema de imagenes de piezas, texturas de las casillas, textura

Deleted: trunk/MihailChessLib/com/mihail/chess/Casilla.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,111 +0,0 @@
-/*
- * Created on 25-jul-2005
- *
- * MihailChess - Casilla.java
- * 
- * Autores:  Iago Porto Diaz
- * 			 Pedro Suarez Casal
- * 
- */
-package com.mihail.chess;
-
-/**
- * Representa una casilla en un tablero de ajedrez. Simplemente almacena informacion sobre
- * la letra y el numero.
- * @author wotan
- *
- */
-
-public class Casilla {
-
-	private char letra;
-
-	private char numero;
-
-	/**
-	 * Crea una casilla con la letra y numero iguales a cero.
-	 *
-	 */
-	
-	public Casilla() {
-		this.letra = 0;
-		this.numero = 0;
-	}
-	
-	/**
-	 * Crea una casilla con la letra y numero indicados.
-	 * 
-	 * @param letra Letra de la casilla
-	 * @param numero Numera de la casilla
-	 */
-
-	public Casilla(char letra, char numero) {
-		this.letra = letra;
-		this.numero = numero;
-	}
-
-	public boolean equals(Object o) {
-		if (o instanceof Casilla) {
-			Casilla c = (Casilla) o;
-			return c.letra == letra &amp;&amp; c.numero == numero;
-		}
-		return false;
-	}
-	
-	/**
-	 * Suma a la casilla actual un vector de direccion, dando como resultado otra casilla.
-	 * A la letra se le suma la direccion x y al numero la direccion y.
-	 * 
-	 * @param v El vector que queremos sumar a la casilla actual.
-	 * @return Otra casilla resultado de sumar a la casilla actual el vector recibido.
-	 */
-
-	public Casilla add(VectorDireccion v) {
-		return new Casilla((char) (this.letra + v.getX()),
-				(char) (this.numero + v.getY()));
-	}
-	
-	/**
-	 * Obtiene la letra de la casilla.
-	 * 
-	 * @return La letra de la casilla
-	 */
-
-	public char getLetra() {
-		return letra;
-	}
-	
-	/**
-	 * Establece la letra de la casilla.
-	 * 
-	 * @param letra La letra de la casilla
-	 */
-
-	public void setLetra(char letra) {
-		this.letra = letra;
-	}
-	
-	/**
-	 * Obtiene el numero de la casilla.
-	 * 
-	 * @return El numero de la casilla
-	 */
-
-	public char getNumero() {
-		return numero;
-	}
-	
-	/**
-	 * Establece el numero de la casilla.
-	 * 
-	 * @param numero El numero de la casilla
-	 */
-
-	public void setNumero(char numero) {
-		this.numero = numero;
-	}
-
-	public String toString() {
-		return letra + &quot;&quot; + numero;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,125 +0,0 @@
-package com.mihail.chess;
-
-import java.util.ArrayList;
-
-/**
- * Esta clase define un objeto TablaHash, que representa a la tabla hash que se
- * usa para almacenar las claves que identifican las posiciones a lo largo de la
- * partida de ajedrez. Asocia a cada clave de posici&#243;n el n&#250;mero de
- * repeticiones.
- * 
- * @author Pedro Su&#225;rez Casal
- * @author Iago Porto D&#237;az
- */
-public final class DiccionarioPosiciones {
-	private ArrayList[] tabla;
-
-	private int tam;
-
-	/**
-	 * Crea una nueva tabla hash del tama&#241;o indicado. Normalmente se creara una
-	 * tabla con un tama&#241;o proximo a 40-50, para situarse en el peor caso de
-	 * repeticiones, y aumentar el rendimiento de la tabla.
-	 */
-	public DiccionarioPosiciones(int t) {
-		tabla = new ArrayList[t];
-		for (int i = 0; i &lt; tabla.length; i++)
-			tabla[i] = new ArrayList();
-		tam = t;
-	}
-
-	/**
-	 * Inserta una clave de posicion dentro de la tabla. Cuando inserta una de
-	 * las claves tambien comprueba si esa posicion esta guardada. Si lo esta,
-	 * vuelve a guardar la clave con el numero de repeticiones aumentado, si no,
-	 * a&#241;ade un nuevo elemento con las repeticiones a 1.
-	 * 
-	 * @param clave
-	 *            Clave que queremos insertar dentro de la tabla
-	 */
-	public void insertar(int clave) {
-		int pos = clave % tam;
-		int i = 0;
-
-		while (i &lt; tabla[pos].size()
-				&amp;&amp; ((Item) tabla[pos].get(i)).getClave() != clave)
-			i++;
-
-		if (i &lt; tabla[pos].size()) {
-			if (((Item) tabla[pos].get(i)).getClave() == clave)
-				((Item) tabla[pos].get(i)).aumentarRep();
-		} else
-			tabla[pos].add(new Item(clave));
-	}
-
-	/**
-	 * Borra todos los elementos de la tabla.
-	 */
-	public void borrarTabla() {
-		for (int i = 0; i &lt; tabla.length; i++)
-			tabla[i].clear();
-	}
-
-	/**
-	 * Obtiene el numero de repeticiones de una posicion dada.
-	 * 
-	 * @param clave
-	 *            La clave asociada con una posicion.
-	 * @return El numero de repeticiones de la clave recibida.
-	 */
-	public int getRepeticiones(int clave) {
-		int pos = clave % tam;
-		int i = 0;
-
-		while (i &lt; tabla[pos].size()
-				&amp;&amp; ((Item) (tabla[pos].get(i))).getClave() != clave)
-			i++;
-
-		if (i &lt; tabla[pos].size())
-			return ((Item) tabla[pos].get(i)).getRepeticiones();
-		return -1;
-	}
-
-	public String toString() {
-		String cad = &quot;[&quot;;
-		for (int i = 0; i &lt; tabla.length; i++) {
-			cad += &quot;[&quot;;
-			for (int j = 0; j &lt; tabla[i].size(); j++) {
-				cad += tabla[i].get(j);
-			}
-			cad += &quot;]&quot;;
-		}
-
-		cad += &quot;]&quot;;
-		return cad;
-	}
-	
-	private final class Item {
-		private int clave;
-
-		private int repeticiones = 1;
-
-		public Item(int num) {
-			clave = num;
-		}
-
-		public int getClave() {
-			return clave;
-		}
-
-		public int getRepeticiones() {
-			return repeticiones;
-		}
-
-		public void aumentarRep() {
-			repeticiones++;
-		}
-
-		public String toString() {
-			String cad = &quot;(&quot; + clave + &quot;, &quot; + repeticiones + &quot;)&quot;;
-
-			return cad;
-		}
-
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/DirectionVector.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/DirectionVector.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,77 @@
+package com.mihail.chess;
+
+/**
+ * Almacena la direcci&#243;n en la que una pieza puede mover. Cuando se crea un
+ * nuevo vector direcci&#243;n, se entiende que la x y la y indican las componentes
+ * del vector dentro del tablero. Adem&#225;s el vector debe ser 'unitario' para que
+ * la l&#243;gica lo interprete correctamente. Por ejemplo, si queremos indicar los
+ * movimientos posibles de una dama, basta con indicar 8 vectores de direcci&#243;n:
+ * (1, 0) (1, 1) (1, -1) (0, 1) (0, -1) (-1, 0) (-1, 1) (-1, -1). Esto
+ * proporciona gran flexibilidad a la hora de definir nuevas piezas en sistemas
+ * de ajedrez alternativos. Podriamos definir una pieza que se mueva unicamente
+ * como (1, 2) y (0, 1). TODO indicar los vectores que deben ser estrictamente
+ * unitarios, para diferenciar piezas que se mueven una casilla de las que se
+ * mueven toda la fila. Quiza sea conveniente indicarlo en Pieza, junto con si
+ * la pieza puede saltar a otras.
+ */
+
+public class DirectionVector {
+	private int x, y;
+
+	/**
+	 * Crea un nuevo vector de direcci&#243;n.
+	 * 
+	 * @param x_
+	 *            Desplazamiento permitido en sentido horizontal, es decir, a
+	 *            traves de las filas
+	 * @param y_
+	 *            Desplazamiento permitido en sentido vertical, es decir, a
+	 *            traves de las columnas
+	 */
+	public DirectionVector(int x_, int y_) {
+		x = x_;
+		y = y_;
+	}
+
+	/**
+	 * Comprueba si un vector es multiplo de otro. Por ejemplo, devolveria true
+	 * en caso que al vector (1, 1) se le pase el vector (2, 2).
+	 * 
+	 * @param v
+	 *            Vector con el que queremos comprobar si es la misma direccion.
+	 * @return Un booleano si este vector y el recibido siguen la misma
+	 *         direccion.
+	 */
+	public boolean esMismaDireccion(DirectionVector v) {
+		int difX, difY;
+
+		if ((x == 0 &amp;&amp; v.getX() != 0) || (y == 0 &amp;&amp; v.getY() != 0))
+			return false;
+
+		if (v.getX() == 0 &amp;&amp; x == 0)
+			difX = 1;
+		else
+			difX = v.getX() / x;
+
+		if (v.getY() == 0 &amp;&amp; y == 0)
+			difY = 1;
+		else
+			difY = v.getY() / y;
+
+		return (difY == difX);
+	}
+
+	/**
+	 * Devuelve el desplazamiento horizontal de este vector.
+	 */
+	public int getX() {
+		return x;
+	}
+
+	/**
+	 * Devuelve el desplazamiento vertical de este vector.
+	 */
+	public int getY() {
+		return y;
+	}
+}

Deleted: trunk/MihailChessLib/com/mihail/chess/Logica.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Logica.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,1033 +0,0 @@
-package com.mihail.chess;
-
-import java.util.ArrayList;
-
-import com.mihail.chess.Pieza.Tipo;
-
-public class Logica {
-
-	public static enum Bando {
-		BLANCO, NEGRO;
-
-		public boolean equals(Bando b) {
-			return this == b;
-		}
-	}
-
-	public static enum Resultado {
-		JAQUE_MATE_BLANCO, JAQUE_MATE_NEGRO, TABLAS_REPETICION, TABLAS_50_MOV, TABLAS_INSUF_MATERIAL, TABLAS_AHOGADO
-	}
-
-	// public static final int JAQUE_MATE_BLANCO = 6;
-	// public static final int JAQUE_MATE_NEGRO = 1;
-	// public static final int TABLAS_REPETICION = 2;
-	// public static final int TABLAS_50_MOV = 3;
-	// public static final int TABLAS_INSUF_MATERIAL = 4;
-	// public static final int TABLAS_AHOGADO = 5;
-
-	/**
-	 * Este atributo sirve para guardar la lista de movimientos de una partida.
-	 */
-	private ArbolVariantes movimientos;
-
-	/**
-	 * Este atributo sirve para saber en que posicion de la lista de movimientos
-	 * nos encontramos, a la hora de avanzar y retroceder por una partida.
-	 * Siempre va una posici&#243;n por delante de la aut&#233;ntica posici&#243;n
-	 */
-	private int indice;
-
-	/**
-	 * Este atributo se utiliza para las coronaciones.
-	 */
-	private Tipo coronar = Tipo.DAMA;
-
-	/**
-	 * Tabla hash usada para comprobar posiciones repetidas.
-	 */
-	private DiccionarioPosiciones hash = new DiccionarioPosiciones(51);
-
-	/**
-	 * Posicion actual en juego
-	 */
-	private Posicion posicion;
-
-	/**
-	 * Crea una nueva instancia de la clase y crea las piezas, colocandolas en
-	 * la posicion que indica el String posInicial.
-	 * 
-	 * @param posInicial
-	 *            Es un String que indica una posicion de juego, siguiendo el
-	 *            estandar FEN.
-	 */
-	public Logica(Posicion posInicial) {
-		movimientos = new ArbolVariantes();
-		posicion = posInicial;
-		hash.insertar(posicion.getClavePosicion());
-	}
-
-	/**
-	 * Reinicia la posicion del tablero a la posicion inicial.
-	 */
-	public void reiniciarTablero() {
-		posicion.setPosicion(Posicion.CAD_INICIAL);
-	}
-
-	/**
-	 * Indica a que pieza queremos coronar por defecto.
-	 * 
-	 * @param c
-	 *            Caracter que indica el tipo de pieza a coronar (C, A, T, D).
-	 */
-
-	public void setCoronacion(Tipo c) {
-		coronar = c;
-	}
-
-	/**
-	 * Permite saber el numero total de movimientos de la partida.
-	 * 
-	 * @return Un entero, el numero en cuestion.
-	 */
-
-	public int getNumTotalMovimientos() {
-		return movimientos.getNumMovimientos();
-	}
-
-	public Posicion getPosicion() {
-		return this.posicion;
-	}
-
-	/**
-	 * Obtiene el resultado de la partida.
-	 * 
-	 * @return Devuelve un caracter: &lt;BR&gt;
-	 *         'B' -&gt; Victoria Blanca &lt;BR&gt;
-	 *         'N' -&gt; Victoria Negra &lt;BR&gt;
-	 *         'T' -&gt; Tablas &lt;BR&gt;
-	 *         '\0' -&gt; Partida Inacabada o Resultado Desconocido
-	 */
-	public Resultado getResultado() {
-		return movimientos.getLastMovimiento().getFinPartida();
-	}
-
-	/**
-	 * Calcula los movimientos validos para todas las piezas del tablero.
-	 */
-	public void calcularMovimientos() {
-		for (char i = 'a'; i &lt;= 'h'; i++) {
-			for (char j = '1'; j &lt;= '8'; j++) {
-				Pieza p = posicion.getPieza(i, j);
-				if (p != null) {
-					if (!Pieza.esBandoContrario(posicion.getTurno(), p)) {
-						calcularMovimientos(p);
-					}
-				}
-			}
-		}
-	}
-
-	/**
-	 * Calcula los movimientos validos para una pieza en concreto, que se le
-	 * pasa como parametro.
-	 * 
-	 * @param pieza
-	 *            Pieza de la que queremos calcular sus movimientos legales
-	 */
-	private void calcularMovimientos(Pieza pieza) {
-		pieza.getCasillasValidas().clear();
-		switch (pieza.getTipo()) {
-		case PEON:
-			// Peon
-			// Peon blanco
-			if (pieza.getBando() == Bando.BLANCO) {
-				// Movimiento hacia delante
-				// Hacemos dos iteraciones, una para el caso de que avance
-				// una casilla, otra para el caso de que avance dos
-				if (posicion.esVacia(pieza.getLetra(),
-						(char) (pieza.getNum() + 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() + 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() + 1));
-						if (pieza.getNum() == '2'
-								&amp;&amp; posicion.esVacia(pieza.getLetra(),
-										(char) (pieza.getNum() + 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() + 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() + 2));
-							}
-						}
-					}
-				}
-				if (posicion.getAlPaso() != '\0'
-						&amp;&amp; pieza.getNum() == '5'
-						&amp;&amp; Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
-							.getNum() + 1));
-				}
-				// Movimientos para comer
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() + 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() + 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() + 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() + 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-			// Peon negro
-			else {
-				if (posicion.esVacia(pieza.getLetra(),
-						(char) (pieza.getNum() - 1))) {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-							.getLetra(), (char) (pieza.getNum() - 1))) {
-						pieza.anadirMov(pieza.getLetra(), (char) (pieza
-								.getNum() - 1));
-						if (pieza.getNum() == '7'
-								&amp;&amp; posicion.esVacia(pieza.getLetra(),
-										(char) (pieza.getNum() - 2))) {
-							if (esLegal(pieza.getLetra(), pieza.getNum(), pieza
-									.getLetra(), (char) (pieza.getNum() - 2))) {
-								pieza.anadirMov(pieza.getLetra(), (char) (pieza
-										.getNum() - 2));
-							}
-						}
-					}
-				}
-				if (posicion.getAlPaso() != '\0'
-						&amp;&amp; pieza.getNum() == '4'
-						&amp;&amp; Math.abs(pieza.getLetra() - posicion.getAlPaso()) == 1) {
-					pieza.anadirMov(posicion.getAlPaso(), (char) (pieza
-							.getNum() - 1));
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() + 1));
-					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() + 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() + 1),
-									(char) (pieza.getNum() - 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-				try {
-					Pieza p = posicion.getPieza((char) (pieza.getLetra() - 1),
-							(char) (pieza.getNum() - 1));
-					if (p != null &amp;&amp; p.getBando() == Bando.NEGRO) {
-						if (esLegal(pieza.getLetra(), pieza.getNum(),
-								(char) (pieza.getLetra() - 1), (char) (pieza
-										.getNum() - 1))) {
-							pieza.anadirMov((char) (pieza.getLetra() - 1),
-									(char) (pieza.getNum() - 1));
-						}
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-			break;
-		case CABALLO:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				Casilla destino = pieza.getCasilla().add(v);
-				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Pieza p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (p == null
-								|| (p != null &amp;&amp; Pieza.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			break;
-		case DAMA:
-		case ALFIL:
-		case TORRE:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				try {
-					Casilla destino = pieza.getCasilla().add(v);
-					Pieza p = posicion.getPieza(destino.getLetra(), destino
-							.getNumero());
-					while (p == null) {
-						p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-								.getLetra(), destino.getNumero())) {
-							if (p == null
-									|| (p != null &amp;&amp; Pieza.esBandoContrario(
-											pieza, p))) {
-								pieza.anadirMov(destino);
-							}
-						}
-						destino = destino.add(v);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			break;
-		case REY:
-			for (VectorDireccion v : pieza.getDirecciones()) {
-				Casilla destino = pieza.getCasilla().add(v);
-				try {
-					if (esLegal(pieza.getLetra(), pieza.getNum(), destino
-							.getLetra(), destino.getNumero())) {
-						Pieza p = posicion.getPieza(destino.getLetra(), destino
-								.getNumero());
-						if (p == null
-								|| (p != null &amp;&amp; Pieza.esBandoContrario(pieza,
-										p)))
-							pieza.anadirMov(destino);
-					}
-				} catch (ArrayIndexOutOfBoundsException e) {
-				}
-			}
-
-			if (posicion.getEnroqueCorto(posicion.getTurno())
-					&amp;&amp; !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() + 1), pieza
-							.getNum())
-					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() + 1), (pieza
-							.getNum()))
-					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() + 2), pieza
-							.getNum())
-					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() + 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() + 2), pieza.getNum());
-			}
-			if (posicion.getEnroqueLargo(posicion.getTurno())
-					&amp;&amp; !esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))
-					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() - 1), pieza
-							.getNum())
-					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() - 1), (pieza
-							.getNum()))
-					&amp;&amp; posicion.esVacia((char) (pieza.getLetra() - 2), pieza
-							.getNum())
-					&amp;&amp; !esCasillaAtacada((char) (pieza.getLetra() - 2), (pieza
-							.getNum()))) {
-				pieza.anadirMov((char) (pieza.getLetra() - 2), pieza.getNum());
-			}
-			break;
-		}
-	}
-
-	/**
-	 * Metodo de utilidad que se comporta exactamente igual que
-	 * esCasillaAtacada(char, char)
-	 * 
-	 * @param c
-	 *            Casilla que queremos comprobar si esta siendo atacada
-	 * @return Devuelve un booleano indicando si es una casilla atacada o no
-	 */
-	public boolean esCasillaAtacada(Casilla c) {
-		return esCasillaAtacada(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * esCasillaAtacada determina si hay alguna pieza que ataque la casilla que
-	 * se le pasa como parametro. &lt;BR&gt;
-	 * NOTA sobre el codigo: se necesita comprobar el turno para: en el turno en
-	 * el que mueves necesitas saber que casillas estan atacadas por el bando
-	 * contrario, y solo por este bando. No interesan las casillas que ataca el
-	 * bando que mueve. Ademas se puede comprobar que una casillas es atacada
-	 * estando vacia lo cual implica que no hay colores contrarios y es
-	 * necesario conocer el turno para saber quien ataca
-	 * 
-	 * @param letra
-	 *            Letra de la casilla que queremos comprobar si esta siendo
-	 *            atacada
-	 * @param num
-	 *            N&#250;mero de la casilla que queremos comprobart si est&#225; siendo
-	 *            atacada
-	 * @return Devuelve un booleano indicando si es una casilla atacada o no
-	 */
-	public boolean esCasillaAtacada(char letra, char num) {
-		// Primero miro las casillas
-		// a salto de caballo. Despues, las verticales, horizontales y
-		// diagonales.
-
-		// Casillas a salto de caballo
-		ArrayList&lt;VectorDireccion&gt; dir = new ArrayList&lt;VectorDireccion&gt;();
-		dir.add(new VectorDireccion(1, 2));
-		dir.add(new VectorDireccion(-1, 2));
-		dir.add(new VectorDireccion(2, 1));
-		dir.add(new VectorDireccion(2, -1));
-		dir.add(new VectorDireccion(1, -2));
-		dir.add(new VectorDireccion(-1, -2));
-		dir.add(new VectorDireccion(-2, 1));
-		dir.add(new VectorDireccion(-2, -1));
-		for (VectorDireccion v : dir) {
-			try {
-				Pieza p = posicion.getPieza((char) (letra + v.getX()),
-						(char) (num + v.getY()));
-				if (p != null) {
-					if (Pieza.esBandoContrario(posicion.getTurno(), p)
-							&amp;&amp; p.getTipo() == Tipo.CABALLO) {
-						return true;
-					}
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, 0));
-		dir.add(new VectorDireccion(-1, 0));
-		dir.add(new VectorDireccion(0, 1));
-		dir.add(new VectorDireccion(0, -1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&amp;&amp; (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.TORRE || (num + v.getY() == numDest
-								&amp;&amp; letra + v.getX() == letDest &amp;&amp; p.getTipo() == Tipo.REY))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, 1));
-		dir.add(new VectorDireccion(-1, 1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&amp;&amp; (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&amp;&amp; letra + v.getX() == letDest &amp;&amp; (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON &amp;&amp; p.getBando() == Bando.NEGRO))))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-		dir.clear();
-		dir.add(new VectorDireccion(1, -1));
-		dir.add(new VectorDireccion(-1, -1));
-
-		for (VectorDireccion v : dir) {
-			try {
-				char letDest = (char) (letra + v.getX()), numDest = (char) (num + v
-						.getY());
-				Pieza p = posicion.getPieza(letDest, numDest);
-				while (p == null) {
-					letDest = (char) (letDest + v.getX());
-					numDest = (char) (numDest + v.getY());
-					p = posicion.getPieza(letDest, numDest);
-				}
-				if (Pieza.esBandoContrario(posicion.getTurno(), p)
-						&amp;&amp; (p.getTipo() == Tipo.DAMA
-								|| p.getTipo() == Tipo.ALFIL || (num + v.getY() == numDest
-								&amp;&amp; letra + v.getX() == letDest &amp;&amp; (p.getTipo() == Tipo.REY || (p
-								.getTipo() == Tipo.PEON &amp;&amp; p.getBando() == Bando.BLANCO))))) {
-					return true;
-				}
-			} catch (ArrayIndexOutOfBoundsException e) {
-			}
-		}
-
-		return false;
-	}
-
-	/**
-	 * Determina si un movimiento es legal, analizando la situacion en la
-	 * partida.
-	 * 
-	 * @param letOrig
-	 *            Letra de la casilla de origen.
-	 * @param numOrig
-	 *            Numero de la casilla de origen.
-	 * @param letDest
-	 *            Letra de la casilla de destino.
-	 * @param numDest
-	 *            Numero de la casilla de destino.
-	 * @return True si el movimiento es legal, false en caso contrario.
-	 */
-	private boolean esLegal(char letOrig, char numOrig, char letDest,
-			char numDest) {
-		boolean resultado;
-		Pieza movida = posicion.getPieza(letOrig, numOrig);
-		Pieza temp = posicion.getPieza(letDest, numDest);
-		posicion.borrarPiezaInternal(letOrig, numOrig);
-		posicion.setPiezaInternal(movida, letDest, numDest);
-		resultado = esCasillaAtacada(posicion.getKingPosition(posicion
-				.getTurno()));
-		posicion.borrarPiezaInternal(letDest, numDest);
-		posicion.setPiezaInternal(movida, letOrig, numOrig);
-		if (temp != null)
-			posicion.setPiezaInternal(temp, letDest, numDest);
-		return !resultado;
-	}
-
-	/**
-	 * Este metodo mueve una pieza en el tablero, comprobando que este
-	 * movimiento sea permitido.
-	 * 
-	 * @param origenLetra
-	 *            Es la letra de la casilla de origen
-	 * @param origenNum
-	 *            Es el numero de la casilla de origen
-	 * @param destinoLetra
-	 *            Es la letra de la casilla de destino
-	 * @param destinoNum
-	 *            Es el numero de la casilla de destino
-	 * @return Devuelve un objeto Movimiento o null si no esta permitido.
-	 */
-	public Movimiento mover(char origenLetra, char origenNum,
-			char destinoLetra, char destinoNum) {
-		Pieza piezaQueMueve;
-		int i;
-		Movimiento mov;
-		piezaQueMueve = posicion.getPieza(origenLetra, origenNum);
-
-		// Comprobamos que en la casilla de origen hay una pieza
-		if (piezaQueMueve == null) {
-			return null;
-		}
-
-		if (Pieza.esBandoContrario(posicion.getTurno(), piezaQueMueve)) {
-			return null;
-		}
-		if (indice != movimientos.getNumHalfPly())
-			return null;
-		// Buscamos la casilla de destino entre las casillas validas de la
-		// pieza.
-		i = 0;
-		do {
-			// Buscamos la letra.
-			while ((i &lt; piezaQueMueve.getCasillasValidas().size())
-					&amp;&amp; (destinoLetra != piezaQueMueve.getCasillasValidas().get(
-							i).getLetra())) {
-				i++;
-				// Comprobamos si el numero de la letra encontrada coincide.
-			}
-			if (i &lt; piezaQueMueve.getCasillasValidas().size()) {
-				// Si se entra en el siguiente caso, es que el movimiento es
-				// valido
-				if (destinoNum == piezaQueMueve.getCasillasValidas().get(i)
-						.getLetra()) {
-					mov = new Movimiento();
-					mov.setCasillaOrigen(new Casilla(origenLetra, origenNum));
-					mov
-							.setCasillaDestino(new Casilla(destinoLetra,
-									destinoNum));
-					mov.setNumeroMovimiento(posicion.getNumeroMovimiento());
-					mov.setBando(posicion.getTurno());
-					mov.setTipoPieza(piezaQueMueve.getTipo());
-
-					// Si se come ponemos el contador a 0
-					if (!posicion.esVacia(destinoLetra, destinoNum)) {
-						posicion.setContadorTablas(0);
-						hash.borrarTabla();
-						mov.setCasillaComer(new Casilla(destinoLetra,
-								destinoNum));
-						mov.setTipoPiezaComida(posicion.getPieza(destinoLetra,
-								destinoNum).getTipo());
-						posicion.borrarPieza(mov.getCasillaComer());
-					}
-
-					// Se hacen los calculos especiales si se trata de un peon
-					if (piezaQueMueve.getTipo() == Tipo.PEON) {
-						// Se borra la pieza correspondiente si se come al paso
-						if (Math.abs(destinoLetra - origenLetra) == 1
-								&amp;&amp; posicion.esVacia(destinoLetra, destinoNum)) {
-							mov.setTipoPiezaComida(posicion.getPieza(
-									destinoLetra, origenNum).getTipo());
-							mov.setCasillaComer(new Casilla(destinoLetra,
-									origenNum));
-							posicion.borrarPieza(mov.getCasillaComer());
-						}
-						// Se establece la variable alPaso a su valor
-						// correspondiente
-						if (Math.abs(destinoNum - origenNum) == 2) {
-							posicion.setAlPaso(origenLetra);
-							mov.setAlPaso(posicion.getAlPaso());
-						} else {
-							posicion.setAlPaso('\0');
-						}
-						// Coronacion
-						if (destinoNum == '1' || destinoNum == '8') {
-							// if (mostrarDialogoCoronacion) {
-							// mostrarDialogoCoronacion ();
-							// }
-							piezaQueMueve = new Pieza(piezaQueMueve.getBando(),
-									coronar);
-
-							mov.setCoronacion(coronar);
-						}
-						posicion.setContadorTablas(0);
-						hash.borrarTabla();
-					}
-					// Se hacen los calculos especiales si se trata de un rey
-					if (piezaQueMueve.getTipo() == Tipo.REY) {
-						// Movemos las torres en caso de enroque
-						if ((destinoLetra - origenLetra) == 2) {
-							Pieza torre = posicion.getPieza('h', origenNum);
-							posicion.borrarPieza('h', origenNum);
-							posicion.setPieza(torre, 'f', origenNum);
-						} else {
-							if ((destinoLetra - origenLetra) == -2) {
-								Pieza torre = posicion.getPieza('a', origenNum);
-								posicion.borrarPieza('a', origenNum);
-								posicion.setPieza(torre, 'd', origenNum);
-							}
-						}
-					}
-
-					mov.setContadorTablas(posicion.getContadorTablas());
-					boolean[][] enroque = new boolean[2][2];
-					enroque[0][0] = posicion.getEnroqueCorto(Bando.BLANCO);
-					enroque[0][1] = posicion.getEnroqueLargo(Bando.BLANCO);
-					enroque[1][0] = posicion.getEnroqueCorto(Bando.NEGRO);
-					enroque[1][1] = posicion.getEnroqueLargo(Bando.NEGRO);
-					mov.setEnroque(enroque);
-					if (posicion.getTurno() == Bando.NEGRO)
-						posicion.addNumeroMovimiento();
-					posicion.setTurno();
-
-					posicion.borrarPieza(origenLetra, origenNum);
-					posicion.setPieza(piezaQueMueve, destinoLetra, destinoNum);
-					posicion.addContadorTablas();
-					calcularMovimientos();
-
-					if (esCasillaAtacada(posicion.getKingPosition(posicion
-							.getTurno()))) {
-						mov.setJaque(true);
-					} else {
-						mov.setJaque(false);
-					}
-					mov.setFinPartida(esFinPartida());
-
-					hash.insertar(posicion.getClavePosicion());
-					movimientos.appendMovimiento(mov);
-					indice++;
-					return mov;
-				} else {
-					i++;
-				}
-			} else {
-				return null;
-			}
-		} while (true);
-	}
-
-	/**
-	 * Avanza por la lista de movimientos de la partida.
-	 * 
-	 * @return El movimiento al que lleguemos en la lista de movimientos.
-	 */
-	public Movimiento avanzar() {
-		Movimiento mov;
-		Pieza piezaQueMueve;
-		if (indice &lt; movimientos.getNumHalfPly()) {
-			mov = movimientos.getMovimiento(indice);
-			piezaQueMueve = posicion.getPieza(mov.getCasillaOrigen());
-			// Si se come al paso
-			if (piezaQueMueve.getTipo() == Tipo.PEON
-					&amp;&amp; Math.abs(mov.getCasillaDestino().getLetra()
-							- mov.getCasillaOrigen().getLetra()) == 1
-					&amp;&amp; posicion.esVacia(mov.getCasillaDestino())) {
-				posicion.borrarPieza(mov.getCasillaComer());
-			}
-			// Si se corona
-			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Pieza(piezaQueMueve.getBando(), mov
-						.getCoronacion());
-			}
-			// Se hacen los calculos especiales si se trata de un rey
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
-				// Movemos las torres en caso de enroque
-				Casilla origen = mov.getCasillaOrigen();
-				Casilla destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Pieza torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
-				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
-						Pieza torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
-					}
-				}
-			}
-			posicion.borrarPieza(mov.getCasillaOrigen());
-			posicion.setPieza(piezaQueMueve, mov.getCasillaDestino());
-			posicion.setContadorTablas(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
-			indice++;
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
-			return mov;
-		} else {
-			return null;
-		}
-	}
-
-	/**
-	 * Retrocede por la lista de movimientos de la partida.
-	 * 
-	 * @return El movimiento al que lleguemos en la lista de movimientos.
-	 */
-	public Movimiento retroceder() {
-		Movimiento mov;
-		Pieza piezaQueMueve;
-		if (indice &gt; 0) {
-			indice--;
-			mov = movimientos.getMovimiento(indice);
-			posicion.setNumeroMovimiento(mov.getNumeroMovimiento());
-			piezaQueMueve = posicion.getPieza(mov.getCasillaDestino());
-			if (mov.getCoronacion() != null) {
-				piezaQueMueve = new Pieza(piezaQueMueve.getBando(), mov
-						.getCoronacion());
-			}
-			if (piezaQueMueve.getTipo() == Tipo.REY) {
-				// Movemos las torres en caso de enroque
-				Casilla origen = mov.getCasillaOrigen();
-				Casilla destino = mov.getCasillaDestino();
-				if ((destino.getLetra() - origen.getLetra()) == 2) {
-					Pieza torre = posicion.getPieza('h', origen.getNumero());
-					posicion.borrarPieza('h', origen.getNumero());
-					posicion.setPieza(torre, 'f', origen.getNumero());
-				} else {
-					if ((destino.getLetra() - origen.getLetra()) == -2) {
-						Pieza torre = posicion
-								.getPieza('a', origen.getNumero());
-						posicion.borrarPieza('a', origen.getNumero());
-						posicion.setPieza(torre, 'd', origen.getNumero());
-					}
-				}
-			}
-			posicion.borrarPieza(mov.getCasillaDestino());
-			if (mov.getTipoPiezaComida() != null) {
-				posicion.setPieza(new Pieza(
-						piezaQueMueve.getBando() == Bando.BLANCO ? Bando.BLANCO
-								: Bando.NEGRO, mov.getTipoPieza()), mov
-						.getCasillaComer());
-			}
-			posicion.setPieza(piezaQueMueve, mov.getCasillaOrigen());
-			posicion.setContadorTablas(mov.getContadorTablas());
-			boolean[][] enroques = mov.getEnroque();
-			posicion.setEnroqueCorto(Bando.BLANCO, enroques[0][0]);
-			posicion.setEnroqueLargo(Bando.BLANCO, enroques[0][1]);
-			posicion.setEnroqueCorto(Bando.NEGRO, enroques[1][0]);
-			posicion.setEnroqueLargo(Bando.NEGRO, enroques[1][1]);
-			posicion.setAlPaso(mov.getAlPaso());
-			posicion.setTurno();
-			return mov;
-		} else {
-			return null;
-		}
-	}
-
-	/**
-	 * Este metodo comprueba si se produce alguna situacion en la que termine
-	 * una partida.
-	 * 
-	 * @return Devuelve '\0' si la partida no se ha acabado, 'B' si las blancas
-	 *         han dado jaque mate, 'N' si las negras han dado jaque mate o 'T'
-	 *         si se produce una situacion de tablas.
-	 */
-	private Resultado esFinPartida() {
-		Pieza pieza;
-		Resultado devolver = null;
-		boolean fin = false, fin2 = false, posibleMatInsuf = false;
-		char i, j;
-		// Tablas por 50 movimientos
-		if (posicion.getContadorTablas() == 50) {
-			fin = true;
-			devolver = Resultado.TABLAS_50_MOV;
-		}
-		// Tablas por repeticion de posiciones
-		if (hash.getRepeticiones(posicion.getClavePosicion()) == 3) {
-			fin = true;
-			devolver = Resultado.TABLAS_REPETICION;
-		}
-		// Tablas por material insuficiente
-		i = 'a';
-		j = '1';
-		while (i &lt;= 'h' &amp;&amp; !fin2) {
-			while (j &lt;= '8' &amp;&amp; !fin2) {
-				pieza = posicion.getPieza(i, j);
-				if (pieza != null) {
-					if (posibleMatInsuf) {
-						if (pieza.getTipo() != Tipo.REY) {
-							fin2 = true;
-						}
-					} else {
-						switch (pieza.getTipo()) {
-						case PEON:
-						case DAMA:
-						case TORRE:
-							fin2 = true;
-							break;
-						case ALFIL:
-						case CABALLO:
-							posibleMatInsuf = true;
-							break;
-						case REY:
-							break;
-						}
-					}
-				}
-				j++;
-			}
-			j = '1';
-			i++;
-		}
-		if (!fin2) {
-			fin = true;
-			devolver = Resultado.TABLAS_INSUF_MATERIAL;
-		}
-		// Miramos si hay movimientos posibles
-		i = 'a';
-		j = '1';
-		while (i &lt;= 'h' &amp;&amp; !fin) {
-			while (j &lt;= '8' &amp;&amp; !fin) {
-				pieza = posicion.getPieza(i, j);
-				if ((pieza != null)
-						&amp;&amp; (!Pieza.esBandoContrario(posicion.getTurno(), pieza))
-						&amp;&amp; (!pieza.getCasillasValidas().isEmpty())) {
-					fin = true;
-				}
-				j++;
-			}
-			j = '1';
-			i++;
-		}
-		if (!fin) {
-			// Negras dan jaque mate
-			if (posicion.getTurno() == Bando.BLANCO)
-				if (esCasillaAtacada(posicion.getKingPosition(Bando.BLANCO))) {
-					devolver = Resultado.JAQUE_MATE_NEGRO;
-				} else {
-					devolver = Resultado.TABLAS_AHOGADO;
-				}
-			else
-			// Blancas dan jaque mate
-			if (esCasillaAtacada(posicion.getKingPosition(Bando.NEGRO))) {
-				devolver = Resultado.JAQUE_MATE_BLANCO;
-			}
-			// Tablas por ahogado
-			else {
-				devolver = Resultado.TABLAS_AHOGADO;
-			}
-		}
-		return devolver;
-	}
-
-	/**
-	 * Interpreta un movimiento en notacion algebraica y lo realiza en la
-	 * Logica. NOTA: Partimos de la base de que el turno corresponde con el
-	 * movimiento que se recibe: no se puede dar el caso de que se reciba un
-	 * movimiento de negras y que el turno pertenezca a blancas o viceversa.
-	 * 
-	 * @param mov
-	 *            String que contiene el movimiento en notacion algebraica.
-	 * @todo Poner las ambig&#252;edades de la dama
-	 * @todo Puede ser que tengamos un problema: cuando una pieza esta clavada
-	 *       con el rey, no hay que marcar la posible ambiguedad. Hay que
-	 *       tenerlo en cuenta.
-	 */
-	public Movimiento moverALG(String mov) {
-		char origenLetra = '\0', origenNum = '\0', destinoLetra = '\0', destinoNum = '\0';
-		char tipoPieza = 'P';
-		Tipo piezaCoronacion = null;
-		int contadorOesEnroque = 0, i;
-		boolean finDestino = false;
-
-		for (i = mov.length() - 1; i &gt;= 0; i--) {
-			switch (mov.charAt(i)) {
-			case '1':
-			case '2':
-			case '3':
-			case '4':
-			case '5':
-			case '6':
-			case '7':
-			case '8':
-				if (!finDestino) {
-					destinoNum = mov.charAt(i);
-				} else {
-					origenNum = mov.charAt(i);
-				}
-				break;
-			case 'a':
-			case 'b':
-			case 'c':
-			case 'd':
-			case 'e':
-			case 'f':
-			case 'g':
-			case 'h':
-				if (!finDestino) {
-					destinoLetra = mov.charAt(i);
-				} else {
-					origenLetra = mov.charAt(i);
-				}
-				finDestino = true;
-				break;
-			case 'B':
-				if (i != 0) {
-					piezaCoronacion = Tipo.ALFIL;
-				} else {
-					tipoPieza = 'A';
-				}
-				break;
-			case 'K':
-				tipoPieza = 'R';
-				break;
-			case 'N':
-				if (i != 0) {
-					piezaCoronacion = Tipo.CABALLO;
-				} else {
-					tipoPieza = 'C';
-				}
-				break;
-			case 'Q':
-				if (i != 0) {
-					piezaCoronacion = Tipo.DAMA;
-				} else {
-					tipoPieza = 'D';
-				}
-				break;
-			case 'R':
-				if (i != 0) {
-					piezaCoronacion = Tipo.TORRE;
-				} else {
-					tipoPieza = 'T';
-				}
-				break;
-			case '0':
-			case 'o':
-			case 'O':
-				contadorOesEnroque++;
-				break;
-			case 'x':
-			case '+':
-			case '!':
-			case '?':
-			case '-':
-			case '=':
-				break;
-			default:
-				System.out.print(&quot;Caracter desconocido: &quot; + mov.charAt(i));
-				break;
-			}
-		}
-		if(piezaCoronacion!=null) {
-			// TODO hacer el mostrarDialogoCoronacion;
-			coronar = piezaCoronacion;
-		}
-		// Enroque Corto
-		if (contadorOesEnroque == 2) {
-			origenLetra = 'e';
-			destinoLetra = 'g';
-			if (posicion.getTurno() == Bando.BLANCO) {
-				origenNum = '1';
-				destinoNum = '1';
-			} else { // turno == NEGRO
-				origenNum = '8';
-				destinoNum = '8';
-			}
-		} else if (contadorOesEnroque == 3) {
-			origenLetra = 'e';
-			destinoLetra = 'c';
-			if (posicion.getTurno() == Bando.BLANCO) {
-				origenNum = '1';
-				destinoNum = '1';
-			} else { // turno == NEGRO
-				origenNum = '8';
-				destinoNum = '8';
-			}
-		} else {
-			Casilla c = new Casilla(destinoLetra, destinoNum);
-			if (origenLetra == '\0' &amp;&amp; origenNum != '\0') {
-				for (char ii = 'a'; ii &lt;= 'h'; ii++) {
-					Pieza p = posicion.getPieza(ii, origenNum);
-					if (p.canMove(c)) {
-						origenLetra = ii;
-						break;
-					}
-				}
-			} else if (origenLetra != '\0' &amp;&amp; origenNum == '\0') {
-				for (char ii = '1'; ii &lt;= '8'; ii++) {
-					Pieza p = posicion.getPieza(origenLetra, ii);
-					if (p.canMove(c)) {
-						origenNum = ii;
-						break;
-					}
-				}
-			} else {
-				for (char ii = '1'; ii &lt;= '8'; ii++) {
-					for (char jj = 'a'; jj &lt;= 'h'; jj++) {
-						Pieza p = posicion.getPieza(jj, ii);
-						if (p.canMove(c)) {
-							origenNum = ii;
-							break;
-						}
-					}
-				}
-			}
-		}
-		if (origenLetra == '\0' || origenNum == '\0' || destinoLetra == '\0'
-				|| destinoNum == '\0') {
-			System.out.println(tipoPieza + &quot; &quot; + origenLetra + &quot; &quot; + origenNum
-					+ &quot; &quot; + destinoLetra + &quot; &quot; + destinoNum);
-			return null;
-		} else {
-			return mover(origenLetra, origenNum, destinoLetra, destinoNum);
-		}
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/chess/Movement.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Movimiento.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Movement.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,241 @@
+package com.mihail.chess;
+
+import static com.mihail.chess.Board.Bando;
+
+import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Piece.Tipo;
+
+/**
+ * Esta clase define un objeto Movimiento, que guarda informacion sobre el
+ * movimiento que se realiza y sobre el estado de la partida en ese momento (qu&#233;
+ * enroques son posibles, es jaque, etc).
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Movement {
+
+	/**
+	 * Este atributo indica la letra de la casilla origen.
+	 */
+	// public char origenLetra;
+	/**
+	 * Este atributo indica el numero de la casilla origen.
+	 */
+	// public char origenNum;
+	private Square casillaOrigen;
+
+	/**
+	 * Este atributo indica la letra de la casilla destino.
+	 */
+	// public char destinoLetra;
+	/**
+	 * Este atributo indica el numero de la casilla destino.
+	 */
+	// public char destinoNum;
+	private Square casillaDestino;
+
+	/**
+	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
+	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
+	 * 1 como numero de movimiento.
+	 */
+	private int numeroMovimiento;
+
+	/**
+	 * Bando que mueve.
+	 */
+	private Bando bando;
+
+	/**
+	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
+	 * 
+	 */
+	private Tipo tipoPieza;
+
+	/**
+	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerLetra;
+	/**
+	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	// public char casillaComerNum;
+	private Square casillaComer;
+
+	/**
+	 * Este atributo indica si el movimiento produce un jaque.
+	 */
+	private boolean jaque;
+
+	/**
+	 * Este atributo indica si el movimiento termina la partida y quien es el
+	 * ganador o bien tablas. &lt;BR&gt;
+	 * 'B' -&gt; Ganan blancas &lt;BR&gt;
+	 * 'N' -&gt; Ganan negras &lt;BR&gt;
+	 * 'T' -&gt; Tablas &lt;BR&gt;
+	 * 0 -&gt; No ha terminado la partida
+	 */
+	private Resultado finPartida;
+
+	/**
+	 * Este atributo indica si se ha producido una coronacion y a que pieza se
+	 * promociona. &lt;BR&gt;
+	 * 'C' -&gt; Caballo &lt;BR&gt;
+	 * 'A' -&gt; Alfil &lt;BR&gt;
+	 * 'T' -&gt; Torre &lt;BR&gt;
+	 * 'D' -&gt; Dama &lt;BR&gt;
+	 * 0 -&gt; No hay coronacion
+	 */
+	private Tipo coronacion;
+
+	/**
+	 * Este atributo indica el valor de contadorTablas en el momento que se
+	 * produce el movimiento.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos en el
+	 * momento en que se produce el movimiento. Es un array 2x2, en donde: &lt;BR&gt;
+	 * enroque[0][0] -&gt; Blancas, enroque corto &lt;BR&gt;
+	 * enroque[0][1] -&gt; Blancas, enroque largo &lt;BR&gt;
+	 * enroque[1][0] -&gt; Negras, enroque corto &lt;BR&gt;
+	 * enroque[1][1] -&gt; Negras, enroque largo &lt;BR&gt;
+	 */
+	private boolean[][] enroque;
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+
+	/**
+	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
+	 * producido una captura contiene un 0.
+	 */
+	private Tipo tipoPiezaComida;
+
+	/**
+	 * Este atributo guarda la representacion del movimiento en notacion
+	 * algebraica.
+	 */
+	private String notacion;
+
+	public Square getCasillaDestino() {
+		return casillaDestino;
+	}
+
+	public void setCasillaDestino(Square casillaDestino) {
+		this.casillaDestino = casillaDestino;
+	}
+
+	public Square getCasillaOrigen() {
+		return casillaOrigen;
+	}
+
+	public void setCasillaOrigen(Square casillaOrigen) {
+		this.casillaOrigen = casillaOrigen;
+	}
+
+	public Bando getBando() {
+		return bando;
+	}
+
+	public void setBando(Bando bando) {
+		this.bando = bando;
+	}
+
+	public int getNumeroMovimiento() {
+		return numeroMovimiento;
+	}
+
+	public void setNumeroMovimiento(int numeroMovimiento) {
+		this.numeroMovimiento = numeroMovimiento;
+	}
+
+	public Tipo getTipoPieza() {
+		return tipoPieza;
+	}
+
+	public void setTipoPieza(Tipo tipoPieza) {
+		this.tipoPieza = tipoPieza;
+	}
+
+	public Square getCasillaComer() {
+		return casillaComer;
+	}
+
+	public void setCasillaComer(Square casillaComer) {
+		this.casillaComer = casillaComer;
+	}
+
+	public int getContadorTablas() {
+		return contadorTablas;
+	}
+
+	public void setContadorTablas(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+
+	public Tipo getCoronacion() {
+		return coronacion;
+	}
+
+	public void setCoronacion(Tipo coronacion) {
+		this.coronacion = coronacion;
+	}
+
+	public boolean[][] getEnroque() {
+		return enroque;
+	}
+
+	public void setEnroque(boolean[][] enroque) {
+		this.enroque = enroque;
+	}
+
+	public Resultado getFinPartida() {
+		return finPartida;
+	}
+
+	public void setFinPartida(Resultado finPartida) {
+		this.finPartida = finPartida;
+	}
+
+	public boolean isJaque() {
+		return jaque;
+	}
+
+	public void setJaque(boolean jaque) {
+		this.jaque = jaque;
+	}
+
+	public char getAlPaso() {
+		return alPaso;
+	}
+
+	public void setAlPaso(char alPaso) {
+		this.alPaso = alPaso;
+	}
+
+	public String getNotacion() {
+		return notacion;
+	}
+
+	public void setNotacion(String notacion) {
+		this.notacion = notacion;
+	}
+
+	public Tipo getTipoPiezaComida() {
+		return tipoPiezaComida;
+	}
+
+	public void setTipoPiezaComida(Tipo tipoPiezaComida) {
+		this.tipoPiezaComida = tipoPiezaComida;
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Movimiento.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Movimiento.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,241 +0,0 @@
-package com.mihail.chess;
-
-import static com.mihail.chess.Logica.Bando;
-
-import com.mihail.chess.Logica.Resultado;
-import com.mihail.chess.Pieza.Tipo;
-
-/**
- * Esta clase define un objeto Movimiento, que guarda informacion sobre el
- * movimiento que se realiza y sobre el estado de la partida en ese momento (qu&#233;
- * enroques son posibles, es jaque, etc).
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Movimiento {
-
-	/**
-	 * Este atributo indica la letra de la casilla origen.
-	 */
-	// public char origenLetra;
-	/**
-	 * Este atributo indica el numero de la casilla origen.
-	 */
-	// public char origenNum;
-	private Casilla casillaOrigen;
-
-	/**
-	 * Este atributo indica la letra de la casilla destino.
-	 */
-	// public char destinoLetra;
-	/**
-	 * Este atributo indica el numero de la casilla destino.
-	 */
-	// public char destinoNum;
-	private Casilla casillaDestino;
-
-	/**
-	 * Numero de movimiento en la partida. Es el mismo numero para blancas que
-	 * para negras. Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el
-	 * 1 como numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Bando que mueve.
-	 */
-	private Bando bando;
-
-	/**
-	 * Este atributo indica el tipo de pieza que es: {P,C,A,T,D,R}
-	 * 
-	 */
-	private Tipo tipoPieza;
-
-	/**
-	 * Este atributo indica la letra de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerLetra;
-	/**
-	 * Este atributo indica el numero de la casilla donde se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	// public char casillaComerNum;
-	private Casilla casillaComer;
-
-	/**
-	 * Este atributo indica si el movimiento produce un jaque.
-	 */
-	private boolean jaque;
-
-	/**
-	 * Este atributo indica si el movimiento termina la partida y quien es el
-	 * ganador o bien tablas. &lt;BR&gt;
-	 * 'B' -&gt; Ganan blancas &lt;BR&gt;
-	 * 'N' -&gt; Ganan negras &lt;BR&gt;
-	 * 'T' -&gt; Tablas &lt;BR&gt;
-	 * 0 -&gt; No ha terminado la partida
-	 */
-	private Resultado finPartida;
-
-	/**
-	 * Este atributo indica si se ha producido una coronacion y a que pieza se
-	 * promociona. &lt;BR&gt;
-	 * 'C' -&gt; Caballo &lt;BR&gt;
-	 * 'A' -&gt; Alfil &lt;BR&gt;
-	 * 'T' -&gt; Torre &lt;BR&gt;
-	 * 'D' -&gt; Dama &lt;BR&gt;
-	 * 0 -&gt; No hay coronacion
-	 */
-	private Tipo coronacion;
-
-	/**
-	 * Este atributo indica el valor de contadorTablas en el momento que se
-	 * produce el movimiento.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos en el
-	 * momento en que se produce el movimiento. Es un array 2x2, en donde: &lt;BR&gt;
-	 * enroque[0][0] -&gt; Blancas, enroque corto &lt;BR&gt;
-	 * enroque[0][1] -&gt; Blancas, enroque largo &lt;BR&gt;
-	 * enroque[1][0] -&gt; Negras, enroque corto &lt;BR&gt;
-	 * enroque[1][1] -&gt; Negras, enroque largo &lt;BR&gt;
-	 */
-	private boolean[][] enroque;
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo indica el tipo de la pieza que se come. Si no se ha
-	 * producido una captura contiene un 0.
-	 */
-	private Tipo tipoPiezaComida;
-
-	/**
-	 * Este atributo guarda la representacion del movimiento en notacion
-	 * algebraica.
-	 */
-	private String notacion;
-
-	public Casilla getCasillaDestino() {
-		return casillaDestino;
-	}
-
-	public void setCasillaDestino(Casilla casillaDestino) {
-		this.casillaDestino = casillaDestino;
-	}
-
-	public Casilla getCasillaOrigen() {
-		return casillaOrigen;
-	}
-
-	public void setCasillaOrigen(Casilla casillaOrigen) {
-		this.casillaOrigen = casillaOrigen;
-	}
-
-	public Bando getBando() {
-		return bando;
-	}
-
-	public void setBando(Bando bando) {
-		this.bando = bando;
-	}
-
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public Tipo getTipoPieza() {
-		return tipoPieza;
-	}
-
-	public void setTipoPieza(Tipo tipoPieza) {
-		this.tipoPieza = tipoPieza;
-	}
-
-	public Casilla getCasillaComer() {
-		return casillaComer;
-	}
-
-	public void setCasillaComer(Casilla casillaComer) {
-		this.casillaComer = casillaComer;
-	}
-
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
-	public Tipo getCoronacion() {
-		return coronacion;
-	}
-
-	public void setCoronacion(Tipo coronacion) {
-		this.coronacion = coronacion;
-	}
-
-	public boolean[][] getEnroque() {
-		return enroque;
-	}
-
-	public void setEnroque(boolean[][] enroque) {
-		this.enroque = enroque;
-	}
-
-	public Resultado getFinPartida() {
-		return finPartida;
-	}
-
-	public void setFinPartida(Resultado finPartida) {
-		this.finPartida = finPartida;
-	}
-
-	public boolean isJaque() {
-		return jaque;
-	}
-
-	public void setJaque(boolean jaque) {
-		this.jaque = jaque;
-	}
-
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	public void setAlPaso(char alPaso) {
-		this.alPaso = alPaso;
-	}
-
-	public String getNotacion() {
-		return notacion;
-	}
-
-	public void setNotacion(String notacion) {
-		this.notacion = notacion;
-	}
-
-	public Tipo getTipoPiezaComida() {
-		return tipoPiezaComida;
-	}
-
-	public void setTipoPiezaComida(Tipo tipoPiezaComida) {
-		this.tipoPiezaComida = tipoPiezaComida;
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Piece.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Pieza.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Piece.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,223 @@
+package com.mihail.chess;
+
+import java.util.*;
+
+import static com.mihail.chess.Board.Bando;
+
+/**
+ * Esta clase define un objeto Pieza y sus caracteristicas: bando, tipo de pieza
+ * (peon, caballo, alfil, torre, dama, rey), posicion en la que se encuentra y
+ * casillas a donde podria mover, ademas de un indicador para saber si la pieza
+ * ha sido comida.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+
+public final class Piece {
+
+	public static enum Tipo {
+		PEON, CABALLO, ALFIL, TORRE, DAMA, REY
+	}
+
+	// Atributos
+
+	/**
+	 * Este atributo indica el bando de la pieza (blanco o negro): true -&gt; bando
+	 * blanco false -&gt; bando negro
+	 */
+	private Bando bando;
+
+	/**
+	 * Este atributo indica el tipo de pieza que es: &lt;BR&gt;
+	 * 'P' -&gt; peon &lt;BR&gt;
+	 * 'C' -&gt; caballo &lt;BR&gt;
+	 * 'A' -&gt; alfil &lt;BR&gt;
+	 * 'T' -&gt; torre &lt;BR&gt;
+	 * 'D' -&gt; dama &lt;BR&gt;
+	 * 'R' -&gt; rey
+	 */
+	private Tipo tipo;
+
+	private Square casilla;
+
+	/**
+	 * Este atributo es un array que almacena todas las casillas a las que puede
+	 * mover la pieza en una determinada situacion de partida, en donde: &lt;BR&gt;
+	 * casillasValidas[0] -&gt; letras de las casillas &lt;BR&gt;
+	 * casillasValidas[1] -&gt; numeros de las casillas &lt;BR&gt;
+	 * Son vectores de tama&#241;o fijo.
+	 * 
+	 * @see java.util.ArrayList
+	 */
+	private ArrayList&lt;Square&gt; casillasValidas;
+
+	private DirectionVector[] direcciones;
+
+	/**
+	 * Inicializa una nueva instancia de esta clase.
+	 * 
+	 * @param ban
+	 *            True para Blancas, false para Negras
+	 * @param claseDePieza
+	 *            Es el tipo de la pieza {P,C,A,T,D,R}
+	 * @see #tipo
+	 */
+	public Piece(Bando ban, Tipo claseDePieza) {
+		bando = ban;
+		tipo = claseDePieza;
+		casilla = new Square();
+		switch (tipo) {
+		case PEON:
+			direcciones = new DirectionVector[1];
+			if (bando == Bando.BLANCO)
+				direcciones[0] = new DirectionVector(0, 1);
+			else
+				direcciones[0] = new DirectionVector(0, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(4);
+			break;
+		case TORRE:
+			direcciones = new DirectionVector[4];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(13);
+			break;
+		case ALFIL:
+			direcciones = new DirectionVector[4];
+			direcciones[0] = new DirectionVector(1, 1);
+			direcciones[1] = new DirectionVector(-1, 1);
+			direcciones[2] = new DirectionVector(1, -1);
+			direcciones[3] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(13);
+			break;
+		case CABALLO:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 2);
+			direcciones[1] = new DirectionVector(-1, 2);
+			direcciones[2] = new DirectionVector(2, 1);
+			direcciones[3] = new DirectionVector(2, -1);
+
+			direcciones[4] = new DirectionVector(1, -2);
+			direcciones[5] = new DirectionVector(-1, -2);
+			direcciones[6] = new DirectionVector(-2, 1);
+			direcciones[7] = new DirectionVector(-2, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(8);
+			break;
+		case REY:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			direcciones[4] = new DirectionVector(1, 1);
+			direcciones[5] = new DirectionVector(-1, 1);
+			direcciones[6] = new DirectionVector(1, -1);
+			direcciones[7] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(8);
+			break;
+		case DAMA:
+			direcciones = new DirectionVector[8];
+			direcciones[0] = new DirectionVector(1, 0);
+			direcciones[1] = new DirectionVector(-1, 0);
+			direcciones[2] = new DirectionVector(0, 1);
+			direcciones[3] = new DirectionVector(0, -1);
+			direcciones[4] = new DirectionVector(1, 1);
+			direcciones[5] = new DirectionVector(-1, 1);
+			direcciones[6] = new DirectionVector(1, -1);
+			direcciones[7] = new DirectionVector(-1, -1);
+			casillasValidas = new ArrayList&lt;Square&gt;(27);
+			break;
+		}
+	}
+
+	/**
+	 * Permite saber si dos piezas son de bandos contrarios.
+	 * 
+	 * @param pieza1
+	 *            Pieza para saber si es de bando contrario a pieza2.
+	 * @param pieza2
+	 *            La otra pieza.
+	 * @return Devuelve true cuando pieza1 y pieza2 sean de bandos contrarios,
+	 *         false cuando sean del mismo bando.
+	 */
+	public final static boolean esBandoContrario(Piece pieza1, Piece pieza2) {
+		return pieza1.bando != pieza2.bando;
+	}
+
+	/**
+	 * Permite saber si una pieza pertenece al bando contrario al que tiene el
+	 * turno.
+	 * 
+	 * @param turno
+	 *            Indica de que bando es el turno.
+	 * @param pieza
+	 *            La pieza en cuestion.
+	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
+	 *         mover, false si es del mismo bando
+	 */
+	public final static boolean esBandoContrario(Bando turno, Piece pieza) {
+		return turno != pieza.bando;
+	}
+
+	/**
+	 * Inserta una casilla en la lista de casillas validas de un objeto Pieza.
+	 * 
+	 * @param let
+	 *            Es la casilla de destino que queremos a&#241;adir
+	 * @param n
+	 *            Es el numero de destino que queremos a&#241;adir
+	 */
+	public void anadirMov(char let, char n) {
+		this.casillasValidas.add(new Square(let, n));
+	}
+
+	public void anadirMov(Square c) {
+		this.casillasValidas.add(c);
+	}
+
+	public Bando getBando() {
+		return bando;
+	}
+
+	public ArrayList&lt;Square&gt; getCasillasValidas() {
+		return casillasValidas;
+	}
+
+	public DirectionVector[] getDirecciones() {
+		return direcciones;
+	}
+
+	public Tipo getTipo() {
+		return tipo;
+	}
+
+	public char getLetra() {
+		return casilla.getLetra();
+	}
+
+	public void setLetra(char let) {
+		casilla.setLetra(let);
+	}
+
+	public char getNum() {
+		return casilla.getNumero();
+	}
+
+	public void setNum(char num) {
+		casilla.setNumero(num);
+	}
+
+	public Square getCasilla() {
+		return casilla;
+	}
+
+	public void setCasilla(Square casilla) {
+		this.casilla = casilla;
+	}
+	
+	public boolean canMove(Square casilla) {
+		return casillasValidas.contains(casilla);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Pieza.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Pieza.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,223 +0,0 @@
-package com.mihail.chess;
-
-import java.util.*;
-
-import static com.mihail.chess.Logica.Bando;
-
-/**
- * Esta clase define un objeto Pieza y sus caracteristicas: bando, tipo de pieza
- * (peon, caballo, alfil, torre, dama, rey), posicion en la que se encuentra y
- * casillas a donde podria mover, ademas de un indicador para saber si la pieza
- * ha sido comida.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-
-public final class Pieza {
-
-	public static enum Tipo {
-		PEON, CABALLO, ALFIL, TORRE, DAMA, REY
-	}
-
-	// Atributos
-
-	/**
-	 * Este atributo indica el bando de la pieza (blanco o negro): true -&gt; bando
-	 * blanco false -&gt; bando negro
-	 */
-	private Bando bando;
-
-	/**
-	 * Este atributo indica el tipo de pieza que es: &lt;BR&gt;
-	 * 'P' -&gt; peon &lt;BR&gt;
-	 * 'C' -&gt; caballo &lt;BR&gt;
-	 * 'A' -&gt; alfil &lt;BR&gt;
-	 * 'T' -&gt; torre &lt;BR&gt;
-	 * 'D' -&gt; dama &lt;BR&gt;
-	 * 'R' -&gt; rey
-	 */
-	private Tipo tipo;
-
-	private Casilla casilla;
-
-	/**
-	 * Este atributo es un array que almacena todas las casillas a las que puede
-	 * mover la pieza en una determinada situacion de partida, en donde: &lt;BR&gt;
-	 * casillasValidas[0] -&gt; letras de las casillas &lt;BR&gt;
-	 * casillasValidas[1] -&gt; numeros de las casillas &lt;BR&gt;
-	 * Son vectores de tama&#241;o fijo.
-	 * 
-	 * @see java.util.ArrayList
-	 */
-	private ArrayList&lt;Casilla&gt; casillasValidas;
-
-	private VectorDireccion[] direcciones;
-
-	/**
-	 * Inicializa una nueva instancia de esta clase.
-	 * 
-	 * @param ban
-	 *            True para Blancas, false para Negras
-	 * @param claseDePieza
-	 *            Es el tipo de la pieza {P,C,A,T,D,R}
-	 * @see #tipo
-	 */
-	public Pieza(Bando ban, Tipo claseDePieza) {
-		bando = ban;
-		tipo = claseDePieza;
-		casilla = new Casilla();
-		switch (tipo) {
-		case PEON:
-			direcciones = new VectorDireccion[1];
-			if (bando == Bando.BLANCO)
-				direcciones[0] = new VectorDireccion(0, 1);
-			else
-				direcciones[0] = new VectorDireccion(0, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(4);
-			break;
-		case TORRE:
-			direcciones = new VectorDireccion[4];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(13);
-			break;
-		case ALFIL:
-			direcciones = new VectorDireccion[4];
-			direcciones[0] = new VectorDireccion(1, 1);
-			direcciones[1] = new VectorDireccion(-1, 1);
-			direcciones[2] = new VectorDireccion(1, -1);
-			direcciones[3] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(13);
-			break;
-		case CABALLO:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 2);
-			direcciones[1] = new VectorDireccion(-1, 2);
-			direcciones[2] = new VectorDireccion(2, 1);
-			direcciones[3] = new VectorDireccion(2, -1);
-
-			direcciones[4] = new VectorDireccion(1, -2);
-			direcciones[5] = new VectorDireccion(-1, -2);
-			direcciones[6] = new VectorDireccion(-2, 1);
-			direcciones[7] = new VectorDireccion(-2, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(8);
-			break;
-		case REY:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			direcciones[4] = new VectorDireccion(1, 1);
-			direcciones[5] = new VectorDireccion(-1, 1);
-			direcciones[6] = new VectorDireccion(1, -1);
-			direcciones[7] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(8);
-			break;
-		case DAMA:
-			direcciones = new VectorDireccion[8];
-			direcciones[0] = new VectorDireccion(1, 0);
-			direcciones[1] = new VectorDireccion(-1, 0);
-			direcciones[2] = new VectorDireccion(0, 1);
-			direcciones[3] = new VectorDireccion(0, -1);
-			direcciones[4] = new VectorDireccion(1, 1);
-			direcciones[5] = new VectorDireccion(-1, 1);
-			direcciones[6] = new VectorDireccion(1, -1);
-			direcciones[7] = new VectorDireccion(-1, -1);
-			casillasValidas = new ArrayList&lt;Casilla&gt;(27);
-			break;
-		}
-	}
-
-	/**
-	 * Permite saber si dos piezas son de bandos contrarios.
-	 * 
-	 * @param pieza1
-	 *            Pieza para saber si es de bando contrario a pieza2.
-	 * @param pieza2
-	 *            La otra pieza.
-	 * @return Devuelve true cuando pieza1 y pieza2 sean de bandos contrarios,
-	 *         false cuando sean del mismo bando.
-	 */
-	public final static boolean esBandoContrario(Pieza pieza1, Pieza pieza2) {
-		return pieza1.bando != pieza2.bando;
-	}
-
-	/**
-	 * Permite saber si una pieza pertenece al bando contrario al que tiene el
-	 * turno.
-	 * 
-	 * @param turno
-	 *            Indica de que bando es el turno.
-	 * @param pieza
-	 *            La pieza en cuestion.
-	 * @return Devuelve true cuando pieza sea del bando contrario al que le toca
-	 *         mover, false si es del mismo bando
-	 */
-	public final static boolean esBandoContrario(Bando turno, Pieza pieza) {
-		return turno != pieza.bando;
-	}
-
-	/**
-	 * Inserta una casilla en la lista de casillas validas de un objeto Pieza.
-	 * 
-	 * @param let
-	 *            Es la casilla de destino que queremos a&#241;adir
-	 * @param n
-	 *            Es el numero de destino que queremos a&#241;adir
-	 */
-	public void anadirMov(char let, char n) {
-		this.casillasValidas.add(new Casilla(let, n));
-	}
-
-	public void anadirMov(Casilla c) {
-		this.casillasValidas.add(c);
-	}
-
-	public Bando getBando() {
-		return bando;
-	}
-
-	public ArrayList&lt;Casilla&gt; getCasillasValidas() {
-		return casillasValidas;
-	}
-
-	public VectorDireccion[] getDirecciones() {
-		return direcciones;
-	}
-
-	public Tipo getTipo() {
-		return tipo;
-	}
-
-	public char getLetra() {
-		return casilla.getLetra();
-	}
-
-	public void setLetra(char let) {
-		casilla.setLetra(let);
-	}
-
-	public char getNum() {
-		return casilla.getNumero();
-	}
-
-	public void setNum(char num) {
-		casilla.setNumero(num);
-	}
-
-	public Casilla getCasilla() {
-		return casilla;
-	}
-
-	public void setCasilla(Casilla casilla) {
-		this.casilla = casilla;
-	}
-	
-	public boolean canMove(Casilla casilla) {
-		return casillasValidas.contains(casilla);
-	}
-}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/Posicion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,874 +0,0 @@
-package com.mihail.chess;
-
-import static com.mihail.chess.Logica.Bando;
-import static com.mihail.chess.Pieza.Tipo;
-
-import com.mihail.chess.Logica.Resultado;
-import com.mihail.chess.Pieza.Tipo;
-
-public class Posicion {
-
-	/**
-	 * Constante que representa al bando blanco.
-	 */
-	// public final static int BLANCO = 0;
-	/**
-	 * Constante que representa al bando negro.
-	 */
-	// public final static int NEGRO = 1;
-	/**
-	 * Constante que representa la cadena FEN con la posici&#243;n inicial en el
-	 * tablero.
-	 */
-	public final static String CAD_INICIAL = &quot;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1&quot;;
-
-	/**
-	 * Este atributo es la representacion del tablero en la logica del programa.
-	 * Es una matriz cuadrada de 64 casillas. El concepto de casilla no se
-	 * representa con un objeto: directamente se almacena un objeto Pieza o null
-	 * si la casilla esta vacia.
-	 */
-	private Pieza[][] tabla = new Pieza[8][8];
-
-	/**
-	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
-	 * blancas y NEGRO cuando mueven negras.
-	 */
-	private Bando turno;
-
-	/**
-	 * Este atributo indica el numero de movimiento por el que va la partida.
-	 * Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el 1 como
-	 * numero de movimiento.
-	 */
-	private int numeroMovimiento;
-
-	/**
-	 * Este atributo indica que enroques estan disponibles para que bandos. Es
-	 * un array 2x2, en donde: &lt;BR&gt;
-	 * enroque[0][0] -&gt; Blancas, enroque corto &lt;BR&gt;
-	 * enroque[0][1] -&gt; Blancas, enroque largo &lt;BR&gt;
-	 * enroque[1][0] -&gt; Negras, enroque corto &lt;BR&gt;
-	 * enroque[1][1] -&gt; Negras, enroque largo
-	 */
-	private boolean[][] enroque = new boolean[2][2];
-
-	/**
-	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
-	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
-	 * necesario para la captura al paso.
-	 */
-	private char alPaso;
-
-	/**
-	 * Este atributo sirve para contar movimientos a la hora de declarar las
-	 * tablas por la regla de los 50 movimientos.
-	 */
-	private int contadorTablas;
-
-	/**
-	 * Vamos almacenando la clave resultante para calcular la siguiente posicion
-	 * a partir de ella.
-	 */
-	private int clavePosicion;
-
-	/**
-	 * Tabla usada para guardar los indices para generar claves en la tabla
-	 * hash.
-	 */
-	private int[][][][] indices = new int[2][6][8][8];
-
-	/**
-	 * Este atributo contiene el numero de las casillas en las que se encuentran
-	 * los reyes. &lt;BR&gt;
-	 * letraPosRey[BLANCO] -&gt; Rey Blanco &lt;BR&gt;
-	 * letraPosRey[NEGRO] -&gt; Rey Negro &lt;BR&gt;
-	 */
-
-	private Casilla[] kingPosition = new Casilla[2];
-
-	public Posicion() {
-		for (int i = 0; i &lt; 2; i++) {
-			for (int j = 0; j &lt; 6; j++) {
-				for (int k = 0; k &lt; 8; k++) {
-					for (int l = 0; l &lt; 8; l++) {
-						indices[i][j][k][l] = i
-								* (new Double(Math.pow(10, 7))).intValue() + j
-								* (new Double(Math.pow(10, 6))).intValue() + k
-								* (new Double(Math.pow(10, 5))).intValue() + l
-								* (new Double(Math.pow(10, 4))).intValue() + i
-								* (new Double(Math.pow(10, 3))).intValue() + j
-								* (new Double(Math.pow(10, 2))).intValue() + k
-								* 10 + l;
-					}
-				}
-			}
-		}
-		turno = Bando.BLANCO;
-		kingPosition[0] = new Casilla();
-		kingPosition[1] = new Casilla();
-		enroque[0][0] = false;
-		enroque[0][1] = false;
-		enroque[1][0] = false;
-		enroque[1][1] = false;
-		alPaso = 0;
-		clavePosicion = 0;
-		contadorTablas = 0;
-		numeroMovimiento = 1;
-	}
-
-	public Posicion(String posicion) {
-		this();
-		setPosicion(posicion);
-	}
-
-	/**
-	 * Convierte el tipo de pieza expresado en castellano (P, C, A, etc.) al
-	 * ingles.
-	 * 
-	 * @param t
-	 *            Caracter que indica el tipo de pieza en castellano.
-	 * @return Tipo de pieza en ingles, es decir: &lt;BR&gt;
-	 *         P -&gt; P &lt;BR&gt;
-	 *         C -&gt; N &lt;BR&gt;
-	 *         A -&gt; B &lt;BR&gt;
-	 *         T -&gt; R &lt;BR&gt;
-	 *         D -&gt; Q &lt;BR&gt;
-	 *         R -&gt; K &lt;BR&gt;
-	 *         Otro caso -&gt; \0
-	 */
-	private final static char tipoToEnglish(Tipo t) {
-		switch (t) {
-		case ALFIL:
-			return 'B';
-		case CABALLO:
-			return 'N';
-		case DAMA:
-			return 'Q';
-		case PEON:
-			return 'P';
-		case REY:
-			return 'K';
-		case TORRE:
-			return 'R';
-		default:
-			return '\0';
-		}
-	}
-
-	/**
-	 * Convierte el booleano que indica el bando de una pieza a un entero.
-	 * 
-	 * @param c
-	 *            Es el booleano en cuestion.
-	 * @return 0 si el turno es blanco y 1 si el turno es negro
-	 */
-	private final static int bandoToInt(Bando c) {
-		if (c == Bando.BLANCO) {
-			return 0;
-		}
-		return 1;
-	}
-
-	/**
-	 * Convierte el tipo de pieza expresado con un caracter (P, C, A, etc.) a un
-	 * entero.
-	 * 
-	 * @param c
-	 *            Caracter que indica el tipo de pieza.
-	 * @return El entero que corresponde al tipo de pieza, es decir: &lt;BR&gt;
-	 *         P -&gt; 0 &lt;BR&gt;
-	 *         C -&gt; 1 &lt;BR&gt;
-	 *         A -&gt; 2 &lt;BR&gt;
-	 *         T -&gt; 3 &lt;BR&gt;
-	 *         D -&gt; 4 &lt;BR&gt;
-	 *         R -&gt; 5 &lt;BR&gt;
-	 *         Otro caso -&gt; -1
-	 */
-	private final static int tipoToInt(Tipo c) {
-		switch (c) {
-		case PEON:
-			return 0;
-		case CABALLO:
-			return 1;
-		case ALFIL:
-			return 2;
-		case TORRE:
-			return 3;
-		case DAMA:
-			return 4;
-		case REY:
-			return 5;
-		default:
-			return -1;
-		}
-	}
-
-	/**
-	 * Construye una cadena FEN a partir de la posicion que hay en el tablero.
-	 * 
-	 * @return Un string, la cadena FEN.
-	 */
-	public String getFEN() {
-		String cad = &quot;&quot;;
-		int cont = 0;
-		for (int i = 7; i &gt;= 0; i--) {
-			for (int j = 0; j &lt; 8; j++) {
-				Pieza p = getPieza((char) ('a' + j), (char) ('1' + i));
-				if (p == null)
-					cont++;
-				else {
-					if (cont &gt; 0)
-						cad += cont;
-					if (p.getBando() == Bando.BLANCO)
-						cad += tipoToEnglish(p.getTipo());
-					else
-						cad += (Character
-								.toLowerCase(tipoToEnglish(p.getTipo())));
-					cont = 0;
-				}
-			}
-			if (cont &gt; 0)
-				cad += cont;
-			if (i &gt; 0)
-				cad += '/';
-			cont = 0;
-		}
-
-		if (turno == Bando.BLANCO)
-			cad += &quot; w&quot;;
-		else
-			cad += &quot; b&quot;;
-
-		cad += &quot; &quot;;
-		if (!enroque[0][0] &amp;&amp; !enroque[0][1] &amp;&amp; !enroque[1][0]
-				&amp;&amp; !enroque[1][1])
-			cad += &quot;-&quot;;
-		else {
-			if (enroque[0][0])
-				cad += &quot;K&quot;;
-			if (enroque[0][1])
-				cad += &quot;Q&quot;;
-			if (enroque[1][0])
-				cad += &quot;k&quot;;
-			if (enroque[1][1])
-				cad += &quot;q&quot;;
-		}
-		if (alPaso != '\0')
-			cad += (&quot; &quot; + alPaso);
-		else
-			cad += (&quot; -&quot;);
-		cad += (&quot; &quot; + contadorTablas);
-		cad += (&quot; &quot; + numeroMovimiento);
-		return cad;
-	}
-
-	/**
-	 * Coloca las piezas en el tablero en la posicion que indica posInicial.
-	 * 
-	 * @param pos
-	 *            Es un String que indica una posicion de juego, siguiendo el
-	 *            estandar FEN.
-	 * @see getFEN()
-	 */
-	public void setPosicion(String pos) {
-		char let = 'a';
-		char num = '8';
-		for (int i = 0; i &lt; 8; i++) {
-			for (int j = 0; j &lt; 8; j++) {
-				tabla[i][j] = null;
-			}
-		}
-		/*
-		 * hash.borrarTabla (); movimientos.clear (); indice = 0;
-		 */
-		clavePosicion = 0;
-		String[] FEN = pos.split(&quot; &quot;);
-		for (int i = 0; i &lt; FEN[0].length(); i++) {
-			switch (FEN[0].charAt(i)) {
-			case 'P':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), let, num);
-				let++;
-				break;
-			case 'p':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.PEON), let, num);
-				let++;
-				break;
-			case 'N':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), let, num);
-				let++;
-				break;
-			case 'n':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.CABALLO), let, num);
-				let++;
-				break;
-			case 'B':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.ALFIL), let, num);
-				let++;
-				break;
-			case 'b':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.ALFIL), let, num);
-				let++;
-				break;
-			case 'R':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), let, num);
-				let++;
-				break;
-			case 'r':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), let, num);
-				let++;
-				break;
-			case 'Q':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.DAMA), let, num);
-				let++;
-				break;
-			case 'q':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.DAMA), let, num);
-				let++;
-				break;
-			case 'K':
-				setPieza(new Pieza(Bando.BLANCO, Tipo.REY), let, num);
-				let++;
-				break;
-			case 'k':
-				setPieza(new Pieza(Bando.NEGRO, Tipo.REY), let, num);
-				let++;
-				break;
-			case '/':
-				let = 'a';
-				num--;
-				break;
-			case '1':
-			case '2':
-			case '3':
-			case '4':
-			case '5':
-			case '6':
-			case '7':
-			case '8':
-				let += (char) (FEN[0].charAt(i) - '0');
-				break;
-			default:
-			}
-		}
-		if (FEN[1].charAt(0) == 'w') {
-			setTurno(Bando.BLANCO);
-		} else {
-			setTurno(Bando.NEGRO);
-		}
-		for (int i = 0; i &lt;= 1; i++) {
-			for (int j = 0; j &lt;= 1; j++) {
-				enroque[i][j] = false;
-			}
-		}
-		if (FEN[2].charAt(0) != '-') {
-			for (int i = 0; i &lt; FEN[2].length(); i++) {
-				switch (FEN[2].charAt(i)) {
-				case 'K':
-					setEnroqueCorto(Bando.BLANCO, true);
-					break;
-				case 'Q':
-					setEnroqueLargo(Bando.BLANCO, true);
-					break;
-				case 'k':
-					setEnroqueCorto(Bando.NEGRO, true);
-					break;
-				case 'q':
-					setEnroqueLargo(Bando.NEGRO, true);
-					break;
-				}
-			}
-
-		}
-		if (FEN[3].charAt(0) == '-') {
-			setAlPaso('\0');
-		} else {
-			setAlPaso(FEN[3].charAt(0));
-		}
-		setContadorTablas((new Integer(FEN[4])).intValue());
-		setNumeroMovimiento((new Integer(FEN[5])).intValue());
-	}
-
-	/**
-	 * Permite saber el numero de movimiento actual.
-	 * 
-	 * @return Un entero, el numero en cuestion.
-	 */
-
-	public int getNumMovimiento() {
-		return numeroMovimiento;
-	}
-
-	/**
-	 * Permite saber si el enroque corto esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque corto puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getEnroqueCorto(Bando c) {
-		switch (c) {
-		case BLANCO:
-			return enroque[0][0];
-		case NEGRO:
-			return enroque[1][0];
-		}
-		throw new AssertionError(&quot;El Bando solo puede ser BLANCO o NEGRO: &quot;
-				+ this);
-	}
-
-	/**
-	 * Permite saber si el enroque largo esta disponible para un bando.
-	 * 
-	 * @param c
-	 *            Bando del que se quiere obtener la informacion.
-	 * @return True si el enroque largo puede realizarse, false en caso
-	 *         contrario.
-	 */
-	public boolean getEnroqueLargo(Bando c) {
-		switch (c) {
-		case BLANCO:
-			return enroque[0][1];
-		case NEGRO:
-			return enroque[1][1];
-		}
-		throw new AssertionError(&quot;El Bando solo puede ser BLANCO o NEGRO: &quot;
-				+ this);
-	}
-
-	/**
-	 * Este metodo devuelve la pieza que se encuentra en una determinada
-	 * casilla. Si no hay ninguna pieza, devuelve null.
-	 * 
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 * @return Devuelve la pieza que se encuentra en la casilla (letra, num),
-	 *         null si la casilla esta vacia.
-	 */
-	public Pieza getPieza(char letra, char num) {
-		return tabla[num - '1'][letra - 'a'];
-	}
-	
-	public Pieza getPieza(Casilla c) {
-		return getPieza(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * Este metodo nos permite consultar el valor del turno.
-	 * 
-	 * @return Devuelve el valor del turno (0 -&gt; blancas, 1 -&gt; negras)
-	 */
-	public Bando getTurno() {
-		return turno;
-	}
-
-	/**
-	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
-	 * viceversa.
-	 */
-	public void setTurno() {
-		if (turno == Bando.BLANCO) {
-			turno = Bando.NEGRO;
-		} else {
-			turno = Bando.BLANCO;
-		}
-	}
-
-	/**
-	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
-	 * 
-	 * @param t
-	 *            BLANCO -&gt; blancas &lt;BR&gt;
-	 *            NEGRO -&gt; negras
-	 */
-	public void setTurno(Bando t) {
-		turno = t;
-	}
-
-	public boolean setEnroqueCorto(Bando b, boolean c) {
-		if (!c) {
-			int x;
-			switch (b) {
-			case BLANCO:
-				x = 0;
-				break;
-			case NEGRO:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						&quot;El Bando solo puede ser BLANCO o NEGRO: &quot; + this);
-			}
-			enroque[x][0] = c;
-			return true;
-		}
-		if (b == Bando.BLANCO) {
-			Pieza p = getPieza('h', '1');
-			if (p != null
-					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
-					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getNumero() == '1'
-					&amp;&amp; p.getBando() == Bando.BLANCO
-					&amp;&amp; p.getTipo() == Tipo.TORRE) {
-				enroque[0][0] = c;
-				return true;
-			} else
-				return false;
-		} else if (b == Bando.NEGRO) {
-			Pieza p = getPieza('h', '8');
-			if (p != null
-					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&amp;&amp; p.getBando() == Bando.NEGRO &amp;&amp; p.getTipo() == Tipo.TORRE) {
-				enroque[1][0] = c;
-				return true;
-			} else
-				return false;
-		}
-		return false;
-	}
-
-	public boolean setEnroqueLargo(Bando b, boolean c) {
-		if (!c) {
-			int x;
-			switch (b) {
-			case BLANCO:
-				x = 0;
-				break;
-			case NEGRO:
-				x = 1;
-				break;
-			default:
-				throw new AssertionError(
-						&quot;El Bando solo puede ser BLANCO o NEGRO: &quot; + this);
-			}
-			enroque[x][1] = c;
-			return true;
-		}
-		if (b == Bando.BLANCO) {
-			Pieza p = getPieza('a', '1');
-			if (p != null
-					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
-					&amp;&amp; kingPosition[0].getNumero() == '1'
-					&amp;&amp; p.getBando() == Bando.BLANCO
-					&amp;&amp; p.getTipo() == Tipo.TORRE) {
-				enroque[0][1] = c;
-				return true;
-			} else
-				return false;
-		} else if (b == Bando.NEGRO) {
-			Pieza p = getPieza('a', '8');
-			if (p != null
-					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
-					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
-					&amp;&amp; p.getBando() == Bando.NEGRO &amp;&amp; p.getTipo() == Tipo.TORRE) {
-				enroque[1][1] = c;
-				return true;
-			} else
-				return false;
-		}
-		return false;
-	}
-
-	/**
-	 * @return Devuelve numeroMovimiento.
-	 */
-	public int getNumeroMovimiento() {
-		return numeroMovimiento;
-	}
-
-	/**
-	 * Este metodo pone una pieza en el tablero en la casilla indicada. Ademas,
-	 * cambia los atributos del objeto pieza que se le pasa como argumento,
-	 * actualizando su situacion en el tablero.
-	 * 
-	 * @param pieza
-	 *            Es la pieza que queremos poner en el tablero
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 */
-	public void setPieza(Pieza pieza, char letra, char num) {
-		pieza.setLetra(letra);
-		pieza.setNum(num);
-		tabla[num - '1'][letra - 'a'] = pieza;
-		clavePosicion = clavePosicion
-				^ indices[bandoToInt(pieza.getBando())][tipoToInt(pieza
-						.getTipo())][num - '1'][letra - 'a'];
-
-		if (pieza.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(pieza.getBando())] = pieza.getCasilla();
-		}
-	}
-	
-	public void setPieza(Pieza pieza, Casilla casilla) {
-		setPieza(pieza, casilla.getLetra(), casilla.getNumero());
-	}
-
-	public void borrarPieza(Casilla casilla) {
-		borrarPieza(casilla.getLetra(), casilla.getNumero());
-	}
-
-	/**
-	 * Este metodo borra la pieza que se encuentra en una determinada casilla.
-	 * Si la casilla esta vacia, no produce error y la deja vacia. Ademas,
-	 * modifica el atributo enJuego de la pieza.
-	 * 
-	 * @param letra
-	 *            Es la letra de la casilla
-	 * @param num
-	 *            Es el numero de la casilla
-	 */
-	public void borrarPieza(char letra, char num) {
-		int iNum = num - '1', iLetra = letra - 'a';
-		Pieza p = tabla[iNum][iLetra];
-		// Se actualiza el estado de los enroques en caso de que se borre un rey
-		// o una torre
-		if (p != null) {
-			if (p.getTipo() == Tipo.REY) {
-				if (p.getBando() == Bando.BLANCO) {
-					enroque[0][0] = false;
-					enroque[0][1] = false;
-					kingPosition[bandoToInt(Bando.BLANCO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.BLANCO)].setNumero('\0');
-				} else {
-					enroque[1][0] = false;
-					enroque[1][1] = false;
-					kingPosition[bandoToInt(Bando.NEGRO)].setLetra('\0');
-					kingPosition[bandoToInt(Bando.NEGRO)].setNumero('\0');
-				}
-			} else if (p.getTipo() == Tipo.TORRE) {
-				if (p.getLetra() == 'a' &amp;&amp; p.getNum() == '1'
-						&amp;&amp; p.getBando() == Bando.BLANCO)
-					enroque[0][1] = false;
-				else if (p.getLetra() == 'h' &amp;&amp; p.getNum() == '1'
-						&amp;&amp; p.getBando() == Bando.BLANCO)
-					enroque[0][0] = false;
-				else if (p.getLetra() == 'a' &amp;&amp; p.getNum() == '8'
-						&amp;&amp; p.getBando() == Bando.NEGRO)
-					enroque[1][1] = false;
-				else if (p.getLetra() == 'h' &amp;&amp; p.getNum() == '8'
-						&amp;&amp; p.getBando() == Bando.NEGRO)
-					enroque[1][0] = false;
-			} else if (p.getTipo() == Tipo.PEON) {
-				if (letra == alPaso
-						&amp;&amp; (p.getBando() == Bando.BLANCO &amp;&amp; num == '4')
-						|| (p.getBando() == Bando.NEGRO &amp;&amp; num == '5'))
-					alPaso = 0;
-			}
-			clavePosicion = clavePosicion
-					^ indices[bandoToInt(p.getBando())][tipoToInt(p.getTipo())][iNum][iLetra];
-			tabla[num - '1'][letra - 'a'] = null;
-		}
-	}
-	
-	public boolean esVacia(Casilla c) {
-		return esVacia(c.getLetra(), c.getNumero());
-	}
-
-	/**
-	 * Consulta si una casilla esta vacia o no.
-	 * 
-	 * @return Devuelve true si la casilla esta vacia (contiene null), false en
-	 *         caso contrario.
-	 */
-	public boolean esVacia(char let, char num) {
-		return (getPieza(let, num) == null);
-	}
-
-	/**
-	 * Permite obtener la clave hash numerica de la posicion actual.
-	 * 
-	 * @return Un entero, la clave en cuestion.
-	 */
-	public int getClavePosicion() {
-		return clavePosicion;
-	}
-
-	/**
-	 * @return Returns the alPaso.
-	 */
-	public char getAlPaso() {
-		return alPaso;
-	}
-
-	/**
-	 * Establece la columna en la que un peon puede ser comido al paso. Es
-	 * decir, si un peon avanza dos casillas, entonces esa es la columna alPaso.
-	 * Es condicicion necesaria que en esa columna haya un peon que haya
-	 * avanzado dos casillas.
-	 * 
-	 * @param alPaso
-	 *            La columna en la qeu se puede comer al paso. Se indica con la
-	 *            letra de la columna.
-	 */
-	public void setAlPaso(char alPaso) {
-		if (alPaso == '\0') {
-			this.alPaso = alPaso;
-			return;
-		}
-		boolean encontrado = false;
-		Pieza p;
-		if (this.turno == Bando.NEGRO) {
-			p = getPieza(alPaso, '4');
-			encontrado = p != null &amp;&amp; p.getBando() == Bando.BLANCO
-					&amp;&amp; p.getTipo() == Tipo.PEON;
-		} else {
-			p = getPieza(alPaso, '5');
-			encontrado = p != null &amp;&amp; p.getBando() == Bando.NEGRO
-					&amp;&amp; p.getTipo() == Tipo.PEON;
-		}
-		if (encontrado)
-			this.alPaso = alPaso;
-	}
-
-	/**
-	 * @return Returns the contadorTablas.
-	 */
-	public int getContadorTablas() {
-		return contadorTablas;
-	}
-
-	/**
-	 * @param contadorTablas
-	 *            The contadorTablas to set.
-	 */
-	public void setContadorTablas(int contadorTablas) {
-		this.contadorTablas = contadorTablas;
-	}
-
-	public void addContadorTablas() {
-		this.contadorTablas++;
-	}
-
-	/**
-	 * @param numeroMovimiento
-	 *            The numeroMovimiento to set.
-	 */
-	public void setNumeroMovimiento(int numeroMovimiento) {
-		this.numeroMovimiento = numeroMovimiento;
-	}
-
-	public void addNumeroMovimiento() {
-		this.numeroMovimiento++;
-	}
-
-	/**
-	 * @return Returns the kingPosition.
-	 */
-	public Casilla getKingPosition(Bando color) {
-		return kingPosition[bandoToInt(color)];
-	}
-	
-	/**
-	 * Genera la notaci&#243;n algebraica de un movimiento.
-	 * 
-	 * @param mov
-	 *            Objeto movimiento del que se generara la notacion algebraica.
-	 * @return Una cadena con el movimiento expresado en notacion algebraica,
-	 *         (por ejemplo: Nf3, e6, Bd5...)
-	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
-	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
-	 */
-	private String generarNotacionALG (Movimiento mov) {
-		StringBuffer temp = new StringBuffer ();
-
-		if (mov.getTipoPieza() == Tipo.REY) {
-			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
-				if (mov.getCasillaDestino().getLetra() == 'g') {
-					temp.append (&quot;O-O&quot;);
-				}
-				else { // mov.destinoLetra == 'c'
-					temp.append (&quot;O-O-O&quot;);
-				}
-				return temp.toString ();
-			}
-		}
-		if (mov.getTipoPieza() != Tipo.PEON) {
-			temp.append (tipoToEnglish (mov.getTipoPieza()));
-		}
-		Pieza pieza = getPieza (mov.getCasillaDestino());
-		switch (mov.getTipoPieza()) {
-			case PEON:
-				if (mov.getCasillaComer() != null)
-					temp.append (mov.getCasillaOrigen().getLetra());
-				break;
-			case CABALLO:
-				for(VectorDireccion v: pieza.getDirecciones()) {
-					try {
-						Pieza p = getPieza(mov.getCasillaDestino().add(v));
-						if(p!=null &amp;&amp; p.getTipo() == Tipo.CABALLO &amp;&amp; p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
-								break;
-							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
-								break;
-							}
-						}
-					} catch(ArrayIndexOutOfBoundsException e) {}
-				}
-				break;
-
-			case ALFIL:
-			case TORRE:
-			case DAMA:
-				for(VectorDireccion v: pieza.getDirecciones()) {
-					try {
-						Casilla destino = mov.getCasillaDestino().add(v);
-						Pieza p;
-						while((p=getPieza(destino))==null) {
-							destino.add(v);
-						}
-						if(p!=null &amp;&amp; p.getTipo() == pieza.getTipo() &amp;&amp; p.getBando() == pieza.getBando()) {
-							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
-								temp.append(mov.getCasillaOrigen().getLetra());
-								break;
-							} else {
-								temp.append (mov.getCasillaOrigen().getNumero());
-								break;
-							}
-						}
-					} catch(ArrayIndexOutOfBoundsException e) {}
-				}
-				break;
-		}
-
-		if (mov.getCasillaComer() != null)
-			temp.append (&quot;x&quot;);
-
-		temp.append (mov.getCasillaDestino().toString());
-
-		if (mov.getCoronacion() != null)
-			temp.append (&quot;=&quot; + tipoToEnglish (mov.getCoronacion()));
-
-		if (mov.isJaque())
-			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
-					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
-				temp.append (&quot;#&quot;);
-			else
-				temp.append (&quot;+&quot;);
-		return temp.toString ();
-	}
-
-	/**
-	 * Funciones de uso interno. No usar directamente
-	 * 
-	 * @param letra
-	 * @param num
-	 */
-	void borrarPiezaInternal(char letra, char num) {
-		tabla[num - '1'][letra - 'a'] = null;
-	}
-
-	void setPiezaInternal(Pieza p, char letra, char num) {
-		tabla[num - '1'][letra - 'a'] = p;
-		if (p.getTipo() == Tipo.REY) {
-			kingPosition[bandoToInt(p.getBando())].setLetra(letra);
-			kingPosition[bandoToInt(p.getBando())].setNumero(num);
-		}
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/chess/Position.java (from rev 32, trunk/MihailChessLib/com/mihail/chess/Posicion.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Posicion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Position.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,874 @@
+package com.mihail.chess;
+
+import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Piece.Tipo;
+
+import com.mihail.chess.Board.Resultado;
+import com.mihail.chess.Piece.Tipo;
+
+public class Position {
+
+	/**
+	 * Constante que representa al bando blanco.
+	 */
+	// public final static int BLANCO = 0;
+	/**
+	 * Constante que representa al bando negro.
+	 */
+	// public final static int NEGRO = 1;
+	/**
+	 * Constante que representa la cadena FEN con la posici&#243;n inicial en el
+	 * tablero.
+	 */
+	public final static String CAD_INICIAL = &quot;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1&quot;;
+
+	/**
+	 * Este atributo es la representacion del tablero en la logica del programa.
+	 * Es una matriz cuadrada de 64 casillas. El concepto de casilla no se
+	 * representa con un objeto: directamente se almacena un objeto Pieza o null
+	 * si la casilla esta vacia.
+	 */
+	private Piece[][] tabla = new Piece[8][8];
+
+	/**
+	 * Este atributo indica a quien le toca mover. Vale BLANCO cuando mueven
+	 * blancas y NEGRO cuando mueven negras.
+	 */
+	private Bando turno;
+
+	/**
+	 * Este atributo indica el numero de movimiento por el que va la partida.
+	 * Por ejemplo: en '1. e4 c5', tanto e4 como c5 compartirian el 1 como
+	 * numero de movimiento.
+	 */
+	private int numeroMovimiento;
+
+	/**
+	 * Este atributo indica que enroques estan disponibles para que bandos. Es
+	 * un array 2x2, en donde: &lt;BR&gt;
+	 * enroque[0][0] -&gt; Blancas, enroque corto &lt;BR&gt;
+	 * enroque[0][1] -&gt; Blancas, enroque largo &lt;BR&gt;
+	 * enroque[1][0] -&gt; Negras, enroque corto &lt;BR&gt;
+	 * enroque[1][1] -&gt; Negras, enroque largo
+	 */
+	private boolean[][] enroque = new boolean[2][2];
+
+	/**
+	 * Este atributo contiene 0 en todos los casos salvo si se ha movido un peon
+	 * dos casillas. En ese caso contendra la letra de la columna del peon. Es
+	 * necesario para la captura al paso.
+	 */
+	private char alPaso;
+
+	/**
+	 * Este atributo sirve para contar movimientos a la hora de declarar las
+	 * tablas por la regla de los 50 movimientos.
+	 */
+	private int contadorTablas;
+
+	/**
+	 * Vamos almacenando la clave resultante para calcular la siguiente posicion
+	 * a partir de ella.
+	 */
+	private int clavePosicion;
+
+	/**
+	 * Tabla usada para guardar los indices para generar claves en la tabla
+	 * hash.
+	 */
+	private int[][][][] indices = new int[2][6][8][8];
+
+	/**
+	 * Este atributo contiene el numero de las casillas en las que se encuentran
+	 * los reyes. &lt;BR&gt;
+	 * letraPosRey[BLANCO] -&gt; Rey Blanco &lt;BR&gt;
+	 * letraPosRey[NEGRO] -&gt; Rey Negro &lt;BR&gt;
+	 */
+
+	private Square[] kingPosition = new Square[2];
+
+	public Position() {
+		for (int i = 0; i &lt; 2; i++) {
+			for (int j = 0; j &lt; 6; j++) {
+				for (int k = 0; k &lt; 8; k++) {
+					for (int l = 0; l &lt; 8; l++) {
+						indices[i][j][k][l] = i
+								* (new Double(Math.pow(10, 7))).intValue() + j
+								* (new Double(Math.pow(10, 6))).intValue() + k
+								* (new Double(Math.pow(10, 5))).intValue() + l
+								* (new Double(Math.pow(10, 4))).intValue() + i
+								* (new Double(Math.pow(10, 3))).intValue() + j
+								* (new Double(Math.pow(10, 2))).intValue() + k
+								* 10 + l;
+					}
+				}
+			}
+		}
+		turno = Bando.BLANCO;
+		kingPosition[0] = new Square();
+		kingPosition[1] = new Square();
+		enroque[0][0] = false;
+		enroque[0][1] = false;
+		enroque[1][0] = false;
+		enroque[1][1] = false;
+		alPaso = 0;
+		clavePosicion = 0;
+		contadorTablas = 0;
+		numeroMovimiento = 1;
+	}
+
+	public Position(String posicion) {
+		this();
+		setPosicion(posicion);
+	}
+
+	/**
+	 * Convierte el tipo de pieza expresado en castellano (P, C, A, etc.) al
+	 * ingles.
+	 * 
+	 * @param t
+	 *            Caracter que indica el tipo de pieza en castellano.
+	 * @return Tipo de pieza en ingles, es decir: &lt;BR&gt;
+	 *         P -&gt; P &lt;BR&gt;
+	 *         C -&gt; N &lt;BR&gt;
+	 *         A -&gt; B &lt;BR&gt;
+	 *         T -&gt; R &lt;BR&gt;
+	 *         D -&gt; Q &lt;BR&gt;
+	 *         R -&gt; K &lt;BR&gt;
+	 *         Otro caso -&gt; \0
+	 */
+	private final static char tipoToEnglish(Tipo t) {
+		switch (t) {
+		case ALFIL:
+			return 'B';
+		case CABALLO:
+			return 'N';
+		case DAMA:
+			return 'Q';
+		case PEON:
+			return 'P';
+		case REY:
+			return 'K';
+		case TORRE:
+			return 'R';
+		default:
+			return '\0';
+		}
+	}
+
+	/**
+	 * Convierte el booleano que indica el bando de una pieza a un entero.
+	 * 
+	 * @param c
+	 *            Es el booleano en cuestion.
+	 * @return 0 si el turno es blanco y 1 si el turno es negro
+	 */
+	private final static int bandoToInt(Bando c) {
+		if (c == Bando.BLANCO) {
+			return 0;
+		}
+		return 1;
+	}
+
+	/**
+	 * Convierte el tipo de pieza expresado con un caracter (P, C, A, etc.) a un
+	 * entero.
+	 * 
+	 * @param c
+	 *            Caracter que indica el tipo de pieza.
+	 * @return El entero que corresponde al tipo de pieza, es decir: &lt;BR&gt;
+	 *         P -&gt; 0 &lt;BR&gt;
+	 *         C -&gt; 1 &lt;BR&gt;
+	 *         A -&gt; 2 &lt;BR&gt;
+	 *         T -&gt; 3 &lt;BR&gt;
+	 *         D -&gt; 4 &lt;BR&gt;
+	 *         R -&gt; 5 &lt;BR&gt;
+	 *         Otro caso -&gt; -1
+	 */
+	private final static int tipoToInt(Tipo c) {
+		switch (c) {
+		case PEON:
+			return 0;
+		case CABALLO:
+			return 1;
+		case ALFIL:
+			return 2;
+		case TORRE:
+			return 3;
+		case DAMA:
+			return 4;
+		case REY:
+			return 5;
+		default:
+			return -1;
+		}
+	}
+
+	/**
+	 * Construye una cadena FEN a partir de la posicion que hay en el tablero.
+	 * 
+	 * @return Un string, la cadena FEN.
+	 */
+	public String getFEN() {
+		String cad = &quot;&quot;;
+		int cont = 0;
+		for (int i = 7; i &gt;= 0; i--) {
+			for (int j = 0; j &lt; 8; j++) {
+				Piece p = getPieza((char) ('a' + j), (char) ('1' + i));
+				if (p == null)
+					cont++;
+				else {
+					if (cont &gt; 0)
+						cad += cont;
+					if (p.getBando() == Bando.BLANCO)
+						cad += tipoToEnglish(p.getTipo());
+					else
+						cad += (Character
+								.toLowerCase(tipoToEnglish(p.getTipo())));
+					cont = 0;
+				}
+			}
+			if (cont &gt; 0)
+				cad += cont;
+			if (i &gt; 0)
+				cad += '/';
+			cont = 0;
+		}
+
+		if (turno == Bando.BLANCO)
+			cad += &quot; w&quot;;
+		else
+			cad += &quot; b&quot;;
+
+		cad += &quot; &quot;;
+		if (!enroque[0][0] &amp;&amp; !enroque[0][1] &amp;&amp; !enroque[1][0]
+				&amp;&amp; !enroque[1][1])
+			cad += &quot;-&quot;;
+		else {
+			if (enroque[0][0])
+				cad += &quot;K&quot;;
+			if (enroque[0][1])
+				cad += &quot;Q&quot;;
+			if (enroque[1][0])
+				cad += &quot;k&quot;;
+			if (enroque[1][1])
+				cad += &quot;q&quot;;
+		}
+		if (alPaso != '\0')
+			cad += (&quot; &quot; + alPaso);
+		else
+			cad += (&quot; -&quot;);
+		cad += (&quot; &quot; + contadorTablas);
+		cad += (&quot; &quot; + numeroMovimiento);
+		return cad;
+	}
+
+	/**
+	 * Coloca las piezas en el tablero en la posicion que indica posInicial.
+	 * 
+	 * @param pos
+	 *            Es un String que indica una posicion de juego, siguiendo el
+	 *            estandar FEN.
+	 * @see getFEN()
+	 */
+	public void setPosicion(String pos) {
+		char let = 'a';
+		char num = '8';
+		for (int i = 0; i &lt; 8; i++) {
+			for (int j = 0; j &lt; 8; j++) {
+				tabla[i][j] = null;
+			}
+		}
+		/*
+		 * hash.borrarTabla (); movimientos.clear (); indice = 0;
+		 */
+		clavePosicion = 0;
+		String[] FEN = pos.split(&quot; &quot;);
+		for (int i = 0; i &lt; FEN[0].length(); i++) {
+			switch (FEN[0].charAt(i)) {
+			case 'P':
+				setPieza(new Piece(Bando.BLANCO, Tipo.PEON), let, num);
+				let++;
+				break;
+			case 'p':
+				setPieza(new Piece(Bando.NEGRO, Tipo.PEON), let, num);
+				let++;
+				break;
+			case 'N':
+				setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), let, num);
+				let++;
+				break;
+			case 'n':
+				setPieza(new Piece(Bando.NEGRO, Tipo.CABALLO), let, num);
+				let++;
+				break;
+			case 'B':
+				setPieza(new Piece(Bando.BLANCO, Tipo.ALFIL), let, num);
+				let++;
+				break;
+			case 'b':
+				setPieza(new Piece(Bando.NEGRO, Tipo.ALFIL), let, num);
+				let++;
+				break;
+			case 'R':
+				setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), let, num);
+				let++;
+				break;
+			case 'r':
+				setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), let, num);
+				let++;
+				break;
+			case 'Q':
+				setPieza(new Piece(Bando.BLANCO, Tipo.DAMA), let, num);
+				let++;
+				break;
+			case 'q':
+				setPieza(new Piece(Bando.NEGRO, Tipo.DAMA), let, num);
+				let++;
+				break;
+			case 'K':
+				setPieza(new Piece(Bando.BLANCO, Tipo.REY), let, num);
+				let++;
+				break;
+			case 'k':
+				setPieza(new Piece(Bando.NEGRO, Tipo.REY), let, num);
+				let++;
+				break;
+			case '/':
+				let = 'a';
+				num--;
+				break;
+			case '1':
+			case '2':
+			case '3':
+			case '4':
+			case '5':
+			case '6':
+			case '7':
+			case '8':
+				let += (char) (FEN[0].charAt(i) - '0');
+				break;
+			default:
+			}
+		}
+		if (FEN[1].charAt(0) == 'w') {
+			setTurno(Bando.BLANCO);
+		} else {
+			setTurno(Bando.NEGRO);
+		}
+		for (int i = 0; i &lt;= 1; i++) {
+			for (int j = 0; j &lt;= 1; j++) {
+				enroque[i][j] = false;
+			}
+		}
+		if (FEN[2].charAt(0) != '-') {
+			for (int i = 0; i &lt; FEN[2].length(); i++) {
+				switch (FEN[2].charAt(i)) {
+				case 'K':
+					setEnroqueCorto(Bando.BLANCO, true);
+					break;
+				case 'Q':
+					setEnroqueLargo(Bando.BLANCO, true);
+					break;
+				case 'k':
+					setEnroqueCorto(Bando.NEGRO, true);
+					break;
+				case 'q':
+					setEnroqueLargo(Bando.NEGRO, true);
+					break;
+				}
+			}
+
+		}
+		if (FEN[3].charAt(0) == '-') {
+			setAlPaso('\0');
+		} else {
+			setAlPaso(FEN[3].charAt(0));
+		}
+		setContadorTablas((new Integer(FEN[4])).intValue());
+		setNumeroMovimiento((new Integer(FEN[5])).intValue());
+	}
+
+	/**
+	 * Permite saber el numero de movimiento actual.
+	 * 
+	 * @return Un entero, el numero en cuestion.
+	 */
+
+	public int getNumMovimiento() {
+		return numeroMovimiento;
+	}
+
+	/**
+	 * Permite saber si el enroque corto esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque corto puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getEnroqueCorto(Bando c) {
+		switch (c) {
+		case BLANCO:
+			return enroque[0][0];
+		case NEGRO:
+			return enroque[1][0];
+		}
+		throw new AssertionError(&quot;El Bando solo puede ser BLANCO o NEGRO: &quot;
+				+ this);
+	}
+
+	/**
+	 * Permite saber si el enroque largo esta disponible para un bando.
+	 * 
+	 * @param c
+	 *            Bando del que se quiere obtener la informacion.
+	 * @return True si el enroque largo puede realizarse, false en caso
+	 *         contrario.
+	 */
+	public boolean getEnroqueLargo(Bando c) {
+		switch (c) {
+		case BLANCO:
+			return enroque[0][1];
+		case NEGRO:
+			return enroque[1][1];
+		}
+		throw new AssertionError(&quot;El Bando solo puede ser BLANCO o NEGRO: &quot;
+				+ this);
+	}
+
+	/**
+	 * Este metodo devuelve la pieza que se encuentra en una determinada
+	 * casilla. Si no hay ninguna pieza, devuelve null.
+	 * 
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 * @return Devuelve la pieza que se encuentra en la casilla (letra, num),
+	 *         null si la casilla esta vacia.
+	 */
+	public Piece getPieza(char letra, char num) {
+		return tabla[num - '1'][letra - 'a'];
+	}
+	
+	public Piece getPieza(Square c) {
+		return getPieza(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * Este metodo nos permite consultar el valor del turno.
+	 * 
+	 * @return Devuelve el valor del turno (0 -&gt; blancas, 1 -&gt; negras)
+	 */
+	public Bando getTurno() {
+		return turno;
+	}
+
+	/**
+	 * Este metodo alterna el turno. Si le tocaba a blancas le toca a negras y
+	 * viceversa.
+	 */
+	public void setTurno() {
+		if (turno == Bando.BLANCO) {
+			turno = Bando.NEGRO;
+		} else {
+			turno = Bando.BLANCO;
+		}
+	}
+
+	/**
+	 * Este metodo permite dar el turno a cualquiera de los dos bandos.
+	 * 
+	 * @param t
+	 *            BLANCO -&gt; blancas &lt;BR&gt;
+	 *            NEGRO -&gt; negras
+	 */
+	public void setTurno(Bando t) {
+		turno = t;
+	}
+
+	public boolean setEnroqueCorto(Bando b, boolean c) {
+		if (!c) {
+			int x;
+			switch (b) {
+			case BLANCO:
+				x = 0;
+				break;
+			case NEGRO:
+				x = 1;
+				break;
+			default:
+				throw new AssertionError(
+						&quot;El Bando solo puede ser BLANCO o NEGRO: &quot; + this);
+			}
+			enroque[x][0] = c;
+			return true;
+		}
+		if (b == Bando.BLANCO) {
+			Piece p = getPieza('h', '1');
+			if (p != null
+					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
+					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getNumero() == '1'
+					&amp;&amp; p.getBando() == Bando.BLANCO
+					&amp;&amp; p.getTipo() == Tipo.TORRE) {
+				enroque[0][0] = c;
+				return true;
+			} else
+				return false;
+		} else if (b == Bando.NEGRO) {
+			Piece p = getPieza('h', '8');
+			if (p != null
+					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
+					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
+					&amp;&amp; p.getBando() == Bando.NEGRO &amp;&amp; p.getTipo() == Tipo.TORRE) {
+				enroque[1][0] = c;
+				return true;
+			} else
+				return false;
+		}
+		return false;
+	}
+
+	public boolean setEnroqueLargo(Bando b, boolean c) {
+		if (!c) {
+			int x;
+			switch (b) {
+			case BLANCO:
+				x = 0;
+				break;
+			case NEGRO:
+				x = 1;
+				break;
+			default:
+				throw new AssertionError(
+						&quot;El Bando solo puede ser BLANCO o NEGRO: &quot; + this);
+			}
+			enroque[x][1] = c;
+			return true;
+		}
+		if (b == Bando.BLANCO) {
+			Piece p = getPieza('a', '1');
+			if (p != null
+					&amp;&amp; kingPosition[bandoToInt(Bando.BLANCO)].getLetra() == 'e'
+					&amp;&amp; kingPosition[0].getNumero() == '1'
+					&amp;&amp; p.getBando() == Bando.BLANCO
+					&amp;&amp; p.getTipo() == Tipo.TORRE) {
+				enroque[0][1] = c;
+				return true;
+			} else
+				return false;
+		} else if (b == Bando.NEGRO) {
+			Piece p = getPieza('a', '8');
+			if (p != null
+					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getLetra() == 'e'
+					&amp;&amp; kingPosition[bandoToInt(Bando.NEGRO)].getNumero() == '8'
+					&amp;&amp; p.getBando() == Bando.NEGRO &amp;&amp; p.getTipo() == Tipo.TORRE) {
+				enroque[1][1] = c;
+				return true;
+			} else
+				return false;
+		}
+		return false;
+	}
+
+	/**
+	 * @return Devuelve numeroMovimiento.
+	 */
+	public int getNumeroMovimiento() {
+		return numeroMovimiento;
+	}
+
+	/**
+	 * Este metodo pone una pieza en el tablero en la casilla indicada. Ademas,
+	 * cambia los atributos del objeto pieza que se le pasa como argumento,
+	 * actualizando su situacion en el tablero.
+	 * 
+	 * @param pieza
+	 *            Es la pieza que queremos poner en el tablero
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 */
+	public void setPieza(Piece pieza, char letra, char num) {
+		pieza.setLetra(letra);
+		pieza.setNum(num);
+		tabla[num - '1'][letra - 'a'] = pieza;
+		clavePosicion = clavePosicion
+				^ indices[bandoToInt(pieza.getBando())][tipoToInt(pieza
+						.getTipo())][num - '1'][letra - 'a'];
+
+		if (pieza.getTipo() == Tipo.REY) {
+			kingPosition[bandoToInt(pieza.getBando())] = pieza.getCasilla();
+		}
+	}
+	
+	public void setPieza(Piece pieza, Square casilla) {
+		setPieza(pieza, casilla.getLetra(), casilla.getNumero());
+	}
+
+	public void borrarPieza(Square casilla) {
+		borrarPieza(casilla.getLetra(), casilla.getNumero());
+	}
+
+	/**
+	 * Este metodo borra la pieza que se encuentra en una determinada casilla.
+	 * Si la casilla esta vacia, no produce error y la deja vacia. Ademas,
+	 * modifica el atributo enJuego de la pieza.
+	 * 
+	 * @param letra
+	 *            Es la letra de la casilla
+	 * @param num
+	 *            Es el numero de la casilla
+	 */
+	public void borrarPieza(char letra, char num) {
+		int iNum = num - '1', iLetra = letra - 'a';
+		Piece p = tabla[iNum][iLetra];
+		// Se actualiza el estado de los enroques en caso de que se borre un rey
+		// o una torre
+		if (p != null) {
+			if (p.getTipo() == Tipo.REY) {
+				if (p.getBando() == Bando.BLANCO) {
+					enroque[0][0] = false;
+					enroque[0][1] = false;
+					kingPosition[bandoToInt(Bando.BLANCO)].setLetra('\0');
+					kingPosition[bandoToInt(Bando.BLANCO)].setNumero('\0');
+				} else {
+					enroque[1][0] = false;
+					enroque[1][1] = false;
+					kingPosition[bandoToInt(Bando.NEGRO)].setLetra('\0');
+					kingPosition[bandoToInt(Bando.NEGRO)].setNumero('\0');
+				}
+			} else if (p.getTipo() == Tipo.TORRE) {
+				if (p.getLetra() == 'a' &amp;&amp; p.getNum() == '1'
+						&amp;&amp; p.getBando() == Bando.BLANCO)
+					enroque[0][1] = false;
+				else if (p.getLetra() == 'h' &amp;&amp; p.getNum() == '1'
+						&amp;&amp; p.getBando() == Bando.BLANCO)
+					enroque[0][0] = false;
+				else if (p.getLetra() == 'a' &amp;&amp; p.getNum() == '8'
+						&amp;&amp; p.getBando() == Bando.NEGRO)
+					enroque[1][1] = false;
+				else if (p.getLetra() == 'h' &amp;&amp; p.getNum() == '8'
+						&amp;&amp; p.getBando() == Bando.NEGRO)
+					enroque[1][0] = false;
+			} else if (p.getTipo() == Tipo.PEON) {
+				if (letra == alPaso
+						&amp;&amp; (p.getBando() == Bando.BLANCO &amp;&amp; num == '4')
+						|| (p.getBando() == Bando.NEGRO &amp;&amp; num == '5'))
+					alPaso = 0;
+			}
+			clavePosicion = clavePosicion
+					^ indices[bandoToInt(p.getBando())][tipoToInt(p.getTipo())][iNum][iLetra];
+			tabla[num - '1'][letra - 'a'] = null;
+		}
+	}
+	
+	public boolean esVacia(Square c) {
+		return esVacia(c.getLetra(), c.getNumero());
+	}
+
+	/**
+	 * Consulta si una casilla esta vacia o no.
+	 * 
+	 * @return Devuelve true si la casilla esta vacia (contiene null), false en
+	 *         caso contrario.
+	 */
+	public boolean esVacia(char let, char num) {
+		return (getPieza(let, num) == null);
+	}
+
+	/**
+	 * Permite obtener la clave hash numerica de la posicion actual.
+	 * 
+	 * @return Un entero, la clave en cuestion.
+	 */
+	public int getClavePosicion() {
+		return clavePosicion;
+	}
+
+	/**
+	 * @return Returns the alPaso.
+	 */
+	public char getAlPaso() {
+		return alPaso;
+	}
+
+	/**
+	 * Establece la columna en la que un peon puede ser comido al paso. Es
+	 * decir, si un peon avanza dos casillas, entonces esa es la columna alPaso.
+	 * Es condicicion necesaria que en esa columna haya un peon que haya
+	 * avanzado dos casillas.
+	 * 
+	 * @param alPaso
+	 *            La columna en la qeu se puede comer al paso. Se indica con la
+	 *            letra de la columna.
+	 */
+	public void setAlPaso(char alPaso) {
+		if (alPaso == '\0') {
+			this.alPaso = alPaso;
+			return;
+		}
+		boolean encontrado = false;
+		Piece p;
+		if (this.turno == Bando.NEGRO) {
+			p = getPieza(alPaso, '4');
+			encontrado = p != null &amp;&amp; p.getBando() == Bando.BLANCO
+					&amp;&amp; p.getTipo() == Tipo.PEON;
+		} else {
+			p = getPieza(alPaso, '5');
+			encontrado = p != null &amp;&amp; p.getBando() == Bando.NEGRO
+					&amp;&amp; p.getTipo() == Tipo.PEON;
+		}
+		if (encontrado)
+			this.alPaso = alPaso;
+	}
+
+	/**
+	 * @return Returns the contadorTablas.
+	 */
+	public int getContadorTablas() {
+		return contadorTablas;
+	}
+
+	/**
+	 * @param contadorTablas
+	 *            The contadorTablas to set.
+	 */
+	public void setContadorTablas(int contadorTablas) {
+		this.contadorTablas = contadorTablas;
+	}
+
+	public void addContadorTablas() {
+		this.contadorTablas++;
+	}
+
+	/**
+	 * @param numeroMovimiento
+	 *            The numeroMovimiento to set.
+	 */
+	public void setNumeroMovimiento(int numeroMovimiento) {
+		this.numeroMovimiento = numeroMovimiento;
+	}
+
+	public void addNumeroMovimiento() {
+		this.numeroMovimiento++;
+	}
+
+	/**
+	 * @return Returns the kingPosition.
+	 */
+	public Square getKingPosition(Bando color) {
+		return kingPosition[bandoToInt(color)];
+	}
+	
+	/**
+	 * Genera la notaci&#243;n algebraica de un movimiento.
+	 * 
+	 * @param mov
+	 *            Objeto movimiento del que se generara la notacion algebraica.
+	 * @return Una cadena con el movimiento expresado en notacion algebraica,
+	 *         (por ejemplo: Nf3, e6, Bd5...)
+	 * @todo Resolver ambiguedades, coronaciones, jaques, mates...
+	 * @todo Esto no esta bien aqui, es mejor dejarlo en Logica....
+	 */
+	private String generarNotacionALG (Movement mov) {
+		StringBuffer temp = new StringBuffer ();
+
+		if (mov.getTipoPieza() == Tipo.REY) {
+			if (Math.abs (mov.getCasillaOrigen().getLetra() - mov.getCasillaDestino().getLetra() ) == 2) {
+				if (mov.getCasillaDestino().getLetra() == 'g') {
+					temp.append (&quot;O-O&quot;);
+				}
+				else { // mov.destinoLetra == 'c'
+					temp.append (&quot;O-O-O&quot;);
+				}
+				return temp.toString ();
+			}
+		}
+		if (mov.getTipoPieza() != Tipo.PEON) {
+			temp.append (tipoToEnglish (mov.getTipoPieza()));
+		}
+		Piece pieza = getPieza (mov.getCasillaDestino());
+		switch (mov.getTipoPieza()) {
+			case PEON:
+				if (mov.getCasillaComer() != null)
+					temp.append (mov.getCasillaOrigen().getLetra());
+				break;
+			case CABALLO:
+				for(DirectionVector v: pieza.getDirecciones()) {
+					try {
+						Piece p = getPieza(mov.getCasillaDestino().add(v));
+						if(p!=null &amp;&amp; p.getTipo() == Tipo.CABALLO &amp;&amp; p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+
+			case ALFIL:
+			case TORRE:
+			case DAMA:
+				for(DirectionVector v: pieza.getDirecciones()) {
+					try {
+						Square destino = mov.getCasillaDestino().add(v);
+						Piece p;
+						while((p=getPieza(destino))==null) {
+							destino.add(v);
+						}
+						if(p!=null &amp;&amp; p.getTipo() == pieza.getTipo() &amp;&amp; p.getBando() == pieza.getBando()) {
+							if(mov.getCasillaOrigen().getLetra() != p.getCasilla().getLetra()) {
+								temp.append(mov.getCasillaOrigen().getLetra());
+								break;
+							} else {
+								temp.append (mov.getCasillaOrigen().getNumero());
+								break;
+							}
+						}
+					} catch(ArrayIndexOutOfBoundsException e) {}
+				}
+				break;
+		}
+
+		if (mov.getCasillaComer() != null)
+			temp.append (&quot;x&quot;);
+
+		temp.append (mov.getCasillaDestino().toString());
+
+		if (mov.getCoronacion() != null)
+			temp.append (&quot;=&quot; + tipoToEnglish (mov.getCoronacion()));
+
+		if (mov.isJaque())
+			if (mov.getFinPartida() == Resultado.JAQUE_MATE_BLANCO
+					|| mov.getFinPartida() == Resultado.JAQUE_MATE_NEGRO)
+				temp.append (&quot;#&quot;);
+			else
+				temp.append (&quot;+&quot;);
+		return temp.toString ();
+	}
+
+	/**
+	 * Funciones de uso interno. No usar directamente
+	 * 
+	 * @param letra
+	 * @param num
+	 */
+	void borrarPiezaInternal(char letra, char num) {
+		tabla[num - '1'][letra - 'a'] = null;
+	}
+
+	void setPiezaInternal(Piece p, char letra, char num) {
+		tabla[num - '1'][letra - 'a'] = p;
+		if (p.getTipo() == Tipo.REY) {
+			kingPosition[bandoToInt(p.getBando())].setLetra(letra);
+			kingPosition[bandoToInt(p.getBando())].setNumero(num);
+		}
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/DiccionarioPosiciones.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/PositionsDictionary.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,125 @@
+package com.mihail.chess;
+
+import java.util.ArrayList;
+
+/**
+ * Esta clase define un objeto TablaHash, que representa a la tabla hash que se
+ * usa para almacenar las claves que identifican las posiciones a lo largo de la
+ * partida de ajedrez. Asocia a cada clave de posici&#243;n el n&#250;mero de
+ * repeticiones.
+ * 
+ * @author Pedro Su&#225;rez Casal
+ * @author Iago Porto D&#237;az
+ */
+public final class PositionsDictionary {
+	private ArrayList[] tabla;
+
+	private int tam;
+
+	/**
+	 * Crea una nueva tabla hash del tama&#241;o indicado. Normalmente se creara una
+	 * tabla con un tama&#241;o proximo a 40-50, para situarse en el peor caso de
+	 * repeticiones, y aumentar el rendimiento de la tabla.
+	 */
+	public PositionsDictionary(int t) {
+		tabla = new ArrayList[t];
+		for (int i = 0; i &lt; tabla.length; i++)
+			tabla[i] = new ArrayList();
+		tam = t;
+	}
+
+	/**
+	 * Inserta una clave de posicion dentro de la tabla. Cuando inserta una de
+	 * las claves tambien comprueba si esa posicion esta guardada. Si lo esta,
+	 * vuelve a guardar la clave con el numero de repeticiones aumentado, si no,
+	 * a&#241;ade un nuevo elemento con las repeticiones a 1.
+	 * 
+	 * @param clave
+	 *            Clave que queremos insertar dentro de la tabla
+	 */
+	public void insertar(int clave) {
+		int pos = clave % tam;
+		int i = 0;
+
+		while (i &lt; tabla[pos].size()
+				&amp;&amp; ((Item) tabla[pos].get(i)).getClave() != clave)
+			i++;
+
+		if (i &lt; tabla[pos].size()) {
+			if (((Item) tabla[pos].get(i)).getClave() == clave)
+				((Item) tabla[pos].get(i)).aumentarRep();
+		} else
+			tabla[pos].add(new Item(clave));
+	}
+
+	/**
+	 * Borra todos los elementos de la tabla.
+	 */
+	public void borrarTabla() {
+		for (int i = 0; i &lt; tabla.length; i++)
+			tabla[i].clear();
+	}
+
+	/**
+	 * Obtiene el numero de repeticiones de una posicion dada.
+	 * 
+	 * @param clave
+	 *            La clave asociada con una posicion.
+	 * @return El numero de repeticiones de la clave recibida.
+	 */
+	public int getRepeticiones(int clave) {
+		int pos = clave % tam;
+		int i = 0;
+
+		while (i &lt; tabla[pos].size()
+				&amp;&amp; ((Item) (tabla[pos].get(i))).getClave() != clave)
+			i++;
+
+		if (i &lt; tabla[pos].size())
+			return ((Item) tabla[pos].get(i)).getRepeticiones();
+		return -1;
+	}
+
+	public String toString() {
+		String cad = &quot;[&quot;;
+		for (int i = 0; i &lt; tabla.length; i++) {
+			cad += &quot;[&quot;;
+			for (int j = 0; j &lt; tabla[i].size(); j++) {
+				cad += tabla[i].get(j);
+			}
+			cad += &quot;]&quot;;
+		}
+
+		cad += &quot;]&quot;;
+		return cad;
+	}
+	
+	private final class Item {
+		private int clave;
+
+		private int repeticiones = 1;
+
+		public Item(int num) {
+			clave = num;
+		}
+
+		public int getClave() {
+			return clave;
+		}
+
+		public int getRepeticiones() {
+			return repeticiones;
+		}
+
+		public void aumentarRep() {
+			repeticiones++;
+		}
+
+		public String toString() {
+			String cad = &quot;(&quot; + clave + &quot;, &quot; + repeticiones + &quot;)&quot;;
+
+			return cad;
+		}
+
+	}
+}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/Square.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/Casilla.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Casilla.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/Square.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,111 @@
+/*
+ * Created on 25-jul-2005
+ *
+ * MihailChess - Casilla.java
+ * 
+ * Autores:  Iago Porto Diaz
+ * 			 Pedro Suarez Casal
+ * 
+ */
+package com.mihail.chess;
+
+/**
+ * Representa una casilla en un tablero de ajedrez. Simplemente almacena informacion sobre
+ * la letra y el numero.
+ * @author wotan
+ *
+ */
+
+public class Square {
+
+	private char letra;
+
+	private char numero;
+
+	/**
+	 * Crea una casilla con la letra y numero iguales a cero.
+	 *
+	 */
+	
+	public Square() {
+		this.letra = 0;
+		this.numero = 0;
+	}
+	
+	/**
+	 * Crea una casilla con la letra y numero indicados.
+	 * 
+	 * @param letra Letra de la casilla
+	 * @param numero Numera de la casilla
+	 */
+
+	public Square(char letra, char numero) {
+		this.letra = letra;
+		this.numero = numero;
+	}
+
+	public boolean equals(Object o) {
+		if (o instanceof Square) {
+			Square c = (Square) o;
+			return c.letra == letra &amp;&amp; c.numero == numero;
+		}
+		return false;
+	}
+	
+	/**
+	 * Suma a la casilla actual un vector de direccion, dando como resultado otra casilla.
+	 * A la letra se le suma la direccion x y al numero la direccion y.
+	 * 
+	 * @param v El vector que queremos sumar a la casilla actual.
+	 * @return Otra casilla resultado de sumar a la casilla actual el vector recibido.
+	 */
+
+	public Square add(DirectionVector v) {
+		return new Square((char) (this.letra + v.getX()),
+				(char) (this.numero + v.getY()));
+	}
+	
+	/**
+	 * Obtiene la letra de la casilla.
+	 * 
+	 * @return La letra de la casilla
+	 */
+
+	public char getLetra() {
+		return letra;
+	}
+	
+	/**
+	 * Establece la letra de la casilla.
+	 * 
+	 * @param letra La letra de la casilla
+	 */
+
+	public void setLetra(char letra) {
+		this.letra = letra;
+	}
+	
+	/**
+	 * Obtiene el numero de la casilla.
+	 * 
+	 * @return El numero de la casilla
+	 */
+
+	public char getNumero() {
+		return numero;
+	}
+	
+	/**
+	 * Establece el numero de la casilla.
+	 * 
+	 * @param numero El numero de la casilla
+	 */
+
+	public void setNumero(char numero) {
+		this.numero = numero;
+	}
+
+	public String toString() {
+		return letra + &quot;&quot; + numero;
+	}
+}

Deleted: trunk/MihailChessLib/com/mihail/chess/Tablero2D.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/Tablero2D.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,569 +0,0 @@
-package com.mihail.chess;
-
-import java.awt.BasicStroke;
-import java.awt.Color;
-import java.awt.Dimension;
-import java.awt.Font;
-import java.awt.GradientPaint;
-import java.awt.Graphics;
-import java.awt.Graphics2D;
-import java.awt.Image;
-import java.awt.MediaTracker;
-import java.awt.Point;
-import java.awt.geom.Rectangle2D;
-
-import javax.swing.ImageIcon;
-import javax.swing.JOptionPane;
-import javax.swing.JPanel;
-
-import com.mihail.chess.Logica.Bando;
-import com.mihail.chess.Pieza.Tipo;
-
-/**
- * Esta clase se encarga de proporcionar una vista b&#225;sica de la l&#243;gica, usada
- * como modelo. No proporciona ningun metodo de manejo de eventos, y enmascara
- * las funciones de la l&#243;gica interna.
- * 
- * @author Pedro Su&#225;rez Casal
- * @author Iago Porto D&#237;az
- */
-public class Tablero2D extends JPanel {
-
-	private static final long serialVersionUID = 1L;
-
-	/*
-	 * Tama&#241;o del borde del tablero.
-	 */
-	private int BORDE = 30;
-
-	/*
-	 * Tama&#241;o de la casilla.
-	 */
-	private int TAM;
-
-	/*
-	 * Tama&#241;o anterior, para comparar si es necesario redimensionar.
-	 * 
-	 * @TODO &#191;Es necesario este atributo? Queda chapucero.
-	 */
-	private int TAMant;
-
-	/*
-	 * Coordenada 'x' de la casilla pulsada por ultima vez [0, 8]. Sirve para
-	 * indicar al metodo de dibujo que la casilla indicada no se debe dibujar si
-	 * se esta arrastrando la pieza.
-	 */
-	protected int posX;
-
-	/*
-	 * Coordenada 'y' de la casilla pulsada por ultima vez [0, 8].
-	 */
-	protected int posY;
-
-	// Espacios que hay que dejar alrededor del tablero cuando se redimensiona
-	private int bordeSUP = 0;
-
-	private int bordeLAT = 0;
-
-	// Logica interna del tablero
-
-	protected Posicion tablero;
-
-	// Versiones ajustadas al tama&#241;o correcto de las imagenes
-	private Image[][] piezas = new Image[2][6];
-
-	// Indica el sentido en el que se esta dibujando el tablero
-	private boolean sentido = true;
-
-	// Matriz en la que se van marcando las casillas seleccionada
-	// 'S' -&gt; Casilla seleccionada (amarillo transparente)
-	// 'C' -&gt; Indica que se comio (cuadro rojo)
-	private char seleccion[][] = new char[8][8];
-
-	// Indica si se esta arrastrando una pieza
-	private boolean arrastrando = false;
-
-	/*
-	 * Posicion de la pieza que se esta arrastrando. Se usa en el metodo de
-	 * dibujo para dibujar la pieza piezaArrastrada en el lugar correcto. TODO
-	 * Remodelar para a&#241;adir objetos arbitrarios al tablero, entre ellos piezas
-	 * que estan siendo arrastradas.
-	 */
-	private int posPiezaX, posPiezaY;
-
-	/*
-	 * Imagen de la pieza qu esta siendo arrastrada.
-	 */
-	private Image piezaArrastrada;
-
-	/*
-	 * Colores que se dibujan las casillas en caso de que el tema no lo
-	 * establezca.
-	 */
-	private Color[] colorLiso = new Color[2];
-
-	/*
-	 * Tema que esta usando el tablero para dibujarse.
-	 */
-
-	private BoardTheme theme;
-
-	public Tablero2D(BoardTheme theme) {
-		this(theme, 60);
-	}
-
-	public Tablero2D(BoardTheme theme, int tam) {
-		super();
-		tablero = new Posicion();
-
-		TAM = tam;
-
-		// this.setAutoscrolls(true);
-		this.theme = theme;
-
-		redimensionar();
-	}
-
-	/**
-	 * Se encarga de cambiar el sentido del tablero.
-	 */
-
-	public void rotarTablero() {
-		sentido = !sentido;
-		repaint();
-	}
-
-	public Dimension getPreferredSize() {
-		return (new Dimension(8 * TAM + BORDE * 2, 8 * TAM + BORDE * 2));
-	}
-
-	public void paintComponent(Graphics g) {
-		Pieza temp;
-		// Actualizamos el tama&#241;o de la casilla en caso de que redimensionen el
-		// tablero
-		int TAMtotal = Math.min(getWidth(), getHeight());
-		Graphics2D g2d = (Graphics2D) g;
-		TAMant = TAM;
-		TAM = (TAMtotal - BORDE * 2) / 8;
-		if (TAMant != TAM) {
-			redimensionar();
-		}
-
-		// Hints de renderizado
-		// g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING,
-		// RenderingHints.VALUE_TEXT_ANTIALIAS_ON);
-
-		if(theme.getBackground()==null) {
-			g.setColor(Color.LIGHT_GRAY);
-			g.fillRect(0, 0, getWidth(), getHeight());
-		} else {
-			g.drawImage(theme.getBackground(), 0, 0, this.getWidth(), this.getHeight(), null);
-		}
-
-		if (getWidth() &lt; getHeight()) {
-			bordeSUP = (getHeight() - getWidth()) / 2;
-			bordeLAT = 0;
-		} else {
-			bordeLAT = (getWidth() - getHeight()) / 2;
-			bordeSUP = 0;
-		}
-		g.setClip(bordeLAT, bordeSUP, TAMtotal, TAMtotal);
-		g.translate(bordeLAT, bordeSUP);
-
-		// Borde tablero
-		dibujarBorde(g);
-		// Bucle para dibujar el tablero
-
-		g.setClip(BORDE, BORDE, getWidth() - BORDE, getHeight() - BORDE);
-		g.translate(BORDE, BORDE);
-		for (int j = 0; j &lt; 8; j++) {
-			for (int i = 0; i &lt; 8; i++) {
-				// En funcion de nuestra posicion escogemos el color para
-				// casillas blancas o negras
-				// if (activado) {
-				int v = (i + j) % 2;
-				Image textura = theme.getImageCasilla(v == 0 ? Bando.BLANCO
-						: Bando.NEGRO);
-				if (textura != null)
-
-					g.drawImage(textura, i * TAM, j * TAM, TAM, TAM, null);
-
-				else {
-					g.setColor(colorLiso[v]);
-					g.fillRect(i * TAM, j * TAM, TAM, TAM);
-				}
-
-				// Dibujamos la casilla
-				//
-				// En caso de que la casilla que tratamos este seleccionada, la
-				// marcamos de color verde
-				int ii = i, jj = j;
-				if (!sentido) {
-					ii = 7 - i;
-					jj = 7 - j;
-				}
-
-				// En funcion del caracter de seleccion dibujamos una cosa u
-				// otra
-				switch (seleccion[ii][jj]) {
-				case 'S':
-					g.setColor(new Color(255, 255, 0, 50));
-					g.fill3DRect(i * TAM, j * TAM, TAM, TAM, true);
-					break;
-				case 'M':
-					g2d.setStroke(new BasicStroke(2.0F, BasicStroke.CAP_BUTT,
-							BasicStroke.JOIN_ROUND));
-					g.setColor(new Color(220, 0, 0));
-					g2d.draw(new Rectangle2D.Float(i * TAM, j * TAM, TAM - 1,
-							TAM - 1));
-
-					// g.drawRect(i * TAM, j * TAM, TAM-1, TAM-1);
-					break;
-				default:
-				}
-
-				// Comprobamos si existe pieza en esa casilla, y en ese caso la
-				// dibujamos
-				char letra, numero;
-				// Se comprueba el sentido en el que dibujamos
-				if (sentido) {
-					numero = (char) ((7 - j) + '1');
-					letra = (char) (i + 'a');
-				} else {
-					numero = (char) (j + '1');
-					letra = (char) ((7 - i) + 'a');
-				}
-
-				if ((temp = tablero.getPieza(letra, numero)) != null) {
-					if (arrastrando
-							&amp;&amp; ((sentido &amp;&amp; i == posX &amp;&amp; j == posY) || (!sentido
-									&amp;&amp; i == 7 - posX &amp;&amp; j == 7 - posY))) {
-						continue;
-					}
-
-					//g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, null);
-					g.drawImage(piezas[bandoToInt(temp.getBando())][tipoToInt(temp.getTipo())], i * TAM, j * TAM, TAM, TAM, null);
-				}
-			}
-
-		}
-
-		// Este es el caso de que haya que dibujar la pieza a arrastrar. Se
-		// dibuja por encima de todo el resto del tablero
-		if (piezaArrastrada != null) {
-			g.translate(-bordeLAT, -bordeSUP);
-			g.translate(-BORDE, -BORDE);
-			g.setClip(posPiezaX - TAM / 2, posPiezaY - TAM / 2, TAM, TAM);
-			if (arrastrando) {
-				g.drawImage(piezaArrastrada, posPiezaX - TAM / 2, posPiezaY
-						- TAM / 2, null);
-			}
-		}
-
-	}
-
-	/**
-	 * @return Devuelve el tama&#241;o del borde del tablero.
-	 */
-
-	public int getBorde() {
-		return BORDE;
-	}
-
-	/**
-	 * @return Devuelve el tama&#241;o de las casilla.
-	 */
-
-	public int getTamanhoCasilla() {
-		return TAM;
-	}
-
-	/**
-	 * @param tam
-	 *            Establece el tama&#241;o de las casilla.
-	 */
-
-	public void setTamanhoCasilla(int tam) {
-		TAM = tam;
-	}
-
-	/**
-	 * Establece que una pieza se esta arrastrando para que la dibuje en la
-	 * posicion correspondiente.
-	 * 
-	 * @param arrastrando
-	 *            El valor al que queremos establecer si se esta arrastrando o
-	 *            no.
-	 */
-	public void setArrastrando(boolean arrastrando) {
-		this.arrastrando = arrastrando;
-	}
-
-	/**
-	 * @param piezaArrastrada
-	 *            Establece al imagen a arrastrar.
-	 */
-	public void setPiezaArrastrada(Image piezaArrastrada) {
-		this.piezaArrastrada = piezaArrastrada;
-	}
-
-	/**
-	 * @return Devuelve si la casilla indicada por (i, j) tiene algun tipo de
-	 *         seleccion.
-	 */
-
-	public char getSeleccion(int i, int j) {
-		return seleccion[i][j];
-	}
-
-	/**
-	 * Establece la seleccion de una casilla.
-	 * 
-	 * @param s
-	 *            Seleccion a la que establecemos la casilla.
-	 */
-	public void setSeleccion(char s, int i, int j) {
-		this.seleccion[i][j] = s;
-	}
-
-	public Point getPosPiezaArrastrada() {
-		return new Point(posPiezaX, posPiezaY);
-	}
-
-	/**
-	 * @param posPiezaX
-	 *            The posPiezaX to set.
-	 */
-	public void setPosPiezaArrastrada(int posPiezaX, int posPiezaY) {
-		this.posPiezaX = posPiezaX;
-		this.posPiezaY = posPiezaY;
-	}
-
-	/**
-	 * @return Devuelve el borde lateral, el espacio que puede sobrar a los
-	 *         lados del tablero.
-	 */
-	public int getBordeLateral() {
-		return bordeLAT;
-	}
-
-	/**
-	 * @return Devuelve el borde superior, el espacio que puede sobrar arriba y
-	 *         abajo del tablero.
-	 */
-	public int getBordeSuperior() {
-		return bordeSUP;
-	}
-
-	/**
-	 * Indica el sentido en el que se esta dibujando el tablero
-	 * 
-	 * @return Devuelve true si las blancas estan abajo y false si las negras
-	 *         estan abajo.
-	 */
-
-	public boolean isSentido() {
-		return sentido;
-	}
-
-	/**
-	 * Establece el sentido del tablero.
-	 * 
-	 * @param sentido
-	 *            The sentido to set.
-	 */
-	public void setSentido(boolean sentido) {
-		this.sentido = sentido;
-	}
-
-	/**
-	 * Obtiene el color liso de las casillas de un color.
-	 * 
-	 * @param b
-	 *            El tipo de las casillas, blancas o negras.
-	 * @return El color liso.
-	 */
-	public Color getColorLiso(Bando b) {
-		return colorLiso[bandoToInt(b)];
-	}
-
-	/**
-	 * Establece el color liso de las casillas de un color. Este color solo se
-	 * mostrara en caso de que el tema no establezca una textura para las
-	 * casillas.
-	 * 
-	 * @param b
-	 *            El tipo de las casillas, blancas o negras.
-	 * @param colorLiso
-	 *            El color liso.
-	 */
-
-	public void setColorLiso(Bando b, Color colorLiso) {
-		this.colorLiso[bandoToInt(b)] = colorLiso;
-	}
-
-	/**
-	 * Establece el tema que usa el tablero para dibujarse.
-	 * 
-	 * @param theme
-	 *            Tema a establecer.
-	 */
-
-	public void setTema(BoardTheme theme) {
-		this.theme = theme;
-	}
-	
-	public void setPieza(Pieza pieza, Casilla casilla) {
-		tablero.setPieza(pieza, casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
-	}
-	
-	public void borrarPieza(Casilla casilla) {
-		tablero.borrarPieza(casilla);
-		repintarCasilla(casilla.getLetra() - 'a', casilla.getNumero()-'1');
-	}
-	
-	public void setFEN(String pos) {
-		tablero.setPosicion(pos);
-		repaint();
-	}
-
-	/*
-	 * Funcion para repintar la casilla indicada por el punto x, y, que debe ser
-	 * el centro de la casilla. TODO Modificar para que funcione con la esquina
-	 * superior izquierda?
-	 */
-
-	protected void repintarCasilla(int x, int y) {
-		repaint(x - TAM / 2, y - TAM / 2, TAM, TAM);
-	}
-
-	/**
-	 * Metodo de utilidad para obtener de forma sencilla la casilla
-	 * correspondiente a la que pertenece un pixel en la posicion (x, y).
-	 * 
-	 * @param x
-	 *            Coordenada x
-	 * @param y
-	 *            Coordenada y
-	 * @return Devuelve un punto con las coordenadas de la casilla
-	 *         correspondiente al punto x, y. El valor devuelto estar&#225; en el
-	 *         intervalo [0, 7].
-	 */
-	protected Point getCasilla(int x, int y) {
-		int posX = (x - BORDE - bordeLAT) / TAM, posY = (y - BORDE - bordeSUP)
-				/ TAM;
-		if (!isSentido()) {
-			posX = 7 - posX;
-			posY = 7 - posY;
-		}
-		return new Point(posX, posY);
-	}
-
-	private void dibujarBorde(Graphics g) {
-		Image borde = theme.getMarco();
-		if (borde != null) {
-			g.drawImage(borde, 0, 0, null);
-		} else { // Dibujamos a mano
-			g.setColor(Color.BLACK);
-
-			g.fillRect(0, 0, Math.min(getWidth(), getHeight()), Math.min(
-					getWidth(), getHeight()));
-			// char num = '8';
-			// char let = 'a';
-
-			g.setColor(new Color(209, 193, 134));
-			g.setFont(new Font(&quot;Arial&quot;, Font.BOLD, 12));
-
-			int yF = 8 * TAM + BORDE * 3 / 2 + 6;
-			for (int i = 0; i &lt; 8; i++) {
-				int xF = i * TAM + BORDE + TAM / 2;
-				if (sentido) {
-					g.drawString(new Character((char) (i + 'A')).toString(),
-							xF, yF);
-				} else {
-					g.drawString(
-							new Character((char) (7 - i + 'A')).toString(), xF,
-							yF);
-				}
-			}
-			int xF = BORDE / 2 - 3;
-			for (int i = 0; i &lt; 8; i++) {
-				yF = i * TAM + BORDE + TAM / 2;
-				if (sentido) {
-
-					g.drawString(new Integer(7 - i + 1).toString(), xF, yF);
-
-				} else {
-					g.drawString(new Integer(i + 1).toString(), xF, yF);
-				}
-			}
-		}
-	}
-
-	private int bandoToInt(Bando b) {
-		if (b == Bando.BLANCO) {
-			return 0;
-		}
-		return 1;
-	}
-	
-	private int tipoToInt(Tipo tipo) {
-		switch(tipo) {
-		case PEON:
-			return 0;
-		case CABALLO:
-			return 1;
-		case ALFIL:
-			return 2;
-		case TORRE:
-			return 3;
-		case DAMA:
-			return 4;
-		case REY:
-			return 5;
-		}
-		return -1;
-	}
-	
-	private Tipo intToTipo(int i) {
-		switch(i) {
-		case 0:
-			return Tipo.PEON;
-		case 1:
-			return Tipo.CABALLO;
-		case 2:
-			return Tipo.ALFIL;
-		case 3:
-			return Tipo.TORRE;
-		case 4:
-			return Tipo.DAMA;
-		case 5:
-			return Tipo.REY;
-		}
-		return null;
-	}
-
-	/*
-	 * Funcion de utilidad que se encarga de redimensionar las imagenes al
-	 * tama&#241;o adecuado del tablero
-	 */
-
-	private final void redimensionar() {
-		MediaTracker media = new MediaTracker(this);
-		for (int i = 0; i &lt; 2; i++) {
-			for (int j = 0; j &lt; 6; j++) {
-				piezas[i][j] = theme.getImagePiece(i==0?Bando.BLANCO:Bando.NEGRO, intToTipo(j))
-						.getScaledInstance(TAM, TAM, Image.SCALE_FAST);
-				media.addImage(piezas[i][j], 1);
-			}
-		}
-		try {
-			media.waitForID(1);
-		} catch (InterruptedException e) {
-			JOptionPane.showMessageDialog(this,
-					&quot;Redimensionado de Imagenes Interrumpido:\n&quot;
-							+ e.getMessage());
-		}
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/chess/VariationsTree.java (from rev 30, trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/ArbolVariantes.java	2005-08-12 23:35:50 UTC (rev 30)
+++ trunk/MihailChessLib/com/mihail/chess/VariationsTree.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,219 @@
+package com.mihail.chess;
+
+import java.util.AbstractList;
+import java.util.ArrayList;
+import java.util.List;
+
+import com.mihail.chess.Board.Bando;
+
+/**
+ * @author Wotan
+ * 
+ * TODO To change the template for this generated type comment go to Window -
+ * Preferences - Java - Code Style - Code Templates
+ */
+public class VariationsTree {
+	private class NodoArbol {
+		public Movement movimiento;
+
+		public ArrayList&lt;VariationsTree&gt; variantes;
+
+		public NodoArbol(Movement mov) {
+			movimiento = mov;
+		}
+	}
+
+	/**
+	 * Desplazamiento con respecto al principio de la partida. En el caso de la
+	 * variante principal, el desplazamiento es 0, pero en otro caso el
+	 * desplazamiento es igual el numero de movimiento en el que se encuentra la
+	 * variante.
+	 */
+
+	private int desplazamiento = 0;
+
+	private AbstractList&lt;NodoArbol&gt; arbol = new ArrayList&lt;NodoArbol&gt;();
+
+	/**
+	 * 
+	 */
+	public VariationsTree() {
+	}
+
+	private VariationsTree(int desp) {
+		desplazamiento = desp;
+	}
+
+	/**
+	 * A&#241;ade el movimiento al final de la variante principal.
+	 * 
+	 * @param mov
+	 *            Movimiento que se a&#241;ade.
+	 */
+	public void appendMovimiento(Movement mov) {
+		arbol.add(new NodoArbol(mov));
+	}
+
+	/**
+	 * Obtiene un movimiento a partir del numero de movimiento y el turno de
+	 * juego.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento
+	 * @param numero
+	 *            Numero del movimiento
+	 * @return Devuelve el movimiento correspondiente a color y numero
+	 */
+	public Movement getMovimiento(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+		if (n != null)
+			return n.movimiento;
+		return null;
+	}
+	
+	public Movement getMovimiento(int halfPly) {
+		return arbol.get(halfPly).movimiento;
+	}
+
+	/**
+	 * Comprueba si dado un movimiento, existen alternativas.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 * @return Un booleano que indica si para ese movimiento existen
+	 *         alternativas.
+	 */
+	public boolean existeVariante(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n != null &amp;&amp; n.variantes != null)
+			return (!n.variantes.isEmpty());
+		return false;
+	}
+
+	/**
+	 * Devuelve el numero de variantes a un movimiento determinado.
+	 * 
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 * @return El numero de alternativas a un movimiento.
+	 */
+	public int getNumVariantes(Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n != null) {
+			if (n.variantes != null)
+				return n.variantes.size();
+		}
+		return 0;
+	}
+
+	private int bandoToInt(Bando b) {
+		if (b == Bando.BLANCO)
+			return 0;
+		return 1;
+	}
+
+	// Funcion de utilidad.
+	private NodoArbol getNodo(Bando color, int numero) {
+		int indice = (numero - 1) * 2 + bandoToInt(color);
+		if (indice &lt; arbol.size())
+			return arbol.get(indice);
+		return null;
+	}
+
+	/**
+	 * A&#241;ade un movimiento como variante a otro movimiento.
+	 * 
+	 * @param mov
+	 *            Movimiento que se a&#241;ade como alternativa
+	 * @param color
+	 *            Turno del que es el movimiento.
+	 * @param numero
+	 *            Numero del movimiento.
+	 */
+	public void addVariante(Movement mov, Bando color, int numero) {
+		NodoArbol n = getNodo(color, numero);
+
+		if (n.variantes == null)
+			n.variantes = new ArrayList&lt;VariationsTree&gt;();
+
+		VariationsTree a = new VariationsTree(numero);
+		if (color == Bando.NEGRO) // Cada arbol de variantes debe empezar con un movimiento de blancas
+			a.appendMovimiento(new Movement());
+		a.appendMovimiento(mov);
+
+		n.variantes.add(a);
+	}
+
+	/**
+	 * Devuelve la variante numero num a un movimiento dado.
+	 * 
+	 * @param color
+	 * @param numero
+	 * @param num
+	 *            Numero de variante que se quiere obtener.
+	 * @return Devuelve un ArbolVariantes, que es la variante del movimiento.
+	 */
+	public VariationsTree getVariante(Bando color, int numero, int num) {
+		NodoArbol n = getNodo(color, numero);
+		if (n != null)
+			return n.variantes.get(num);
+		return null;
+	}
+
+	/**
+	 * @return Devuelve el numero total de movimientos desde el comienzo de la
+	 *         partida. Solo cuenta los turnos jugados, no cuenta un movimiento
+	 *         por negras y otro por blancas.
+	 */
+	public int getNumMovimientos() {
+		return desplazamiento + ((arbol.size() + 1) / 2);
+	}
+
+	/**
+	 * Cuenta los medios movimientos, es decir, contando uno por cada movimiento
+	 * de negras y blancas.
+	 * 
+	 * @return Los medios movimientos desde el comienzo de la partida.
+	 */
+
+	public int getNumHalfPly() {
+		return arbol.size();
+	}
+
+	/**
+	 * Devuelve el &#250;ltimo movimiento de la variante actual.
+	 * 
+	 * @return
+	 */
+
+	public Movement getLastMovimiento() {
+		return arbol.get(arbol.size() - 1).movimiento;
+	}
+	
+	/**
+	 * Hace que una variante pase a ser la variante principal.
+	 * 
+	 * @param color
+	 * @param numero
+	 * @param num
+	 */
+	
+	public void promoteVariant(Bando color, int numero, int num) {
+		VariationsTree a = getVariante(color, numero, num);
+		int indice = (numero - 1) * 2 + bandoToInt(color);
+		NodoArbol n = getNodo(color, numero);
+		
+		VariationsTree newTree = new VariationsTree();
+		newTree.arbol  = (AbstractList&lt;VariationsTree.NodoArbol&gt;)arbol.subList(indice, arbol.size());
+		n.variantes.add(newTree);
+		
+		arbol.addAll(a.arbol);
+		n.variantes.remove(num);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java
===================================================================
--- trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/chess/VectorDireccion.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,77 +0,0 @@
-package com.mihail.chess;
-
-/**
- * Almacena la direcci&#243;n en la que una pieza puede mover. Cuando se crea un
- * nuevo vector direcci&#243;n, se entiende que la x y la y indican las componentes
- * del vector dentro del tablero. Adem&#225;s el vector debe ser 'unitario' para que
- * la l&#243;gica lo interprete correctamente. Por ejemplo, si queremos indicar los
- * movimientos posibles de una dama, basta con indicar 8 vectores de direcci&#243;n:
- * (1, 0) (1, 1) (1, -1) (0, 1) (0, -1) (-1, 0) (-1, 1) (-1, -1). Esto
- * proporciona gran flexibilidad a la hora de definir nuevas piezas en sistemas
- * de ajedrez alternativos. Podriamos definir una pieza que se mueva unicamente
- * como (1, 2) y (0, 1). TODO indicar los vectores que deben ser estrictamente
- * unitarios, para diferenciar piezas que se mueven una casilla de las que se
- * mueven toda la fila. Quiza sea conveniente indicarlo en Pieza, junto con si
- * la pieza puede saltar a otras.
- */
-
-public class VectorDireccion {
-	private int x, y;
-
-	/**
-	 * Crea un nuevo vector de direcci&#243;n.
-	 * 
-	 * @param x_
-	 *            Desplazamiento permitido en sentido horizontal, es decir, a
-	 *            traves de las filas
-	 * @param y_
-	 *            Desplazamiento permitido en sentido vertical, es decir, a
-	 *            traves de las columnas
-	 */
-	public VectorDireccion(int x_, int y_) {
-		x = x_;
-		y = y_;
-	}
-
-	/**
-	 * Comprueba si un vector es multiplo de otro. Por ejemplo, devolveria true
-	 * en caso que al vector (1, 1) se le pase el vector (2, 2).
-	 * 
-	 * @param v
-	 *            Vector con el que queremos comprobar si es la misma direccion.
-	 * @return Un booleano si este vector y el recibido siguen la misma
-	 *         direccion.
-	 */
-	public boolean esMismaDireccion(VectorDireccion v) {
-		int difX, difY;
-
-		if ((x == 0 &amp;&amp; v.getX() != 0) || (y == 0 &amp;&amp; v.getY() != 0))
-			return false;
-
-		if (v.getX() == 0 &amp;&amp; x == 0)
-			difX = 1;
-		else
-			difX = v.getX() / x;
-
-		if (v.getY() == 0 &amp;&amp; y == 0)
-			difY = 1;
-		else
-			difY = v.getY() / y;
-
-		return (difY == difX);
-	}
-
-	/**
-	 * Devuelve el desplazamiento horizontal de este vector.
-	 */
-	public int getX() {
-		return x;
-	}
-
-	/**
-	 * Devuelve el desplazamiento vertical de este vector.
-	 */
-	public int getY() {
-		return y;
-	}
-}

Copied: trunk/MihailChessLib/com/mihail/clock/Clock.java (from rev 27, trunk/MihailChessLib/com/mihail/clock/Reloj.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/clock/Clock.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,174 @@
+package com.mihail.clock;
+
+import java.util.Observable;
+import java.util.TimerTask;
+import java.util.Timer;
+
+/**
+ * El funcionamiento de la clase Reloj se basa en el paradigma Modelo-Vista.
+ * Reloj representa un objeto observable. Una aplicacion que quiera usar un
+ * reloj ha de implementar la interfaz Observer, como explica la documentacion
+ * de la superclase Observable.&lt;br&gt;
+ * Reloj utiliza un Timer que, cada decima de segundo, decrementa el valor del
+ * reloj. Se pueden utilizar recargas, si bien se realizan de forma asincrona,
+ * estando obligado el observador a recargar el Reloj cuando lo desee. Presenta
+ * dos estados, parado y en marcha. Estos estados nos permiten parar el Reloj
+ * cuando sea el turno del oponente.&lt;br&gt;
+ * El metodo Observer.update() sera llamado cada vez que haya un cambio de
+ * estado en el Reloj, esto es, cada vez que se decrementa el tiempo. Es
+ * responsabilidad del observador controlar el fin de tiempo.&lt;br&gt;
+ * El manejo de la clase Reloj se realiza basicamente con tres metodos: comenzar
+ * (), setParado (boolean b) y recargar ().&lt;br&gt;
+ * Una vez instanciada la clase, se llamara a comenzar(). Esto hace que el Timer
+ * comience a funcionar. El estado inicial del Reloj sera de parado. Para
+ * ponerlo en marcha y pararlo sucesivamente, segun cambie el turno de juego en
+ * la partida, usaremos setParado (boolean b). Cuando el observador desee
+ * recargar el reloj, llamara a recarga (), sumandose en el reloj la cantidad
+ * establecida previamente en el constructor o usando setRecarga(int recarga).&lt;br&gt;
+ * 
+ * @author Pedro Su&#225;rez Casal
+ * @author Iago Porto D&#237;az
+ * 
+ * @see java.util.Observable
+ * @see java.util.Observer
+ * @see java.util.Timer
+ */
+public class Clock extends Observable {
+	protected int horas, minutos, segundos, decimas;
+
+	protected int recarga;
+
+	protected boolean parado;
+
+	protected static Timer tiempo = null;
+
+	public Clock(int h, int m, int s) throws ClockException {
+		parado = true;
+		horas = h;
+		minutos = m;
+		segundos = s;
+		if (h &lt; 0)
+			throw new ClockException(&quot;Horas fuera de rango&quot;);
+		if (m &lt; 0 || m &gt; 59)
+			throw new ClockException(&quot;Minutos fuera de rango&quot;);
+		if (s &lt; 0 || s &gt; 59)
+			throw new ClockException(&quot;Segundos fuera de rango&quot;);
+		decimas = 0;
+		recarga = 0;
+	}
+
+	public Clock(int h, int m, int s, int rec) throws ClockException {
+		parado = true;
+		horas = h;
+		minutos = m;
+		segundos = s;
+		if (h &lt; 0)
+			throw new ClockException(&quot;Horas fuera de rango&quot;);
+		if (m &lt; 0 || m &gt; 59)
+			throw new ClockException(&quot;Minutos fuera de rango&quot;);
+		if (s &lt; 0 || s &gt; 59)
+			throw new ClockException(&quot;Segundos fuera de rango&quot;);
+		decimas = 0;
+		recarga = rec;
+		if (rec &lt; 0)
+			throw new ClockException(&quot;Recarga fuera de rango&quot;);
+	}
+
+	public void comenzar() {
+		if (tiempo == null) {
+			tiempo = new Timer();
+		}
+		parado = false;
+		tiempo.scheduleAtFixedRate(new TimerTask() {
+			public void run() {
+				tareasRun();
+			}
+		}, 0, 100);
+	}
+
+	protected void tareasRun() {
+		if (!parado) {
+			if (decimas != 0) {
+				decimas--;
+			} else {
+				if (segundos != 0) {
+					segundos--;
+				} else {
+					if (minutos != 0) {
+						minutos--;
+					} else {
+						horas--;
+						minutos = 59;
+					}
+					segundos = 59;
+				}
+				decimas = 9;
+			}
+			// Notifica que se han producido cambios en el reloj.
+			this.setChanged();
+			// Avisa a sus observadores de que se han producido cambios. Este
+			// metodo ya llama a clearChanged().
+			this.notifyObservers();
+			// // Sirve para que no aparezcan tiempos negativos en el
+			// // reloj (por ejemplo, al acabarse el tiempo).
+			// if (HORAS &lt; 0 || MINUTOS &lt; 0 || SEGUNDOS &lt; 0) {
+			// HORAS = 0;
+			// MINUTOS = 0;
+			// SEGUNDOS = 0;
+			// DECIMAS = 0;
+			// }
+		}
+	}
+
+	public void setParado(boolean b) {
+		parado = b;
+	}
+
+	public void setTiempo(int h, int m, int s, int d) throws ClockException {
+		horas = h;
+		if (h &lt; 0)
+			throw new ClockException(&quot;Horas fuera de rango&quot;);
+		if (m &lt; 0 || m &gt; 59)
+			throw new ClockException(&quot;Minutos fuera de rango&quot;);
+		else
+			minutos = m;
+		if (s &lt; 0 || s &gt; 59)
+			throw new ClockException(&quot;Segundos fuera de rango&quot;);
+		else
+			segundos = s;
+		decimas = d;
+	}
+
+	public void recargar() {
+		int simul, resto;
+		simul = segundos + recarga;
+		horas += simul / 3600;
+		resto = simul % 3600;
+		minutos += resto / 60;
+		segundos = resto % 60;
+	}
+
+	public boolean isFinTiempo() {
+		return horas &lt; 0;
+	}
+
+	public void setRecarga(int segs) {
+		recarga = segs;
+	}
+
+	public int getHoras() {
+		return horas;
+	}
+
+	public int getMinutos() {
+		return minutos;
+	}
+
+	public int getSegundos() {
+		return segundos;
+	}
+
+	public int getDecimas() {
+		return decimas;
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/clock/ClockException.java (from rev 27, trunk/MihailChessLib/com/mihail/clock/RelojException.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/clock/ClockException.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,24 @@
+package com.mihail.clock;
+
+/**
+ * Esta clase define una RelojException, que son las excepciones que se lanzan
+ * cuando hay algun problema con los relojes.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ * 
+ */
+public class ClockException extends Exception {
+
+	private static final long serialVersionUID = 1L;
+
+	/**
+	 * Construye una RelojException con el mensaje de detalle especificado.
+	 * 
+	 * @param s
+	 *            Mensaje que detalla la excepcion.
+	 */
+	public ClockException(String s) {
+		super(s);
+	}
+}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/clock/Reloj.java
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/clock/Reloj.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,174 +0,0 @@
-package com.mihail.clock;
-
-import java.util.Observable;
-import java.util.TimerTask;
-import java.util.Timer;
-
-/**
- * El funcionamiento de la clase Reloj se basa en el paradigma Modelo-Vista.
- * Reloj representa un objeto observable. Una aplicacion que quiera usar un
- * reloj ha de implementar la interfaz Observer, como explica la documentacion
- * de la superclase Observable.&lt;br&gt;
- * Reloj utiliza un Timer que, cada decima de segundo, decrementa el valor del
- * reloj. Se pueden utilizar recargas, si bien se realizan de forma asincrona,
- * estando obligado el observador a recargar el Reloj cuando lo desee. Presenta
- * dos estados, parado y en marcha. Estos estados nos permiten parar el Reloj
- * cuando sea el turno del oponente.&lt;br&gt;
- * El metodo Observer.update() sera llamado cada vez que haya un cambio de
- * estado en el Reloj, esto es, cada vez que se decrementa el tiempo. Es
- * responsabilidad del observador controlar el fin de tiempo.&lt;br&gt;
- * El manejo de la clase Reloj se realiza basicamente con tres metodos: comenzar
- * (), setParado (boolean b) y recargar ().&lt;br&gt;
- * Una vez instanciada la clase, se llamara a comenzar(). Esto hace que el Timer
- * comience a funcionar. El estado inicial del Reloj sera de parado. Para
- * ponerlo en marcha y pararlo sucesivamente, segun cambie el turno de juego en
- * la partida, usaremos setParado (boolean b). Cuando el observador desee
- * recargar el reloj, llamara a recarga (), sumandose en el reloj la cantidad
- * establecida previamente en el constructor o usando setRecarga(int recarga).&lt;br&gt;
- * 
- * @author Pedro Su&#225;rez Casal
- * @author Iago Porto D&#237;az
- * 
- * @see java.util.Observable
- * @see java.util.Observer
- * @see java.util.Timer
- */
-public class Reloj extends Observable {
-	protected int horas, minutos, segundos, decimas;
-
-	protected int recarga;
-
-	protected boolean parado;
-
-	protected static Timer tiempo = null;
-
-	public Reloj(int h, int m, int s) throws RelojException {
-		parado = true;
-		horas = h;
-		minutos = m;
-		segundos = s;
-		if (h &lt; 0)
-			throw new RelojException(&quot;Horas fuera de rango&quot;);
-		if (m &lt; 0 || m &gt; 59)
-			throw new RelojException(&quot;Minutos fuera de rango&quot;);
-		if (s &lt; 0 || s &gt; 59)
-			throw new RelojException(&quot;Segundos fuera de rango&quot;);
-		decimas = 0;
-		recarga = 0;
-	}
-
-	public Reloj(int h, int m, int s, int rec) throws RelojException {
-		parado = true;
-		horas = h;
-		minutos = m;
-		segundos = s;
-		if (h &lt; 0)
-			throw new RelojException(&quot;Horas fuera de rango&quot;);
-		if (m &lt; 0 || m &gt; 59)
-			throw new RelojException(&quot;Minutos fuera de rango&quot;);
-		if (s &lt; 0 || s &gt; 59)
-			throw new RelojException(&quot;Segundos fuera de rango&quot;);
-		decimas = 0;
-		recarga = rec;
-		if (rec &lt; 0)
-			throw new RelojException(&quot;Recarga fuera de rango&quot;);
-	}
-
-	public void comenzar() {
-		if (tiempo == null) {
-			tiempo = new Timer();
-		}
-		parado = false;
-		tiempo.scheduleAtFixedRate(new TimerTask() {
-			public void run() {
-				tareasRun();
-			}
-		}, 0, 100);
-	}
-
-	protected void tareasRun() {
-		if (!parado) {
-			if (decimas != 0) {
-				decimas--;
-			} else {
-				if (segundos != 0) {
-					segundos--;
-				} else {
-					if (minutos != 0) {
-						minutos--;
-					} else {
-						horas--;
-						minutos = 59;
-					}
-					segundos = 59;
-				}
-				decimas = 9;
-			}
-			// Notifica que se han producido cambios en el reloj.
-			this.setChanged();
-			// Avisa a sus observadores de que se han producido cambios. Este
-			// metodo ya llama a clearChanged().
-			this.notifyObservers();
-			// // Sirve para que no aparezcan tiempos negativos en el
-			// // reloj (por ejemplo, al acabarse el tiempo).
-			// if (HORAS &lt; 0 || MINUTOS &lt; 0 || SEGUNDOS &lt; 0) {
-			// HORAS = 0;
-			// MINUTOS = 0;
-			// SEGUNDOS = 0;
-			// DECIMAS = 0;
-			// }
-		}
-	}
-
-	public void setParado(boolean b) {
-		parado = b;
-	}
-
-	public void setTiempo(int h, int m, int s, int d) throws RelojException {
-		horas = h;
-		if (h &lt; 0)
-			throw new RelojException(&quot;Horas fuera de rango&quot;);
-		if (m &lt; 0 || m &gt; 59)
-			throw new RelojException(&quot;Minutos fuera de rango&quot;);
-		else
-			minutos = m;
-		if (s &lt; 0 || s &gt; 59)
-			throw new RelojException(&quot;Segundos fuera de rango&quot;);
-		else
-			segundos = s;
-		decimas = d;
-	}
-
-	public void recargar() {
-		int simul, resto;
-		simul = segundos + recarga;
-		horas += simul / 3600;
-		resto = simul % 3600;
-		minutos += resto / 60;
-		segundos = resto % 60;
-	}
-
-	public boolean isFinTiempo() {
-		return horas &lt; 0;
-	}
-
-	public void setRecarga(int segs) {
-		recarga = segs;
-	}
-
-	public int getHoras() {
-		return horas;
-	}
-
-	public int getMinutos() {
-		return minutos;
-	}
-
-	public int getSegundos() {
-		return segundos;
-	}
-
-	public int getDecimas() {
-		return decimas;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/clock/RelojException.java
===================================================================
--- trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/clock/RelojException.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,24 +0,0 @@
-package com.mihail.clock;
-
-/**
- * Esta clase define una RelojException, que son las excepciones que se lanzan
- * cuando hay algun problema con los relojes.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- * 
- */
-public class RelojException extends Exception {
-
-	private static final long serialVersionUID = 1L;
-
-	/**
-	 * Construye una RelojException con el mensaje de detalle especificado.
-	 * 
-	 * @param s
-	 *            Mensaje que detalla la excepcion.
-	 */
-	public RelojException(String s) {
-		super(s);
-	}
-}
\ No newline at end of file

Deleted: trunk/MihailChessLib/com/mihail/openings/Aperturas.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,41 +0,0 @@
-package com.mihail.openings;
-
-import java.io.*;
-import java.util.Locale;
-
-import com.mihail.chess.*;
-
-public class Aperturas {
-	/**
-	 * Tabla hash con las aperturas.
-	 */
-	private DiccionarioAperturas aperturas;
-
-	/**
-	 * Recibe el tablero donde se va a mirar la apertura y el idioma en que se
-	 * quieren las aperturas.
-	 * 
-	 * @param loc
-	 * @throws FileNotFoundException
-	 * @throws IOException
-	 */
-	public Aperturas(Locale loc) throws FileNotFoundException, IOException {
-		// Se construye la Tabla Hash con las aperturas.
-		aperturas = new DiccionarioAperturas(loc);
-		aperturas.parse();
-	}
-
-	/**
-	 * Obtiene la apertura que se esta jugando en una Posicion pos
-	 * 
-	 * @param pos
-	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
-	 */
-	public String getApertura(Posicion pos) {
-		int clave = pos.getClavePosicion();
-		if (aperturas.containsKey(clave))
-			return aperturas.get(clave);
-		else
-			return null;
-	}
-}

Deleted: trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -1,123 +0,0 @@
-package com.mihail.openings;
-
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.*;
-
-/**
- * Esta clase define un objeto DiccionarioAperturas y se encarga de almacenar en
- * una tabla hash los nombres de las aperturas junto con una clave numerica que
- * los identifica. Ofrece soporte para varios idiomas.
- * 
- * @author Pedro Suarez Casal
- * @author Iago Porto Diaz
- */
-public final class DiccionarioAperturas {
-
-	/**
-	 * Tama&#241;o de la Tabla Hash. Se elige 2017 porque es el numero primo mas
-	 * cercano a 2014, que es el numero de entradas del fichero eco.dat
-	 */
-	private final static int CAPACIDAD = 2017;
-
-	/**
-	 * Constante que representa el nombre del fichero donde estan las aperturas.
-	 */
-	private final static String NOMBRE_FICHERO_APERTURAS = &quot;eco&quot;;
-
-	/**
-	 * Representa la extension que indica en que idioma estan las aperturas
-	 * (_es, _en, etc).
-	 */
-	private static String SUFIJO_FICHERO_APERTURAS;
-
-	/**
-	 * Constante que representa la extension del fichero donde estan las
-	 * aperturas.
-	 */
-	private final static String EXTENSION_FICHERO_APERTURAS = &quot;.dat&quot;;
-
-	/**
-	 * Tabla Hash donde se almacenan los nombres de aperturas. Las claves se
-	 * generan a partir del numero de la posicion.
-	 */
-	private HashMap&lt;Integer, String&gt; tabla;
-
-	/**
-	 * Idioma de las aperturas.
-	 */
-	private Locale idioma;
-
-	/**
-	 * Crea una nueva instancia de la clase y crea la Tabla Hash con capacidad
-	 * CAPACIDAD.
-	 */
-	public DiccionarioAperturas(Locale id) {
-		tabla = new HashMap&lt;Integer, String&gt;(CAPACIDAD);
-		// Segun el idioma que se use en el programa, se cargan las aperturas en
-		// ingles o en castellano.
-		idioma = id;
-		String lang = idioma.getLanguage();
-		if (lang.equals(&quot;en&quot;) || lang.equals(&quot;de&quot;))
-			SUFIJO_FICHERO_APERTURAS = &quot;_en&quot;;
-		else
-			SUFIJO_FICHERO_APERTURAS = &quot;_es&quot;;
-	}
-
-	/**
-	 * Lee el fichero de aperturas FICHERO_APERTURAS e introduce sus datos en la
-	 * Tabla Hash.
-	 */
-	public void parse() throws FileNotFoundException, IOException {
-		byte[] text;
-		String c;
-		String[] lineas, partes;
-		String eco, apertura, variante;
-		StringBuffer aInsertar;
-		Integer clave;
-		FileInputStream ent;
-		ent = new FileInputStream(NOMBRE_FICHERO_APERTURAS
-				+ SUFIJO_FICHERO_APERTURAS + EXTENSION_FICHERO_APERTURAS);
-		text = new byte[ent.available()];
-		ent.read(text);
-		ent.close();
-		c = new String(text);
-		lineas = c.split(&quot;\n&quot;);
-		for (int i = 0; i &lt; lineas.length; i++) {
-			partes = lineas[i].split(&quot;\t&quot;);
-			clave = new Integer(partes[0]);
-			eco = partes[1];
-			apertura = partes[2];
-			variante = partes[3];
-			aInsertar = new StringBuffer(eco + &quot; &quot; + apertura + &quot;, &quot; + variante);
-			if (aInsertar.charAt(aInsertar.length() - 2) == ',') {
-				aInsertar.deleteCharAt(aInsertar.length() - 1);
-				aInsertar.deleteCharAt(aInsertar.length() - 1);
-			}
-			tabla.put(clave, aInsertar.toString());
-		}
-	}
-
-	/**
-	 * Este m&#233;todo sirve para consultar si la tabla hash contiene la clave n.
-	 * 
-	 * @param clave
-	 *            La clave hash.
-	 * @return True si la contiene, false en caso contrario.
-	 */
-	public boolean containsKey(int clave) {
-		return tabla.containsKey(clave);
-	}
-
-	/**
-	 * Este m&#233;todo sirve para obtener un nombre de apertura de la tabla hash.
-	 * 
-	 * @param clave
-	 *            La clave hash.
-	 * @return El string que corresponde con la clave n.
-	 */
-	public String get(int clave) {
-		return tabla.get(clave);
-	}
-}
\ No newline at end of file

Copied: trunk/MihailChessLib/com/mihail/openings/Openings.java (from rev 27, trunk/MihailChessLib/com/mihail/openings/Aperturas.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/Aperturas.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/openings/Openings.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,41 @@
+package com.mihail.openings;
+
+import java.io.*;
+import java.util.Locale;
+
+import com.mihail.chess.*;
+
+public class Openings {
+	/**
+	 * Tabla hash con las aperturas.
+	 */
+	private OpeningsDictionary aperturas;
+
+	/**
+	 * Recibe el tablero donde se va a mirar la apertura y el idioma en que se
+	 * quieren las aperturas.
+	 * 
+	 * @param loc
+	 * @throws FileNotFoundException
+	 * @throws IOException
+	 */
+	public Openings(Locale loc) throws FileNotFoundException, IOException {
+		// Se construye la Tabla Hash con las aperturas.
+		aperturas = new OpeningsDictionary(loc);
+		aperturas.parse();
+	}
+
+	/**
+	 * Obtiene la apertura que se esta jugando en una Posicion pos
+	 * 
+	 * @param pos
+	 * @return Nombre de la apertura que se esta jugando en la Posicion pos.
+	 */
+	public String getApertura(Position pos) {
+		int clave = pos.getClavePosicion();
+		if (aperturas.containsKey(clave))
+			return aperturas.get(clave);
+		else
+			return null;
+	}
+}

Copied: trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java (from rev 27, trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java)
===================================================================
--- trunk/MihailChessLib/com/mihail/openings/DiccionarioAperturas.java	2005-08-07 23:39:10 UTC (rev 27)
+++ trunk/MihailChessLib/com/mihail/openings/OpeningsDictionary.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -0,0 +1,123 @@
+package com.mihail.openings;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.*;
+
+/**
+ * Esta clase define un objeto DiccionarioAperturas y se encarga de almacenar en
+ * una tabla hash los nombres de las aperturas junto con una clave numerica que
+ * los identifica. Ofrece soporte para varios idiomas.
+ * 
+ * @author Pedro Suarez Casal
+ * @author Iago Porto Diaz
+ */
+public final class OpeningsDictionary {
+
+	/**
+	 * Tama&#241;o de la Tabla Hash. Se elige 2017 porque es el numero primo mas
+	 * cercano a 2014, que es el numero de entradas del fichero eco.dat
+	 */
+	private final static int CAPACIDAD = 2017;
+
+	/**
+	 * Constante que representa el nombre del fichero donde estan las aperturas.
+	 */
+	private final static String NOMBRE_FICHERO_APERTURAS = &quot;eco&quot;;
+
+	/**
+	 * Representa la extension que indica en que idioma estan las aperturas
+	 * (_es, _en, etc).
+	 */
+	private static String SUFIJO_FICHERO_APERTURAS;
+
+	/**
+	 * Constante que representa la extension del fichero donde estan las
+	 * aperturas.
+	 */
+	private final static String EXTENSION_FICHERO_APERTURAS = &quot;.dat&quot;;
+
+	/**
+	 * Tabla Hash donde se almacenan los nombres de aperturas. Las claves se
+	 * generan a partir del numero de la posicion.
+	 */
+	private HashMap&lt;Integer, String&gt; tabla;
+
+	/**
+	 * Idioma de las aperturas.
+	 */
+	private Locale idioma;
+
+	/**
+	 * Crea una nueva instancia de la clase y crea la Tabla Hash con capacidad
+	 * CAPACIDAD.
+	 */
+	public OpeningsDictionary(Locale id) {
+		tabla = new HashMap&lt;Integer, String&gt;(CAPACIDAD);
+		// Segun el idioma que se use en el programa, se cargan las aperturas en
+		// ingles o en castellano.
+		idioma = id;
+		String lang = idioma.getLanguage();
+		if (lang.equals(&quot;en&quot;) || lang.equals(&quot;de&quot;))
+			SUFIJO_FICHERO_APERTURAS = &quot;_en&quot;;
+		else
+			SUFIJO_FICHERO_APERTURAS = &quot;_es&quot;;
+	}
+
+	/**
+	 * Lee el fichero de aperturas FICHERO_APERTURAS e introduce sus datos en la
+	 * Tabla Hash.
+	 */
+	public void parse() throws FileNotFoundException, IOException {
+		byte[] text;
+		String c;
+		String[] lineas, partes;
+		String eco, apertura, variante;
+		StringBuffer aInsertar;
+		Integer clave;
+		FileInputStream ent;
+		ent = new FileInputStream(NOMBRE_FICHERO_APERTURAS
+				+ SUFIJO_FICHERO_APERTURAS + EXTENSION_FICHERO_APERTURAS);
+		text = new byte[ent.available()];
+		ent.read(text);
+		ent.close();
+		c = new String(text);
+		lineas = c.split(&quot;\n&quot;);
+		for (int i = 0; i &lt; lineas.length; i++) {
+			partes = lineas[i].split(&quot;\t&quot;);
+			clave = new Integer(partes[0]);
+			eco = partes[1];
+			apertura = partes[2];
+			variante = partes[3];
+			aInsertar = new StringBuffer(eco + &quot; &quot; + apertura + &quot;, &quot; + variante);
+			if (aInsertar.charAt(aInsertar.length() - 2) == ',') {
+				aInsertar.deleteCharAt(aInsertar.length() - 1);
+				aInsertar.deleteCharAt(aInsertar.length() - 1);
+			}
+			tabla.put(clave, aInsertar.toString());
+		}
+	}
+
+	/**
+	 * Este m&#233;todo sirve para consultar si la tabla hash contiene la clave n.
+	 * 
+	 * @param clave
+	 *            La clave hash.
+	 * @return True si la contiene, false en caso contrario.
+	 */
+	public boolean containsKey(int clave) {
+		return tabla.containsKey(clave);
+	}
+
+	/**
+	 * Este m&#233;todo sirve para obtener un nombre de apertura de la tabla hash.
+	 * 
+	 * @param clave
+	 *            La clave hash.
+	 * @return El string que corresponde con la clave n.
+	 */
+	public String get(int clave) {
+		return tabla.get(clave);
+	}
+}
\ No newline at end of file

Modified: trunk/MihailChessLib/com/mihail/pgn/PGNParser.java
===================================================================
--- trunk/MihailChessLib/com/mihail/pgn/PGNParser.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/pgn/PGNParser.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -11,14 +11,14 @@
  * @author Martin Rademacher <A HREF="https://lists.berlios.de/mailman/listinfo/mihailchess-svn">mano at radebatz.net</A>
  * @versionServidor $Id: PGNParser.jj,v 1.4 2002/06/15 09:00:47 radebatz Exp $
  */
-public final class PGNParser extends Analizador implements PGNParserConstants {
+public final class PGNParser extends Parser implements PGNParserConstants {
 	public static final int NEXT_TOKEN = 1;
 
 	public static final int SKIP_TOKEN = 0;
 
 	public static final int EOF = -1;
 
-	Partida partida = new Partida();
+	Game partida = new Game();
 
 	public void analizar() throws ParseException {
 		while (parse() != -1) {
@@ -415,7 +415,7 @@
 		 * token.setTerminator(imageOf(gg)); return token;
 		 */
 		listaPartidas.add(partida);
-		partida = new Partida();
+		partida = new Game();
 	}
 
 	/**
@@ -1039,12 +1039,12 @@
 		java.io.FileWriter f = new java.io.FileWriter(archivo);
 
 		for (int i = 0; i &lt; listaPartidas.size(); i++) {
-			Partida p = listaPartidas.get(i);
+			Game p = listaPartidas.get(i);
 			PGNParser.guardarPartida(archivo, p);
 		}
 	}
 
-	public static void guardarPartida(String archivo, Partida p)
+	public static void guardarPartida(String archivo, Game p)
 			throws IOException {
 		java.io.FileWriter f = new java.io.FileWriter(archivo, true);
 

Modified: trunk/MihailChessLib/com/mihail/test/PositionTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/test/PositionTest.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -9,12 +9,12 @@
  */
 package com.mihail.test;
 
-import com.mihail.chess.Pieza;
-import com.mihail.chess.Posicion;
+import com.mihail.chess.Piece;
+import com.mihail.chess.Position;
 import junit.framework.TestCase;
 
-import static com.mihail.chess.Logica.Bando;
-import static com.mihail.chess.Pieza.Tipo;
+import static com.mihail.chess.Board.Bando;
+import static com.mihail.chess.Piece.Tipo;
 
 public class PositionTest extends TestCase {
 
@@ -22,7 +22,7 @@
 	 * Test method for 'com.mihail.chess.Position.Position()'
 	 */
 	public void testPosition() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		assertEquals(&quot;8/8/8/8/8/8/8/8 w - - 0 1&quot;, p.getFEN());
 	}
 
@@ -30,22 +30,22 @@
 	 * Test method for 'com.mihail.chess.Position.getFEN()'
 	 */
 	public void testGetFEN() {
-		Posicion p = new Posicion();
-		p.setPosicion(Posicion.CAD_INICIAL);
+		Position p = new Position();
+		p.setPosicion(Position.CAD_INICIAL);
 		assertEquals(
 				&quot;rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1&quot;, p
 						.getFEN());
 	}
 
 	public void testSetPosicion() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 	}
 
 	/*
 	 * Test method for 'com.mihail.chess.Position.setTurno()'
 	 */
 	public void testSetTurno() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		Bando turno = p.getTurno();
 		p.setTurno();
 		p.setTurno();
@@ -56,7 +56,7 @@
 	 * Test method for 'com.mihail.chess.Position.setTurno(int)'
 	 */
 	public void testSetTurnoInt() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		p.setTurno(Bando.BLANCO);
 		assertEquals(Bando.BLANCO, p.getTurno());
 		p.setTurno(Bando.NEGRO);
@@ -67,18 +67,18 @@
 	 * Test method for 'com.mihail.chess.Position.setEnroqueCorto(int, boolean)'
 	 */
 	public void testSetEnroqueCorto() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.REY), 'e', '1');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
 		p.setEnroqueCorto(Bando.BLANCO, true);
 		assertFalse(p.getEnroqueCorto(Bando.BLANCO));
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), 'h', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'h', '1');
 		p.setEnroqueCorto(Bando.BLANCO, true);
 		assertTrue(p.getEnroqueCorto(Bando.BLANCO));
 
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.REY), 'e', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
 		p.setEnroqueCorto(Bando.NEGRO, true);
 		assertFalse(p.getEnroqueCorto(Bando.NEGRO));
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), 'h', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'h', '8');
 		p.setEnroqueCorto(Bando.NEGRO, true);
 		assertTrue(p.getEnroqueCorto(Bando.NEGRO));
 	}
@@ -87,18 +87,18 @@
 	 * Test method for 'com.mihail.chess.Position.setEnroqueLargo(int, boolean)'
 	 */
 	public void testSetEnroqueLargo() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.REY), 'e', '1');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.REY), 'e', '1');
 		p.setEnroqueLargo(Bando.BLANCO, true);
 		assertEquals(false, p.getEnroqueLargo(Bando.BLANCO));
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.TORRE), 'a', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.TORRE), 'a', '1');
 		p.setEnroqueLargo(Bando.BLANCO, true);
 		assertTrue(p.getEnroqueLargo(Bando.BLANCO));
 
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.REY), 'e', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.REY), 'e', '8');
 		p.setEnroqueLargo(Bando.NEGRO, true);
 		assertFalse(p.getEnroqueLargo(Bando.NEGRO));
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.TORRE), 'a', '8');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.TORRE), 'a', '8');
 		p.setEnroqueLargo(Bando.NEGRO, true);
 		assertTrue(p.getEnroqueLargo(Bando.NEGRO));
 	}
@@ -114,7 +114,7 @@
 	 * Test method for 'com.mihail.chess.Position.borrarPieza(char, char)'
 	 */
 	public void testBorrarPieza() {
-		Posicion p = new Posicion(&quot;8/8/8/7p/8/8/8/8 w - h 0 1&quot;);
+		Position p = new Position(&quot;8/8/8/7p/8/8/8/8 w - h 0 1&quot;);
 		// Al borrar la pieza, alPaso deberia resetearse, ya que no hay peon en
 		// esa columna
 		p.borrarPieza('h', '5');
@@ -153,11 +153,11 @@
 	 * Test method for 'com.mihail.chess.Position.getClavePosicion()'
 	 */
 	public void testGetClavePosicion() {
-		Posicion p = new Posicion();
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
+		Position p = new Position();
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
 		int clave = p.getClavePosicion();
 		p.borrarPieza('d', '4');
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.CABALLO), 'd', '4');
 		assertEquals(clave, p.getClavePosicion());
 	}
 
@@ -165,18 +165,18 @@
 	 * Test method for 'com.mihail.chess.Position.setAlPaso(char)'
 	 */
 	public void testSetAlPaso() {
-		Posicion p = new Posicion();
+		Position p = new Position();
 		// Comprobamos que no se pone siempre alPaso
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), 'a', '1');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'a', '1');
 		p.setAlPaso('a');
 		assertEquals(p.getAlPaso(), 0);
 		// Comprobamos que al poner un peon negro en una casilla de alPaso, la
 		// funcion deja
-		p.setPieza(new Pieza(Bando.NEGRO, Tipo.PEON), 'h', '5');
+		p.setPieza(new Piece(Bando.NEGRO, Tipo.PEON), 'h', '5');
 		p.setAlPaso('h');
 		assertEquals(p.getAlPaso(), 'h');
 		// Probamos lo mismo pero con un peon blanco
-		p.setPieza(new Pieza(Bando.BLANCO, Tipo.PEON), 'h', '4');
+		p.setPieza(new Piece(Bando.BLANCO, Tipo.PEON), 'h', '4');
 		p.setTurno(Bando.NEGRO);
 		p.setAlPaso('h');
 		assertEquals(p.getAlPaso(), 'h');

Modified: trunk/MihailChessLib/com/mihail/test/RelojTest.java
===================================================================
--- trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-13 15:54:52 UTC (rev 32)
+++ trunk/MihailChessLib/com/mihail/test/RelojTest.java	2005-08-14 12:21:56 UTC (rev 33)
@@ -3,14 +3,14 @@
 import java.util.Observable;
 import java.util.Observer;
 
-import com.mihail.clock.Reloj;
-import com.mihail.clock.RelojException;
+import com.mihail.clock.Clock;
+import com.mihail.clock.ClockException;
 
 public class RelojTest implements Observer {
 
 	public void update(Observable arg0, Object arg1) {
-		if (arg0 instanceof Reloj) {
-			Reloj r = (Reloj) arg0;
+		if (arg0 instanceof Clock) {
+			Clock r = (Clock) arg0;
 			if (r.getDecimas() == 0) {
 				System.out.println(r.getHoras() + &quot;:&quot; + r.getMinutos() + &quot;:&quot;
 						+ r.getSegundos() + &quot;.&quot; + r.getDecimas());
@@ -21,11 +21,11 @@
 	}
 
 	public static void main(String args[]) {
-		Reloj reloj = null;
+		Clock reloj = null;
 		RelojTest relojTest = null;
 		try {
-			reloj = new Reloj(0, 0, 10);
-		} catch (RelojException e) {
+			reloj = new Clock(0, 0, 10);
+		} catch (ClockException e) {
 		}
 		relojTest = new RelojTest();
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000004.html">[Mihailchess-svn] r32 - trunk/MihailChessLib/com/mihail/chess
</A></li>
	<LI>Next message: <A HREF="000005.html">[Mihailchess-svn] r34 - trunk/MihailChessLib/com/mihail/pgn
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#9">[ date ]</a>
              <a href="thread.html#9">[ thread ]</a>
              <a href="subject.html#9">[ subject ]</a>
              <a href="author.html#9">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/mihailchess-svn">More information about the Mihailchess-svn
mailing list</a><br>
</body></html>
